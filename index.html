<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Maxime El Masri">
<meta name="author" content="Jérôme Morio">
<meta name="author" content="Florian Simatos">
<meta name="dcterms.date" content="2023-01-16">
<meta name="keywords" content="Importance sampling, High dimension, Gaussian covariance matrix, Kullback-Leibler divergence, Projection">
<meta name="description" content="This document provides a dimension-reduction strategy in order to improve the performance of importance sampling in high dimension.">

<title>Optimal projection for parametric importance sampling in high dimension</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>


<script src="content_files/libs/clipboard/clipboard.min.js"></script>
<script src="content_files/libs/quarto-html/quarto.js"></script>
<script src="content_files/libs/quarto-html/popper.min.js"></script>
<script src="content_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="content_files/libs/quarto-html/anchor.min.js"></script>
<link href="content_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="content_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="content_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="content_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="content_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="content_files/libs/quarto-contrib/pseudocode-1.0.0/pseudocode.min.js"></script>
<link href="content_files/libs/quarto-contrib/pseudocode-1.0.0/pseudocode.min.css" rel="stylesheet">
<style>
    .quarto-title-block .quarto-title-banner {
      color: #FFFFFF;
background: #034E79;
    }
    </style>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

</head>

<body>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><a href="https://computo.sfds.asso.fr">
        <img src="https://computo.sfds.asso.fr/assets/img/logo_notext_white.png" height="60px">
      </a> &nbsp; Optimal projection for parametric importance sampling in high dimension</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> source</button></div></div>
            <p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="Creative Commons BY License"></a>
ISSN 2824-7795</p>
            <div>
        <div class="description">
          <p>This document provides a dimension-reduction strategy in order to improve the performance of importance sampling in high dimension.</p>
        </div>
      </div>
                </div>
  </div>
    
    <div class="quarto-title-meta-author">
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-heading">Affiliations</div>
          
          <div class="quarto-title-meta-contents">
        Maxime El Masri <a href="https://orcid.org/0000-0002-9127-4503" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.onera.fr/">ONERA/DTIS</a>, <a href="https://www.isae-supaero.fr/">ISAE-SUPAERO</a>, <a href="https://www.univ-toulouse.fr/">Université de Toulouse</a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://www.onera.fr/en/staff/jerome-morio?destination=node/981">Jérôme Morio</a> <a href="https://orcid.org/0000-0002-8811-8956" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.onera.fr/">ONERA/DTIS</a>, <a href="https://www.univ-toulouse.fr/">Université de Toulouse</a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://pagespro.isae-supaero.fr/florian-simatos/">Florian Simatos</a> 
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.isae-supaero.fr/">ISAE-SUPAERO</a>, <a href="https://www.univ-toulouse.fr/">Université de Toulouse</a>
                </p>
            </div>
        </div>
                    
  <div class="quarto-title-meta">
                                
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 16, 2023</p>
      </div>
    </div>
                                    
      
                  
      <div>
      <div class="quarto-title-meta-heading">Keywords</div>
      <div class="quarto-title-meta-contents">
        <p class="date">Importance sampling, High dimension, Gaussian covariance matrix, Kullback-Leibler divergence, Projection</p>
      </div>
    </div>
    
    <div>
      <div class="quarto-title-meta-heading">Status</div>
      <div class="quarto-title-meta-contents">
              <p class="date">draft</p>
                  </div>
    </div>

  </div>
                                                
  <div>
    <div class="abstract">
    <div class="abstract-title">Abstract</div>
      <p>In this paper we propose a dimension-reduction strategy in order to improve the performance of importance sampling in high dimension. The idea is to estimate variance terms in a small number of suitably chosen directions. We first prove that the optimal directions, i.e., the ones that minimize the Kullback–Leibler divergence with the optimal auxiliary density, are the eigenvectors associated to extreme (small or large) eigenvalues of the optimal covariance matrix. We then perform extensive numerical experiments that show that as dimension increases, these directions give estimations which are very close to optimal. Moreover, we show that the estimation remains accurate even when a simple empirical estimator of the covariance matrix is used to estimate these directions. These theoretical and numerical results open the way for different generalizations, in particular the incorporation of such ideas in adaptive importance sampling schemes.</p>
    </div>
  </div>

  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="toc-section-number">1</span>  Introduction</a></li>
  <li><a href="#sec-IS" id="toc-sec-IS" class="nav-link" data-scroll-target="#sec-IS"><span class="toc-section-number">2</span>  Importance Sampling</a></li>
  <li><a href="#sec-main-result" id="toc-sec-main-result" class="nav-link" data-scroll-target="#sec-main-result"><span class="toc-section-number">3</span>  Main result and positioning of the paper</a>
  <ul class="collapse">
  <li><a href="#sec-proj" id="toc-sec-proj" class="nav-link" data-scroll-target="#sec-proj"><span class="toc-section-number">3.1</span>  Projecting on a low dimensional subspace</a></li>
  <li><a href="#sec-main-result-positioning" id="toc-sec-main-result-positioning" class="nav-link" data-scroll-target="#sec-main-result-positioning"><span class="toc-section-number">3.2</span>  Main result of the paper</a></li>
  <li><a href="#sec-choicek" id="toc-sec-choicek" class="nav-link" data-scroll-target="#sec-choicek"><span class="toc-section-number">3.3</span>  Choice of the number of dimensions <span class="math inline">k</span></a></li>
  <li><a href="#sec-mm" id="toc-sec-mm" class="nav-link" data-scroll-target="#sec-mm"><span class="toc-section-number">3.4</span>  Theoretical result concerning the projection on <span class="math inline">\mathbf{m}^*</span></a></li>
  </ul></li>
  <li><a href="#sec-proof" id="toc-sec-proof" class="nav-link" data-scroll-target="#sec-proof"><span class="toc-section-number">4</span>  Proof of Theorems Theorem&nbsp;1 and Theorem&nbsp;2</a></li>
  <li><a href="#sec-num-results-framework" id="toc-sec-num-results-framework" class="nav-link" data-scroll-target="#sec-num-results-framework"><span class="toc-section-number">5</span>  Framework for the numerical results</a>
  <ul class="collapse">
  <li><a href="#general-framework" id="toc-general-framework" class="nav-link" data-scroll-target="#general-framework"><span class="toc-section-number">5.1</span>  General framework</a></li>
  <li><a href="#sec-def_cov" id="toc-sec-def_cov" class="nav-link" data-scroll-target="#sec-def_cov"><span class="toc-section-number">5.2</span>  Choice of the auxiliary density <span class="math inline">g'</span> for the Gaussian model</a></li>
  <li><a href="#choice-of-the-auxiliary-density-g-for-the-von-misesfishernakagami-model" id="toc-choice-of-the-auxiliary-density-g-for-the-von-misesfishernakagami-model" class="nav-link" data-scroll-target="#choice-of-the-auxiliary-density-g-for-the-von-misesfishernakagami-model"><span class="toc-section-number">5.3</span>  Choice of the auxiliary density <span class="math inline">g'</span> for the von Mises–Fisher–Nakagami model</a></li>
  </ul></li>
  <li><a href="#sec-test-cases" id="toc-sec-test-cases" class="nav-link" data-scroll-target="#sec-test-cases"><span class="toc-section-number">6</span>  Numerical results on five test cases</a>
  <ul class="collapse">
  <li><a href="#sec-sub:sum" id="toc-sec-sub:sum" class="nav-link" data-scroll-target="#sec-sub\:sum"><span class="toc-section-number">6.1</span>  Test case 1: one-dimensional optimal projection</a>
  <ul class="collapse">
  <li><a href="#evolution-of-the-partial-kl-divergence-and-spectrum" id="toc-evolution-of-the-partial-kl-divergence-and-spectrum" class="nav-link" data-scroll-target="#evolution-of-the-partial-kl-divergence-and-spectrum"><span class="toc-section-number">6.1.1</span>  Evolution of the partial KL divergence and spectrum</a></li>
  <li><a href="#numerical-results" id="toc-numerical-results" class="nav-link" data-scroll-target="#numerical-results"><span class="toc-section-number">6.1.2</span>  Numerical results</a></li>
  </ul></li>
  <li><a href="#sec-sub:parabol" id="toc-sec-sub:parabol" class="nav-link" data-scroll-target="#sec-sub\:parabol"><span class="toc-section-number">6.2</span>  Test case 2: projection in 2 directions</a>
  <ul class="collapse">
  <li><a href="#evolution-of-the-partial-kl-divergence-and-spectrum-1" id="toc-evolution-of-the-partial-kl-divergence-and-spectrum-1" class="nav-link" data-scroll-target="#evolution-of-the-partial-kl-divergence-and-spectrum-1"><span class="toc-section-number">6.2.1</span>  Evolution of the partial KL divergence and spectrum</a></li>
  <li><a href="#numerical-results-1" id="toc-numerical-results-1" class="nav-link" data-scroll-target="#numerical-results-1"><span class="toc-section-number">6.2.2</span>  Numerical results</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#bibliography" id="toc-bibliography" class="nav-link" data-scroll-target="#bibliography">Bibliography</a></li>
  </ul>
</nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">



<div class="cell" data-execution_count="1">
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy <span class="im">as</span> sp</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> CEIS_vMFNM <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display, Math, Latex</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Markdown</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tabulate <span class="im">import</span> tabulate</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>Importance Sampling (IS) is a widely considered stochastic method to estimate integrals of the form <span class="math inline">E = \int \phi f</span> with a black-box function <span class="math inline">\phi</span> and a probability density function (pdf) <span class="math inline">f</span>. It rests upon the choice of an auxiliary density which, when suitably chosen, can significantly improve the situation compared to the naive Monte Carlo (MC) method <span class="citation" data-cites="AgapiouEtAl_ImportanceSamplingIntrinsic_2017">(<a href="#ref-AgapiouEtAl_ImportanceSamplingIntrinsic_2017" role="doc-biblioref">Agapiou et al. 2017</a>)</span>, <span class="citation" data-cites="OwenZhou_SafeEffectiveImportance_2000">(<a href="#ref-OwenZhou_SafeEffectiveImportance_2000" role="doc-biblioref">Owen and Zhou 2000</a>)</span>. The theoretical optimal IS density, also called zero-variance density, is defined by <span class="math inline">\phi f / E</span> when <span class="math inline">\phi</span> is a positive function. This density is not available in practice as it involves the unknown integral <span class="math inline">E</span>, but a classical strategy consists in searching an optimal approximation in a parametric family of densities. By minimising a ‘’distance’’ with the optimal IS density, such as the Kullback–Leibler divergence, one can find optimal parameters in this family to get an efficient sampling pdf. Adaptive Importance Sampling (AIS) algorithms, such as the Mixture Population Monte Carlo method <span class="citation" data-cites="CappeEtAl_AdaptiveImportanceSampling_2008">(<a href="#ref-CappeEtAl_AdaptiveImportanceSampling_2008" role="doc-biblioref">Cappé et al. 2008</a>)</span>, the Adaptive Multiple Importance Sampling method <span class="citation" data-cites="CornuetEtAl_AdaptiveMultipleImportance_2012">(<a href="#ref-CornuetEtAl_AdaptiveMultipleImportance_2012" role="doc-biblioref">Cornuet et al. 2012</a>)</span>, or the Cross Entropy method <span class="citation" data-cites="RubinsteinKroese_CrossentropyMethodUnified_2011">(<a href="#ref-RubinsteinKroese_CrossentropyMethodUnified_2011" role="doc-biblioref">Reuven Y. Rubinstein and Kroese 2011</a>)</span>, estimate the optimal parameters adaptively by updating intermediate parameters <span class="citation" data-cites="BugalloEtAl_AdaptiveImportanceSampling_2017">(<a href="#ref-BugalloEtAl_AdaptiveImportanceSampling_2017" role="doc-biblioref">Bugallo et al. 2017</a>)</span>.</p>
<p>An intense research activity has made these techniques work very well, but only for moderate dimensions. In high dimension, most of these techniques actually fail to give efficient parameters for two reasons. The first one is the so-called weight degeneracy problem, which is that in high dimension, the weights appearing in the IS densities (which are self-normalized likelihood ratios) degenerate. More precisely, the largest weight takes all the mass, while all other weights are negligible so that the final estimation essentially uses only one sample, see for instance <span class="citation" data-cites="BengtssonEtAl_CurseofdimensionalityRevisitedCollapse_2008">(<a href="#ref-BengtssonEtAl_CurseofdimensionalityRevisitedCollapse_2008" role="doc-biblioref">Bengtsson, Bickel, and Li 2008</a>)</span> for a theoretical analysis in the related context of particle filtering. But even without likelihood ratios, such techniques may fail if they need to estimate high-dimensional parameters such as covariance matrices, whose size increases quadratically in the dimension <span class="citation" data-cites="AshurbekovaEtAl_OptimalShrinkageRobust_">(<a href="#ref-AshurbekovaEtAl_OptimalShrinkageRobust_" role="doc-biblioref">Ashurbekova et al. 2020</a>)</span>, <span class="citation" data-cites="LedoitWolf_WellconditionedEstimatorLargedimensional_2004">(<a href="#ref-LedoitWolf_WellconditionedEstimatorLargedimensional_2004" role="doc-biblioref">Ledoit and Wolf 2004</a>)</span>. The conditions under which importance sampling is applicable in high dimension are notably investigated in a reliability context in <span class="citation" data-cites="AuBeck_ImportantSamplingHigh_2003">(<a href="#ref-AuBeck_ImportantSamplingHigh_2003" role="doc-biblioref">Au and Beck 2003</a>)</span>: it is remarked that the optimal covariance matrix should not deviate significantly from the identity matrix. <span class="citation" data-cites="El-LahamEtAl_RecursiveShrinkageCovariance_">(<a href="#ref-El-LahamEtAl_RecursiveShrinkageCovariance_" role="doc-biblioref">El-Laham, Elvira, and Bugallo 2019</a>)</span> tackle the weight degeneracy problem by applying a recursive shrinkage of the covariance matrix, which is constructed iteratively with a weighted sum of the sample covariance estimator and a biased, but more stable, estimator. Concerning the second problem of having to estimate high-dimensional parameters, the idea was recently put forth to reduce the effective dimension by only estimating these parameters (in particular the covariance matrix) in suitable directions <span class="citation" data-cites="MasriEtAl_ImprovementCrossentropyMethod_2020">(<a href="#ref-MasriEtAl_ImprovementCrossentropyMethod_2020" role="doc-biblioref">El Masri, Morio, and Simatos 2021</a>)</span>, <span class="citation" data-cites="UribeEtAl_CrossentropybasedImportanceSampling_2020">(<a href="#ref-UribeEtAl_CrossentropybasedImportanceSampling_2020" role="doc-biblioref">Uribe et al. 2021</a>)</span>. In this paper we seek to delve deeper into this idea. The main contribution of the present paper is to identify the optimal directions in the fundamental case when the parametric family is Gaussian, and perform numerical simulations in order to understand how they behave in practice. In particular, we propose directions which, in contrast to the recent paper <span class="citation" data-cites="UribeEtAl_CrossentropybasedImportanceSampling_2020">(<a href="#ref-UribeEtAl_CrossentropybasedImportanceSampling_2020" role="doc-biblioref">Uribe et al. 2021</a>)</span>, does not require the objective function to be differentiable, and moreover optimizes the Kullback–Leibler distance with the optimal density instead of simply an upper bound on it, as in <span class="citation" data-cites="UribeEtAl_CrossentropybasedImportanceSampling_2020">(<a href="#ref-UribeEtAl_CrossentropybasedImportanceSampling_2020" role="doc-biblioref">Uribe et al. 2021</a>)</span>. In <a href="#sec-proj">Section&nbsp;3.1</a> we elaborate in more details on the differences between the two approaches.</p>
<p>The paper is organised as follows: in <a href="#sec-IS">Section&nbsp;2</a> we recall the foundations of IS. In <a href="#sec-main-result">Section&nbsp;3</a>, we state our main theoretical result and we compare it with the current state-of-the-art. <a href="#sec-proof">Section&nbsp;4</a> presents the proof of our theoretical result; <a href="#sec-num-results-framework">Section&nbsp;5</a> introduces the numerical framework that we have adopted, and <a href="#sec-test-cases">Section&nbsp;6</a> presents the numerical results obtained on five different test cases to assess the efficiency of the directions that we propose. We conclude in <strong>?@sec-Ccl</strong> with a summary and research perspectives.</p>
</section>
<section id="sec-IS" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Importance Sampling</h1>
<p>We consider the problem of estimating the following integral: <span class="math display">
    E=\mathbb{E}_f(\phi(\mathbf{X}))=\int \phi(\mathbf{x})f(\mathbf{x})\textrm{d} \mathbf{x},
    </span> where <span class="math inline">\mathbf{X}</span> is a random vector in <span class="math inline">\mathbb{R}^n</span> with Gaussian standard pdf <span class="math inline">f</span>, and <span class="math inline">\phi: \mathbb{R}^n\rightarrow\mathbb{R}_+</span> is a real-valued, non-negative function. If one were to relax this Gaussian standard assumption, one would need to look for covariance matrices in a different auxiliary set. The function <span class="math inline">\phi</span> is considered as a black-box function which is potentially expensive to evaluate, which means the number of calls to <span class="math inline">\phi</span> should be limited.</p>
<p>IS is a widely considered approach to reduce the variance of the classical Monte Carlo estimator of <span class="math inline">E</span>. The idea of IS is to generate a random sample <span class="math inline">\mathbf{X}_1,\ldots,\mathbf{X}_N</span> from an auxiliary density <span class="math inline">g</span>, instead of <span class="math inline">f</span>, and to compute the following estimator: <span id="eq-hatE"><span class="math display">
    \widehat{E}_N=\frac{1}{N}\sum_{i=1}^N \phi(\mathbf{X}_i)L(\mathbf{X}_i),
     \tag{1}</span></span> with <span class="math inline">L=f/g</span> the likelihood ratio, or importance weight, and the density <span class="math inline">g</span>, called importance sampling density, is such that <span class="math inline">g(\mathbf{x})=0</span> implies <span class="math inline">\phi(\mathbf{x}) f(\mathbf{x})=0</span> for every <span class="math inline">\mathbf{x}</span> (which makes the product <span class="math inline">\phi L</span> well-defined). This estimator is consistent and unbiased but its accuracy strongly depends on the choice of the auxiliary density <span class="math inline">g</span>. It is well known that the optimal choice for <span class="math inline">g</span> is <span class="citation" data-cites="bucklew2013introduction">(<a href="#ref-bucklew2013introduction" role="doc-biblioref">Bucklew 2013</a>)</span> <span class="math display">
    g^*(\mathbf{x})=\dfrac{\phi(\mathbf{x})f(\mathbf{x})}{E}, \ \mathbf{x}\in\mathbb{R}^n.
    </span> Indeed, for this choice we have <span class="math inline">\phi L = E</span> and so <span class="math inline">\widehat E_N</span> is actually the deterministic estimator <span class="math inline">E</span>. For this reason, <span class="math inline">g^*</span> is sometimes called zero-variance density, a terminology that we will adopt here. Of course, <span class="math inline">g^*</span> is only of theoretical interest as it depends on the unknown integral <span class="math inline">E</span>. However, it gives an idea of good choices for the auxiliary density <span class="math inline">g</span>, and we will seek to approximate <span class="math inline">g^*</span> by an auxiliary density that minimizes a distance between <span class="math inline">g^*</span> and a given parametric family of densities.</p>
<p>In this paper, the parametric family of densities is the Gaussian family <span class="math inline">\{g_{\mathbf{m}, \Sigma}: \mathbf{m} \in \mathbb{R}^n, \Sigma \in \mathcal{S}^+_n\}</span>, where <span class="math inline">g_{\mathbf{m}, \Sigma}</span> denotes the Gaussian density with mean <span class="math inline">\mathbf{m} \in \mathbb{R}^n</span> and covariance matrix <span class="math inline">\Sigma \in \mathcal{S}^+_n</span> with <span class="math inline">\mathcal{S}^+_n \subset \mathbb{R}^{n \times n}</span> the set of symmetric, positive-definite matrices: <span class="math display">
    g_{\mathbf{m},\Sigma}(\mathbf{x})=\dfrac{1}{ (2\pi)^{n/2} \lvert \Sigma \rvert^{1/2}} \exp\left(-\frac{1}{2}(\mathbf{x}-\mathbf{m})^\top\Sigma^{-1}(\mathbf{x}-\mathbf{m})\right), \ \mathbf{x} \in \mathbb{R}^n.
    </span> with <span class="math inline">\lvert \Sigma \rvert</span> the determinant of <span class="math inline">\Sigma</span>. Moreover, we will consider the Kullback–Leibler (KL) divergence to measure a ‘’distance’’ between <span class="math inline">g^*</span> and <span class="math inline">g_{\mathbf{m}, \Sigma}</span>. Recall that for two densities <span class="math inline">f</span> and <span class="math inline">h</span>, with <span class="math inline">f</span> absolutely continuous with respect to <span class="math inline">h</span>, the KL divergence <span class="math inline">D(f,h)</span> between <span class="math inline">f</span> and <span class="math inline">h</span> is defined by: <span class="math display">
    D(f,h)=\mathbb{E}_{f}\left[\log \left( \frac{f(\mathbf{X})}{h(\mathbf{X})} \right) \right] = \int \log \left( \frac{f(\mathbf{x})}{h(\mathbf{x})} \right)f(\mathbf{x}) \textrm{d} \mathbf{x}.
    </span> Thus, our goal is to approximate <span class="math inline">g^*</span> by <span class="math inline">g_{\mathbf{m}^*, \Sigma^*}</span> with the optimal mean vector <span class="math inline">\mathbf{m}^*</span> and the optimal covariance matrix <span class="math inline">\Sigma^*</span> given by: <span id="eq-argminDkl"><span class="math display">
    (\mathbf{m}^*,\Sigma^*) = \arg\min \left\{ D(g^*,g_{\mathbf{m},\Sigma}): \mathbf{m} \in \mathbb{R}^n, \Sigma \in \mathcal{S}_n^+ \right\}.
     \tag{2}</span></span> In the Gaussian case of the present setting, it is well-known that <span class="math inline">\mathbf{m}^*</span> and <span class="math inline">\Sigma^*</span> are simply the mean and variance of the zero-variance density <span class="citation" data-cites="RubinsteinKroese_CrossentropyMethodUnified_2011">(<a href="#ref-RubinsteinKroese_CrossentropyMethodUnified_2011" role="doc-biblioref">Reuven Y. Rubinstein and Kroese 2011</a>)</span>, <span class="citation" data-cites="RubinsteinKroese_SimulationMonteCarlo_2017">(<a href="#ref-RubinsteinKroese_SimulationMonteCarlo_2017" role="doc-biblioref">Reuven Y. Rubinstein and Kroese 2017</a>)</span>: <span id="eq-mstar"><span class="math display">
    \mathbf{m}^*=\mathbb{E}_{g^*}(\mathbf{X}) \hspace{0.5cm} \text{ and } \hspace{0.5cm} \Sigma^* = \textrm{Var}_{g^*} \left(\mathbf{X}\right).
     \tag{3}</span></span></p>
</section>
<section id="sec-main-result" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Main result and positioning of the paper</h1>
<section id="sec-proj" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-proj"><span class="header-section-number">3.1</span> Projecting on a low dimensional subspace</h2>
<p>As <span class="math inline">g^*</span> is unknown (although, as will be considered below, we can in principle sample from it since it is known up to a multiplicative constant), the optimal parameters <span class="math inline">\mathbf{m}^*</span> and <span class="math inline">\Sigma^*</span> given by <a href="#eq-mstar">Equation&nbsp;3</a> are not directly computable. Therefore, usual estimation schemes start with estimating <span class="math inline">\mathbf{m}^*</span> and <span class="math inline">\Sigma^*</span>, say through <span class="math inline">\widehat{\mathbf{m}}^*</span> and <span class="math inline">\widehat{\Sigma}^*</span>, respectively, and then use these approximations to estimate <span class="math inline">E</span> through <a href="#eq-hatE">Equation&nbsp;1</a> with the auxiliary density <span class="math inline">g_{\widehat{\mathbf{m}}^*, \widehat{\Sigma}^*}</span>. Although the estimation of <span class="math inline">E</span> with the auxiliary density <span class="math inline">g_{\mathbf{m}^*, \Sigma^*}</span> usually provides very good results, it is well-known that in high dimension, the additional error induced by the estimations of <span class="math inline">\mathbf{m}^*</span> and <span class="math inline">\Sigma^*</span> severely degrades the accuracy of the final estimation <span class="citation" data-cites="PapaioannouEtAl_ImprovedCrossEntropybased_2019">(<a href="#ref-PapaioannouEtAl_ImprovedCrossEntropybased_2019" role="doc-biblioref">Papaioannou, Geyer, and Straub 2019</a>)</span>, <span class="citation" data-cites="UribeEtAl_CrossentropybasedImportanceSampling_2020">(<a href="#ref-UribeEtAl_CrossentropybasedImportanceSampling_2020" role="doc-biblioref">Uribe et al. 2021</a>)</span>. The main problem lies in the estimation of <span class="math inline">\Sigma^*</span> which, in dimension <span class="math inline">n</span>, involves the estimation of a quadratic (in the dimension) number of terms, namely <span class="math inline">n(n+1)/2</span>. Recently, the idea to overcome this problem by only evaluating variance terms in a small number of influential directions was explored in <span class="citation" data-cites="MasriEtAl_ImprovementCrossentropyMethod_2020">(<a href="#ref-MasriEtAl_ImprovementCrossentropyMethod_2020" role="doc-biblioref">El Masri, Morio, and Simatos 2021</a>)</span> and <span class="citation" data-cites="UribeEtAl_CrossentropybasedImportanceSampling_2020">(<a href="#ref-UribeEtAl_CrossentropybasedImportanceSampling_2020" role="doc-biblioref">Uribe et al. 2021</a>)</span>. In these two papers, the auxiliary covariance matrix <span class="math inline">\Sigma</span> is modeled in the form <span id="eq-Sigmak"><span class="math display">
    \Sigma = \sum_{i=1}^k (v_i-1) \mathbf{d}_i \mathbf{d}_i^\top + I_n
     \tag{4}</span></span> where the <span class="math inline">\mathbf{d}_i</span>’s are the <span class="math inline">k</span> orthonormal directions which are deemed influential. It is easy to check that <span class="math inline">\Sigma</span> is the covariance matrix of the Gaussian vector <span class="math display"> v^{1/2}_1 Y_1 \mathbf{d}_1 + \cdots + v^{1/2}_k Y_k \mathbf{d}_k + Y_{k+1} \mathbf{d}_{k+1} + \cdots + Y_n \mathbf{d}_n </span> where the <span class="math inline">Y_i</span>’s are i.i.d. standard normal random variables (one-dimensional), and the <span class="math inline">n-k</span> vectors <span class="math inline">(\mathbf{d}_{k+1}, \ldots, \mathbf{d}_n)</span> complete <span class="math inline">(\mathbf{d}_1, \ldots, \mathbf{d}_k)</span> into an orthonormal basis. In particular, <span class="math inline">v_i</span> is the variance in the direction of <span class="math inline">\mathbf{d}_i</span>, i.e., <span class="math inline">v_i = \mathbf{d}_i^\top \Sigma \mathbf{d}_i</span>. In <a href="#eq-Sigmak">Equation&nbsp;4</a>, <span class="math inline">k</span> can be considered as the effective dimension in which variance terms are estimated. In other words, in <span class="citation" data-cites="MasriEtAl_ImprovementCrossentropyMethod_2020">(<a href="#ref-MasriEtAl_ImprovementCrossentropyMethod_2020" role="doc-biblioref">El Masri, Morio, and Simatos 2021</a>)</span> and <span class="citation" data-cites="UribeEtAl_CrossentropybasedImportanceSampling_2020">(<a href="#ref-UribeEtAl_CrossentropybasedImportanceSampling_2020" role="doc-biblioref">Uribe et al. 2021</a>)</span>, the optimal variance parameter is not sought in <span class="math inline">\mathcal{S}^+_n</span> as in <a href="#eq-argminDkl">Equation&nbsp;2</a>}, but rather in the subset of matrices of the form <span class="math display"> \mathcal{L}_{n,k} = \left\{ \sum_{i=1}^k (\alpha_i-1) \frac{\mathbf{d}_i \mathbf{d}_i^\top}{\lVert \mathbf{d}_i \rVert^2} + I_n: \alpha_1, \ldots, \alpha_k &gt;0 \ \text{ and the $\mathbf{d}_i$'s are orthogonal} \right\}. </span> The relevant minimization problem thus becomes <span id="eq-argminDkl-k"><span class="math display">
    (\mathbf{m}^*_k, \Sigma^*_k) = \arg\min \left\{ D(g^*,g_{\mathbf{m},\Sigma}): \mathbf{m} \in \mathbb{R}^n, \ \Sigma \in \mathcal{L}_{n,k} \right\}
     \tag{5}</span></span> instead of <a href="#eq-argminDkl">Equation&nbsp;2</a>, with the effective dimension <span class="math inline">k</span> being allowed to be adjusted dynamically. By restricting the space in which the variance is looked up, one seeks to limit the number of variance terms to be estimated. The idea is that if the directions are suitably chosen, then the improvement of the accuracy due to the smaller error in estimating the variance terms will compensate the fact that we consider less candidates for the covariance matrix. In <span class="citation" data-cites="MasriEtAl_ImprovementCrossentropyMethod_2020">(<a href="#ref-MasriEtAl_ImprovementCrossentropyMethod_2020" role="doc-biblioref">El Masri, Morio, and Simatos 2021</a>)</span>, the authors consider <span class="math inline">k = 1</span> and <span class="math inline">\mathbf{d}_1 = \mathbf{m}^* / \lVert \mathbf{m}^* \rVert</span>. When <span class="math inline">f</span> is Gaussian, this choice is motivated by the fact that, due to the light tail of the Gaussian random variable and the reliability context, the variance should vary significantly in the direction of <span class="math inline">\mathbf{m}^*</span> and so estimating the variance in this direction can bring information. (In <a href="#sec-mm">Section&nbsp;3.4</a>, we actually use the techniques of the present paper to provide a stronger theoretical justification of this choice, see <a href="#thm-thm2">Theorem&nbsp;2</a> and the discussion following it). The method in <span class="citation" data-cites="UribeEtAl_CrossentropybasedImportanceSampling_2020">(<a href="#ref-UribeEtAl_CrossentropybasedImportanceSampling_2020" role="doc-biblioref">Uribe et al. 2021</a>)</span> is more involved: <span class="math inline">k</span> is adjusted dynamically, while the directions <span class="math inline">\mathbf{d}_i</span> are the eigenvectors associated to the largest eigenvalues of a certain matrix. They span a low-dimensional subspace called Failure-Informed Subspace, and the authors in <span class="citation" data-cites="UribeEtAl_CrossentropybasedImportanceSampling_2020">(<a href="#ref-UribeEtAl_CrossentropybasedImportanceSampling_2020" role="doc-biblioref">Uribe et al. 2021</a>)</span> prove that this choice minimizes an upper bound on the minimal KL divergence. In practice, this algorithm yields very accurate results. However, we will not consider it further in the present paper for two reasons. First, this algorithm is tailored for the reliability case where <span class="math inline">\phi = \mathbb{I}_{\{\varphi \geq 0\}}</span>, with a function <span class="math inline">\varphi: \mathbb{R}^n \to \mathbb{R}</span>, whereas our method is more general and applies to the general problem of estimating an integral (see for instance our test case of <strong>?@sec-sub:payoff</strong>). Second, the algorithm in <span class="citation" data-cites="UribeEtAl_CrossentropybasedImportanceSampling_2020">(<a href="#ref-UribeEtAl_CrossentropybasedImportanceSampling_2020" role="doc-biblioref">Uribe et al. 2021</a>)</span> requires the evaluation of the gradient of the function <span class="math inline">\varphi</span>. However, this gradient is not always known and can be expensive to evaluate in high dimension; in some cases, the function <span class="math inline">\varphi</span> is even not differentiable, as will be the case in our numerical example in <strong>?@sec-sub:portfolio</strong>. In contrast, our method makes no assumption on the form or smoothness of <span class="math inline">\phi</span>: it does not need to assume that it is of the form <span class="math inline">\mathbb{I}_{\{\varphi \geq 0\}}</span>, or to assume that <span class="math inline">\nabla \varphi</span> is tractable. For completeness, whenever the algorithm of <span class="citation" data-cites="UribeEtAl_CrossentropybasedImportanceSampling_2020">(<a href="#ref-UribeEtAl_CrossentropybasedImportanceSampling_2020" role="doc-biblioref">Uribe et al. 2021</a>)</span> was applicable and computing the gradient of <span class="math inline">\varphi</span> did not require any additional simulation budget, we have run it on the test cases considered here and found that it outperformed our algorithm. In more realistic settings, computing <span class="math inline">\nabla \varphi</span> would likely increase the simulation budget, and it would be interesting to compare the two algorithms in more details to understand when this extra computation cost is worthwhile. We reserve such a question for future research and will not consider the algorithm of <span class="citation" data-cites="UribeEtAl_CrossentropybasedImportanceSampling_2020">(<a href="#ref-UribeEtAl_CrossentropybasedImportanceSampling_2020" role="doc-biblioref">Uribe et al. 2021</a>)</span> further, as our aim in this paper is to establish benchmark results for a general algorithm which works for any function <span class="math inline">\phi</span>.</p>
</section>
<section id="sec-main-result-positioning" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-main-result-positioning"><span class="header-section-number">3.2</span> Main result of the paper</h2>
<p>The main result of the present paper is to actually compute the exact value for <span class="math inline">\Sigma^*_k</span> in <a href="#eq-argminDkl-k">Equation&nbsp;5</a>, which therefore paves the way for efficient high-dimensional estimation schemes. The statement of our result involves the following function <span class="math inline">\ell</span>, which is represented in <a href="#fig-l">Figure&nbsp;1</a>: <span id="eq-l"><span class="math display">
    \ell: x \in (0,\infty) \mapsto -\log(x) + x - 1.
     \tag{6}</span></span> In the following, <span class="math inline">(\lambda, \mathbf{d}) \in \mathbb{R} \times \mathbb{R}^n</span> is an eigenpair of a matrix <span class="math inline">A</span> if <span class="math inline">A\mathbf{d} = \lambda \mathbf{d}</span> and <span class="math inline">\lVert \mathbf{d} \rVert = 1</span>. A diagonalizable matrix has <span class="math inline">n</span> distinct eigenpairs, say <span class="math inline">((\lambda^*_i, \mathbf{d}^*_i), i = 1, \ldots, n)</span>, and we say that these eigenpairs are ranked in decreasing <span class="math inline">\ell</span>-order if <span class="math inline">\ell(\lambda^*_1) \geq \cdots \geq \ell(\lambda^*_n)</span>.</p>
<div class="cell" data-execution_count="2">
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Figure 1. Plot of the function "l"</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(np.finfo(<span class="bu">float</span>).eps,<span class="fl">4.0</span>,<span class="dv">100</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="op">-</span>np.log(x) <span class="op">+</span> x <span class="op">-</span><span class="dv">1</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># plot</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>ax.plot(x, y, linewidth<span class="op">=</span><span class="fl">2.0</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(xlim<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">4</span>), xticks<span class="op">=</span>[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>       ylim<span class="op">=</span>(<span class="dv">0</span>, <span class="fl">0.5</span>), yticks<span class="op">=</span>[<span class="dv">0</span>,<span class="fl">0.5</span>,<span class="dv">1</span>,<span class="fl">1.5</span>])</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"$x$"</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="vs">r"$\ell(x)$"</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tickLabel <span class="kw">in</span> plt.gca().get_xticklabels() <span class="op">+</span> plt.gca().get_yticklabels():</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    tickLabel.set_fontsize(<span class="dv">16</span>)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-l" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="content_files/figure-html/fig-l-output-1.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;1: Plot of the function <span class="math inline">\ell=-\log(x) + x - 1</span> given by <a href="#eq-l">Equation&nbsp;6</a></figcaption><p></p>
</figure>
</div>
</div>
</div>
<div id="thm-thm1" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 </strong></span>Let <span class="math inline">(\lambda^*_i, \mathbf{d}^*_i)</span> be the eigenpairs of <span class="math inline">\Sigma^*</span> ranked in decreasing <span class="math inline">\ell</span>-order. Then for <span class="math inline">1 \leq k \leq n</span>, the solution <span class="math inline">(\mathbf{m}^*_k, \Sigma^*_k)</span> to <a href="#eq-argminDkl-k">Equation&nbsp;5</a> is given by <span id="eq-Sigma*k"><span class="math display">
\mathbf{m}^*_k = \mathbf{m}^* \ \text{ and } \ \Sigma^*_k = I_n + \sum_{i=1}^k \left( \lambda^*_i - 1 \right) \mathbf{d}^*_i (\mathbf{d}^*_i)^\top.
\tag{7}</span></span></p>
</div>
<p>For <span class="math inline">k = 1</span> for instance, the shape of the function <span class="math inline">\ell</span> depicted in <a href="#fig-l">Figure&nbsp;1</a> implies that <span class="math inline">\Sigma^*_1 = I_n + (\lambda^*-1) \mathbf{d}^* (\mathbf{d}^*)^\top</span> with <span class="math inline">(\lambda^*, \mathbf{d}^*)</span> the eigenpair of <span class="math inline">\Sigma^*</span> with <span class="math inline">\lambda^*</span> either the largest or the smallest eigenvalue of <span class="math inline">\Sigma^*</span>, depending on which one maximizes <span class="math inline">\ell</span>.</p>
<p>This theoretical result therefore suggests to reduce dimension by estimating eigenpairs of <span class="math inline">\Sigma^*</span>, rank them in decreasing <span class="math inline">\ell</span>-order and then use the <span class="math inline">k</span> first eigenpairs <span class="math inline">(({\widehat{\lambda}}^*_i, {\widehat{\mathbf{d}}}^*_i), i = 1, \ldots, k)</span> to build the covariance matrix <span class="math inline">\widehat \Sigma^*_k = \sum_{i=1}^k ({\widehat{\lambda}}^*_i-1) {\widehat{\mathbf{d}}}^*_i ({{\widehat{\mathbf{d}}}^*}_i)^\top + I_n</span> and the corresponding auxiliary density. This scheme is summarized in Algorithm 1. The effective dimension <span class="math inline">k</span> is obtained by Algorithm 2, see <a href="#sec-choicek">Section&nbsp;3.3</a> below.</p>
<pre class="pseudocode"><code>\begin{algorithm}
\caption{Algorithm suggested by Theorem 1.}
\begin{algorithmic}
\State \textbf{Data}: Sample sizes $N$ and $M$
\State \textbf{Result}: Estimation $\widehat{E}_N$ of integral $E$
\State Generate a sample $\mathbf{X}_1,\ldots,\mathbf{X}_M$  on $\mathbb{R}^n$ independently according to $g^*$
\State  Estimate $\widehat{\mathbf{m}}^*$ and $\widehat{\Sigma}^*$ defined in Equation 10 and Equation 11 with this sample
\State Compute the eigenpairs $(\widehat{\lambda}^*_i, \widehat{\mathbf{d}}^*_i)$ of $\widehat{\Sigma}^*$ ranked in decreasing $\ell$-order
\State Compute the matrix $\widehat{\Sigma}^*_k = \sum_{i=1}^k ({\widehat{\lambda}}^*_i-1) {\widehat{\mathbf{d}}}^*_i ({{\widehat{\mathbf{d}}}^*}_i)^\top + I_n$ with $k$ obtained by applying Algorithm 2 with input $({\widehat{\lambda}}^*_1, \ldots, {\widehat{\lambda}}^*_n)$
\State Generate a new sample $\mathbf{X}_1,\ldots,\mathbf{X}_N$ independently from $g' = g_{\widehat{\mathbf{m}}^*,\widehat{\Sigma}^*_k}$
\State Return $\displaystyle \widehat{E}_N=\frac{1}{N}\underset{i=1}{\overset{N}{\sum}} \phi(\mathbf{X}_i)\frac{f(\mathbf{X}_i)}{g'(\mathbf{X}_i)}$
\end{algorithmic}
\end{algorithm}</code></pre>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>The value <span class="math inline">1</span> plays a particular role in <a href="#thm-thm1">Theorem&nbsp;1</a>, in that, as <span class="math inline">\ell</span> is minimized in <span class="math inline">1</span>, eigenvectors with eigenvalues <span class="math inline">1</span> will only be selected once all other eigenvalues will have been picked: in other words, if <span class="math inline">\lambda^*_i = 1</span> then <span class="math inline">\lambda^*_j = 1</span> for all <span class="math inline">j \geq i</span>. The reason why <span class="math inline">1</span> plays this special role is due to the form of the covariance matrix that we impose. More precisely, looking for covariance matrices in the set <span class="math inline">\mathcal{L}_{n,k}</span> amounts to looking for covariance matrices which, once diagonalized, have one’s on the diagonal except possibly for <span class="math inline">k</span> values (the <span class="math inline">\alpha_i</span>’s). As <span class="math inline">k</span> will be small, typically <span class="math inline">k = 1</span> or <span class="math inline">2</span>, this amounts to looking for covariance matrices which are perturbation of the identity. This is particularly relevant as we assume <span class="math inline">f</span> is a standard Gaussian density. What <a href="#thm-thm1">Theorem&nbsp;1</a> tells is that, when trying to approximate <span class="math inline">\Sigma^*</span> by such matrices, we should first consider eigenvectors with eigenvalues as different as possible from <span class="math inline">1</span>, the ‘’distance’’ to <span class="math inline">1</span> being measured by <span class="math inline">\ell</span>. If one was imposing a different form on <span class="math inline">\Sigma^*_k</span> (which can be interesting if the distribution <span class="math inline">f</span> is not standardized), then a different result would arise. For instance, if one was looking for matrices where the ‘’default’’ choice would be some <span class="math inline">\lambda &gt; 0</span> for the diagonal entries that are not estimated, i.e., a matrix of the form <span class="math inline">\sum_i (\alpha_i-\lambda) \mathbf{d}_i \mathbf{d}_i^\top + \lambda I_n</span>, then eigenpairs would be ranked according to the function <span class="math inline">\ell(\cdot/\lambda)</span>, meaning that one would look for eigenvectors associated to eigenvalues as different as possible from <span class="math inline">\lambda</span>.</p>
</div>
<p>As mentioned above, we assume in the first step of Algorithm 1 that we can sample according to <span class="math inline">g^*</span>. Since <span class="math inline">g^*</span> is known up to a multiplicative constant, this is a reasonable assumption as classical techniques such as importance sampling with self-normalized weights or Markov Chain Monte–Carlo (MCMC) can be applied in this case (see for instance <span class="citation" data-cites="ChanKroese_ImprovedCrossentropyMethod_2012">(<a href="#ref-ChanKroese_ImprovedCrossentropyMethod_2012" role="doc-biblioref">Chan and Kroese 2012</a>)</span>, <span class="citation" data-cites="GraceEtAl_AutomatedStateDependentImportance_2014">(<a href="#ref-GraceEtAl_AutomatedStateDependentImportance_2014" role="doc-biblioref">Grace, Kroese, and Sandmann 2014</a>)</span>). In this paper, we choose to apply a basic rejection method that yields perfect independent samples from <span class="math inline">g^*</span>, possibly at the price of a high computational cost. As the primary goal of this paper is to understand whether the <span class="math inline">\mathbf{d}^*_i</span>’s are indeed good projection directions, this computational cost to generate from <span class="math inline">g^*</span> is not relevant for us and therefore not taken into account. Possible improvements to relax this assumption are discussed in the conclusion of the paper.</p>
</section>
<section id="sec-choicek" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="sec-choicek"><span class="header-section-number">3.3</span> Choice of the number of dimensions <span class="math inline">k</span></h2>
<p>The choice of the effective dimension <span class="math inline">k</span>, i.e., the number of projection directions considered, is important. If it is close to <span class="math inline">n</span>, then the matrix <span class="math inline">\widehat{\Sigma}^*_k</span> will be close to <span class="math inline">\widehat{\Sigma}^*</span> which is the situation we want to avoid in the first place. On the other hand, setting <span class="math inline">k=1</span> in all cases may be too simple and lead to suboptimal results. In practice however, this is often a good choice. In order to adapt <span class="math inline">k</span> dynamically, we consider a simple method based on the value of the KL divergence. Given the eigenvalues <span class="math inline">\lambda_1, \ldots, \lambda_n</span> ranked in decreasing <span class="math inline">\ell</span>-order, we look for the maximal gap in the sequence <span class="math inline">(\ell(\lambda_1), \ldots, \ell(\lambda_n))</span>. This allows to choose <span class="math inline">k</span> such that <span class="math inline">\sum_{i=1}^k \ell(\lambda_i)</span> is close to <span class="math inline">\sum_{i=1}^n \ell(\lambda_i)</span> which is equal, up to an additive constant, to the minimal KL divergence (see <a href="#eq-Dell">Equation&nbsp;9</a> below). The precise method is described in Algorithm 2.</p>
<pre class="pseudocode"><code>\begin{algorithm}
\caption{Choice of the number of dimensions}
\begin{algorithmic}
\State \textbf{Data}: Sequence of positive numbers $\lambda_1, \ldots, \lambda_n$ in decreasing $\ell$-order
\State \textbf{Result}: Number of selected dimensions $k$
\State Compute the increments $\delta_i = \ell(\lambda_{i+1}) - \ell(\lambda_i)$ for $i=1\ldots n-1$
\State Return $k=\arg\max \delta_i$, the index of the maximum of the differences.
\end{algorithmic}
\end{algorithm}</code></pre>
</section>
<section id="sec-mm" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="sec-mm"><span class="header-section-number">3.4</span> Theoretical result concerning the projection on <span class="math inline">\mathbf{m}^*</span></h2>
<p>In <span class="citation" data-cites="MasriEtAl_ImprovementCrossentropyMethod_2020">(<a href="#ref-MasriEtAl_ImprovementCrossentropyMethod_2020" role="doc-biblioref">El Masri, Morio, and Simatos 2021</a>)</span>, the authors propose to project on the mean <span class="math inline">\mathbf{m}^*</span> of the optimal auxiliary density <span class="math inline">g^*</span>. Numerically, this algorithm is shown to perform well, but only a very heuristic explanation based on the light tail of the Gaussian distribution is provided to motivate this choice. It turns out that the techniques used in the proof of <a href="#thm-thm1">Theorem&nbsp;1</a> can shed light on why projecting on <span class="math inline">\mathbf{m}^*</span> may indeed be a good idea. Let us first state our theoretical result, and then explain why it justifies the idea of projecting on <span class="math inline">\mathbf{m}^*</span>.</p>
<div id="thm-thm2" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2 </strong></span>Consider <span class="math inline">\Sigma \in \mathcal{L}_{n,1}</span> of the form <span class="math inline">\Sigma = I_n + (\alpha - 1) \mathbf{d} \mathbf{d}^\top</span> with <span class="math inline">\alpha &gt; 0</span> and <span class="math inline">\lVert \mathbf{d} \rVert = 1</span>. Then the minimizer in <span class="math inline">(\alpha, \mathbf{d})</span> of the KL divergence between <span class="math inline">f</span> and <span class="math inline">g_{\mathbf{m}^*, \Sigma}</span> is <span class="math inline">(1+\lVert m^*\rVert^2, \mathbf{m}^* / \lVert \mathbf{m}^* \rVert)</span>: <span class="math display">\left( 1+\lVert \mathbf{m}^*\rVert^2, \mathbf{m}^* / \lVert \mathbf{m}^* \rVert \right) = \arg \min_{\alpha, \mathbf{d}} \left\{ D(f, g_{\mathbf{m}^*, I_n + (\alpha - 1) \mathbf{d} \mathbf{d}^\top}): \alpha &gt; 0, \ \lVert \mathbf{d} \rVert = 1 \right\}. </span></p>
</div>
<p>In other words, <span class="math inline">\mathbf{m}^*</span> appears as an optimal projection direction when one seeks to minimize the KL divergence between <span class="math inline">f</span> and the Gaussian density with mean <span class="math inline">\mathbf{m}^*</span> and covariance of the form <span class="math inline">I_n + (\alpha - 1) \mathbf{d} \mathbf{d}^\top</span>. Let us now explain why this minimization problem is indeed relevant, and why choosing an auxiliary density which minimizes this KL divergence may indeed lead to an accurate estimation. The justification deeply relies on the recent results by Chatterjee and Diaconis <span class="citation" data-cites="Chatterjee18:0">(<a href="#ref-Chatterjee18:0" role="doc-biblioref">Chatterjee and Diaconis 2018</a>)</span>.</p>
<p>As mentioned above, in a reliability context where one seeks to estimate a small probability <span class="math inline">p = \mathbb{P}(\mathbf{X} \in A),</span> Theorem <span class="math inline">1.3</span> in <span class="citation" data-cites="Chatterjee18:0">(<a href="#ref-Chatterjee18:0" role="doc-biblioref">Chatterjee and Diaconis 2018</a>)</span> shows that <span class="math inline">D(g^*, g)</span> governs the sample size required for an accurate estimation of <span class="math inline">p</span>: more precisely, the estimation is accurate if the sample size is larger than <span class="math inline">e^{D(g^*, g)}</span>, and inaccurate otherwise. This motivates the rationale for minimizing the KL divergence with <span class="math inline">g^*</span>.</p>
<p>However, in high dimension, importance sampling is known to fail because of the weight degeneracy problem whereby <span class="math inline">\max_i L_i / \sum_i L_i \approx 1</span>, with the <span class="math inline">L_i</span>’s the unnormalized importance weights, or likelihood ratios: <span class="math inline">L_i = f(\mathbf{X}_i) / g(\mathbf{X}_i)</span> with the <span class="math inline">\mathbf{X}_i</span>’s i.i.d. drawn according to <span class="math inline">g</span>. Theorem <span class="math inline">2.3</span> in <span class="citation" data-cites="Chatterjee18:0">(<a href="#ref-Chatterjee18:0" role="doc-biblioref">Chatterjee and Diaconis 2018</a>)</span> shows that the weight degeneracy problem is avoided if the empirical mean of the likelihood ratios is close to <span class="math inline">1</span>, and for this, Theorem <span class="math inline">1.1</span> in <span class="citation" data-cites="Chatterjee18:0">(<a href="#ref-Chatterjee18:0" role="doc-biblioref">Chatterjee and Diaconis 2018</a>)</span> shows that the sample size should be larger than <span class="math inline">e^{D(f, g)}</span>. In other words, these results suggest that the KL divergence with <span class="math inline">g^*</span> governs the sample size for an accurate estimation of <span class="math inline">p</span>, while the KL divergence with <span class="math inline">f</span> governs the weight degeneracy problem.</p>
<p>In light of these results, it becomes natural to consider the KL divergence with <span class="math inline">f</span> and not only <span class="math inline">g^*</span>. Of course, minimizing <span class="math inline">D(f, g_{\mathbf{m}, \Sigma})</span> without constraints on <span class="math inline">\mathbf{m}</span> and <span class="math inline">\Sigma</span> is trivial since <span class="math inline">g_{\mathbf{m}, \Sigma} = f</span> for <span class="math inline">\mathbf{m} = 0</span> and <span class="math inline">\Sigma = I_n</span>. However, these choices are the ones we want to avoid in the first place, and so it makes sense to impose some constraints on <span class="math inline">\mathbf{m}</span> and <span class="math inline">\Sigma</span>. If one keeps in mind the other objective of getting close to <span class="math inline">g^*</span>, then the choice <span class="math inline">\mathbf{m} = \mathbf{m}^*</span> becomes very natural, and we are led, when <span class="math inline">\Sigma \in \mathcal{L}_{n,1}</span> is sought as a rank-<span class="math inline">1</span> perturbation of the identity, to considering the optimization problem of <a href="#thm-thm2">Theorem&nbsp;2</a>.</p>
</section>
</section>
<section id="sec-proof" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Proof of Theorems <a href="#thm-thm1">Theorem&nbsp;1</a> and <a href="#thm-thm2">Theorem&nbsp;2</a></h1>
<p>We begin with a preliminary lemma.</p>
<div id="lem-D" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 1 </strong></span>Let <span class="math inline">f</span> be the density of the standard Gaussian vector in dimension <span class="math inline">n</span>, <span class="math inline">\phi: \mathbb{R}^n \to \mathbb{R}_+</span> and <span class="math inline">g_* = f \phi / E</span> with <span class="math inline">E = \int f \phi</span>. Then for any <span class="math inline">\mathbf{m}</span> and any <span class="math inline">\Sigma</span> of the form <span class="math inline">\Sigma = I_n + \sum_i (\alpha_i - 1) \mathbf{d}_i \mathbf{d}_i^\top</span> with <span class="math inline">\alpha_i &gt; 0</span> and the <span class="math inline">\mathbf{d}_i</span>’s orthonormal, we have <span id="eq-D"><span class="math display">
D(g^*, g_{\mathbf{m}, \Sigma}) =  \frac{1}{2} \sum_i \left( \log \alpha_i - \left(1 - \frac{1}{\alpha_i} \right) \mathbf{d}_i^\top \Sigma^* \mathbf{d}_i \right) + \frac{1}{2} (\mathbf{m} - \mathbf{m}^*)^\top \Sigma^{-1} (\mathbf{m} - \mathbf{m}^*)\\
- \frac{1}{2} \lVert \mathbf{m}^* \rVert^2 - \log E + \mathbb{E}_{g^*}(\log \phi(\mathbf{X})).
\tag{8}</span></span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em> (of <a href="#lem-D">Lemma&nbsp;1</a>). </span>For any <span class="math inline">\mathbf{m} \in \mathbb{R}^n</span> and <span class="math inline">\Sigma \in \mathcal{S}^+_n</span>, we have by definition <span class="math display"> D(g^*, g_{\mathbf{m}, \Sigma}) = \mathbb{E}_{g^*} \left( \log \left( \frac{g^*(\mathbf{X})}{g_{\mathbf{m}, \Sigma}(\mathbf{X})} \right) \right) = \mathbb{E}_{g^*} \left( \log \left( \frac{\frac{\phi(\mathbf{X}) e^{-\frac{1}{2} \lVert \mathbf{X} \rVert^2}}{E(2\pi)^{d/2}}}{ \frac{e^{-\frac{1}{2} (\mathbf{X} - \mathbf{m})^\top \Sigma^{-1} (\mathbf{X} - \mathbf{m})}}{(2\pi)^{d/2} \lvert \Sigma \rvert^{1/2}} } \right) \right) </span> and so <span class="math display">
D(g^*, g_{\mathbf{m}, \Sigma}) = - \frac{1}{2} \mathbb{E}_{g^*}(\lVert \mathbf{X} \rVert^2) + \frac{1}{2} \mathbb{E}_{g^*} \left( (\mathbf{X} - \mathbf{m})^\top \Sigma^{-1} (\mathbf{X} - \mathbf{m}) \right) + \frac{1}{2} \log \lvert \Sigma \rvert\\
- \log E + \mathbb{E}_{g^*}(\log \phi(\mathbf{X})).
</span> Because <span class="math inline">\mathbb{E}_{g^*}(\mathbf{X}) = \mathbf{m}^*</span>, we have <span class="math inline">\mathbb{E}_{g^*}(\lVert \mathbf{X} \rVert^2) = \mathbb{E}_{g^*}(\lVert \mathbf{X} - \mathbf{m}^* \rVert^2) + \lVert \mathbf{m}^* \rVert^2</span> and <span class="math display">
\mathbb{E}_{g^*} \left( (\mathbf{X} - \mathbf{m})^\top \Sigma^{-1} (\mathbf{X} - \mathbf{m}) \right) = \mathbb{E}_{g^*} \left( (\mathbf{X} - \mathbf{m}^*)^\top \Sigma^{-1} (\mathbf{X} - \mathbf{m}^*) \right)\\
+ (\mathbf{m} - \mathbf{m}^*)^\top \Sigma^{-1} (\mathbf{m} - \mathbf{m}^*).
</span> In the following derivations, we use the linearity of the trace and of the expectation, which make these two operators commute, as well as the identity <span class="math inline">a^\top b = \textrm{tr}(a b^\top)</span> for any two vectors <span class="math inline">a</span> and <span class="math inline">b</span>. With this caveat, we obtain <span class="math display">
\mathbb{E}_{g^*}\left[ \lVert \mathbf{X} - \mathbf{m}^* \rVert^2 \right] = \mathbb{E}_{g^*} \left[ \textrm{tr}((\mathbf{X} - \mathbf{m}^*) (\mathbf{X} - \mathbf{m}^*)^\top) \right] = \textrm{tr} (\Sigma^*)
</span> and we obtain with similar arguments <span class="math inline">\mathbb{E}_{g^*}( (\mathbf{X} - \mathbf{m}^*)^\top \Sigma^{-1} (\mathbf{X} - \mathbf{m}^*) ) = \textrm{tr} ( \Sigma^{-1} \Sigma^*)</span>. Consider now <span class="math inline">\Sigma = I_n + \sum_i (\alpha_i - 1) \mathbf{d}_i \mathbf{d}_i^\top</span> with <span class="math inline">\alpha_i &gt; 0</span> and the <span class="math inline">\mathbf{d}_i</span>’s orthonormal. Then the eigenvalues of <span class="math inline">\Sigma</span> potentially different from <span class="math inline">1</span> are the <span class="math inline">\alpha_i</span>’s (<span class="math inline">\alpha_i</span> is the eigenvalue associated with <span class="math inline">\mathbf{d}_i</span>), so that <span class="math display">\log \lvert \Sigma \rvert = \sum_i \log \alpha_i.
</span> Moreover, we have <span class="math inline">\Sigma^{-1} = I_n - \sum_i \beta_i \mathbf{d}_i \mathbf{d}_i^\top</span> with <span class="math inline">\beta_i = 1 - 1/\alpha_i</span> and so <span class="math display">
\textrm{tr}(\Sigma^{-1} \Sigma^*) = \textrm{tr}(\Sigma^*) - \sum_i \beta_i \mathbf{d}_i^\top \Sigma^* \mathbf{d}_i.
</span> Gathering the previous relation, we finally obtain the desired result.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em> (of <a href="#thm-thm1">Theorem&nbsp;1</a>). </span>From <a href="#eq-D">Equation&nbsp;8</a> we see that the only dependency of <span class="math inline">D(g^*, g_{\mathbf{m}, \Sigma})</span> in <span class="math inline">\mathbf{m}</span> is in the quadratic term <span class="math inline">(\mathbf{m} - \mathbf{m}^*)^\top \Sigma^{-1} (\mathbf{m} - \mathbf{m}^*)</span>. As <span class="math inline">\Sigma</span> is definite positive, this term is <span class="math inline">\geq 0</span>, and so it is minimized for <span class="math inline">\mathbf{m} = \mathbf{m}^*</span>. Next, we see that the derivative in <span class="math inline">\alpha_i</span> is given by (here and in the sequel, we see <span class="math inline">D(g^*, g_{\mathbf{m}, \Sigma})</span> as a function of <span class="math inline">\mathbf{v} = (\alpha_i)_i</span> and <span class="math inline">\mathbf{d} = (\mathbf{d}_i)_i</span>) <span class="math display"> \dfrac{\partial D}{\partial \alpha_i}(\mathbf{v}, \mathbf{d}) = \dfrac{1}{\alpha_i} - \frac{1}{\alpha_i^2} \mathbf{d}_i^\top \Sigma^* \mathbf{d}_i = \frac{1}{\alpha_i^2} \left( \alpha_i - \mathbf{d}_i^\top \Sigma^* \mathbf{d}_i \right). </span> Thus, for fixed <span class="math inline">\mathbf{d}</span>, <span class="math inline">D</span> is decreasing in <span class="math inline">\alpha_i</span> for <span class="math inline">\alpha_i &lt; \mathbf{d}_i^\top \Sigma^* \mathbf{d}_i</span> and then increasing for <span class="math inline">\alpha_i &gt; \mathbf{d}_i^\top \Sigma^* \mathbf{d}_i</span>, which shows that, for fixed <span class="math inline">\mathbf{d}</span>, it is minimized for <span class="math inline">\alpha_i = \mathbf{d}_i^\top \Sigma^* \mathbf{d}_i</span>. For this value (and <span class="math inline">\mathbf{m} = \mathbf{m}^*</span>) we have <span id="eq-Dell"><span class="math display">
D(g^*, g_{\mathbf{m}^*, \Sigma}) = \sum_{i=1}^k \left[ \log(\mathbf{d}_i^\top \Sigma^* \mathbf{d}_i) + 1 - \mathbf{d}_i^\top \Sigma^* \mathbf{d}_i \right] + C = -\sum_{i=1}^k \ell(\mathbf{d}_i^\top \Sigma^* \mathbf{d}_i) + C
\tag{9}</span></span> with <span class="math inline">C = - \frac{1}{2} \lVert \mathbf{m}^* \rVert^2 - \log E + \mathbb{E}_{g^*}(\log \phi(\mathbf{X}))</span> independent from the <span class="math inline">\mathbf{d}_i</span>’s. Since <span class="math inline">\ell</span> is decreasing and then increasing, it is clear from this expression that in order to minimize <span class="math inline">D</span>, one must choose the <span class="math inline">\mathbf{d}_i</span>’s in order to either maximize or minimize <span class="math inline">\mathbf{d}_i^\top \Sigma^* \mathbf{d}_i</span>, whichever maximizes <span class="math inline">\ell</span>. Since the variational characterization of eigenvalues shows that eigenvectors precisely solve this problem, we get the desired result.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em> (of <a href="#thm-thm2">Theorem&nbsp;2</a>). </span>In <a href="#eq-D">Equation&nbsp;8</a>, the <span class="math inline">\mathbf{m}^*</span> and the <span class="math inline">\Sigma^*</span> that appear in the right-hand side are the mean and variance of the density <span class="math inline">g^*</span> considered in the first argument of the Kullback–Leibler divergence. In particular, if we apply <a href="#eq-D">Equation&nbsp;8</a> with <span class="math inline">\phi \equiv 1</span>, we have <span class="math inline">g^* = f</span>, and the <span class="math inline">\mathbf{m}^*</span> and <span class="math inline">\Sigma^*</span> of the right-hand side become <span class="math inline">0</span> and <span class="math inline">I_n</span>, respectively, so that <span class="math display">
D(f, g_{\mathbf{m}, \Sigma}) =  \frac{1}{2} \sum_i \left( \log \alpha_i - \left(1 - \frac{1}{\alpha_i} \right) \right) + \frac{1}{2} \mathbf{m}^\top \Sigma^{-1} \mathbf{m}.
</span> Now, if we consider <span class="math inline">\mathbf{m} = \mathbf{m}^*</span> and <span class="math inline">\Sigma = I + (\alpha - 1) \mathbf{d} \mathbf{d}^\top</span>, we obtain (using <span class="math inline">\Sigma^{-1} = I - (1-1/\alpha) \mathbf{d} \mathbf{d}^\top</span> as mentioned in the proof of <a href="#lem-D">Lemma&nbsp;1</a>) <span class="math display">
D(f, g_{\mathbf{m}^*, \Sigma}) =  \frac{1}{2} \left( \log \alpha - \left(1 - \frac{1}{\alpha} \right) \left( 1 + (\mathbf{d}^\top \mathbf{m}^*)^2 \right) \right) + \frac{1}{2} \lVert \mathbf{m}^* \rVert^2.
</span> We have seen in the proof of <a href="#thm-thm1">Theorem&nbsp;1</a> that the function <span class="math inline">x \mapsto \log x + (1/x-1)\gamma</span> is minimized for <span class="math inline">x = \gamma</span> where it takes the value <span class="math inline">-\ell(\gamma)</span>: <span class="math inline">D(f, g_{\mathbf{m}^*, \Sigma})</span> is therefore minimized for <span class="math inline">\alpha = 1 + (\mathbf{d}^\top \mathbf{m}^*)^2</span> and for this value, we have <span class="math display">
D(f, g_{\mathbf{m}^*, \Sigma}) =  - \frac{1}{2} \ell(1 + (\mathbf{d}^\top \mathbf{m}^*)^2) + \frac{1}{2} \lVert \mathbf{m}^* \rVert^2.
</span> As <span class="math inline">\ell</span> is increasing in <span class="math inline">[1, \infty)</span>, this last quantity is minimized by maximizing <span class="math inline">(\mathbf{d}^\top \mathbf{m}^*)^2</span>, which is obtained for <span class="math inline">\mathbf{d} = \mathbf{m}^* / \lVert \mathbf{m}^* \rVert</span>. The result is proved.</p>
</div>
</section>
<section id="sec-num-results-framework" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Framework for the numerical results</h1>
<section id="general-framework" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="general-framework"><span class="header-section-number">5.1</span> General framework</h2>
<p>The objective of the numerical simulations is to evaluate the impact of the choice of the covariance matrix on the estimation accuracy of a high dimensional integral <span class="math inline">E</span>. We compare in this section the estimation results for different choices of the auxiliary covariance matrix when the IS auxiliary density is Gaussian. To extend this comparison, we also compute the results when the IS auxiliary density is chosen with the von Mises–Fisher– Nakagami (vMFN) model recently proposed in <span class="citation" data-cites="PapaioannouEtAl_ImprovedCrossEntropybased_2019">(<a href="#ref-PapaioannouEtAl_ImprovedCrossEntropybased_2019" role="doc-biblioref">Papaioannou, Geyer, and Straub 2019</a>)</span> for high dimensional probability estimation.</p>
<p>In the following section we test these different models of auxiliary densities on five test cases, where <span class="math inline">f</span> is a standard Gaussian density. This choice is not a theoretical limitation as we can in principle always come back to this case by transforming the vector <span class="math inline">\mathbf{X}</span> with isoprobabilistic transformations (see for instance <span class="citation" data-cites="HohenbichlerRackwitz_NonNormalDependentVectors_1981">(<a href="#ref-HohenbichlerRackwitz_NonNormalDependentVectors_1981" role="doc-biblioref">Hohenbichler and Rackwitz 1981</a>)</span>, <span class="citation" data-cites="LiuDerKiureghian_MultivariateDistributionModels_1986">(<a href="#ref-LiuDerKiureghian_MultivariateDistributionModels_1986" role="doc-biblioref">Liu and Der Kiureghian 1986</a>)</span>).</p>
<p>The precise numerical framework that we will consider to assess the efficiency of the different auxiliary models is as follows. We assume first that <span class="math inline">M</span> i.i.d.&nbsp;random samples <span class="math inline">\mathbf{X}_1,\ldots,\mathbf{X}_M</span> distributed from <span class="math inline">g^*</span> are available from rejection sampling. From these samples, the parameters of the Gaussian and of the vMFN auxiliary density are computed to get an auxiliary density <span class="math inline">g'</span>. Finally, <span class="math inline">N</span> samples are generated from <span class="math inline">g'</span> to provide an estimation of <span class="math inline">E</span> with IS. This procedure is summarized by the following stages:</p>
<ol type="1">
<li>Generate a sample <span class="math inline">\mathbf{X}_1,\ldots,\mathbf{X}_M</span> independently according to <span class="math inline">g^*</span>;</li>
<li>From <span class="math inline">\mathbf{X}_1,\ldots,\mathbf{X}_M</span>, compute the parameters of the auxiliary parametric density <span class="math inline">g'</span>;</li>
<li>Generate a new sample <span class="math inline">\mathbf{X}_1,\ldots,\mathbf{X}_N</span> independently from <span class="math inline">g'</span>;</li>
<li>Estimate <span class="math inline">E</span> with <span class="math inline">\widehat{E}_N=\frac{1}{N}\underset{i=1}{\overset{N}{\sum}} \phi(\mathbf{X}_i)\frac{f(\mathbf{X}_i)}{g'(\mathbf{X}_i)}</span>.</li>
</ol>
<p>The number of samples <span class="math inline">M</span> and <span class="math inline">N</span> are respectively set to <span class="math inline">M=500</span> and <span class="math inline">N=2000</span>. This procedure is then repeated <span class="math inline">50</span> times to provide a mean estimation <span class="math inline">\widehat{E}</span> of <span class="math inline">E</span>. In the result tables, for each auxiliary density <span class="math inline">g'</span> we report the corresponding value for the relative error <span class="math inline">\widehat{E}/ E-1</span> and the coefficient of variation of the <span class="math inline">50</span> iterations (the empirical standard deviation divided by <span class="math inline">E</span>). As was established in the proof of <a href="#thm-thm1">Theorem&nbsp;1</a>, the KL divergence is, up to an additive constant, equal to <span class="math inline">D'(\Sigma) = \log \lvert \Sigma \rvert + \textrm{tr}(\Sigma^* \Sigma^{-1})</span> which we will refer to as partial KL divergence. In the result tables, we also report thus the mean value of <span class="math inline">D'(\Sigma)</span> to analyse the relevancy of the auxiliary density <span class="math inline">g_{\widehat{\mathbf{m}}^*, \Sigma}</span> for these six choices of covariance matrix <span class="math inline">\Sigma</span>. The next sections specify the different parameters of <span class="math inline">g'</span> for the Gaussian model and for the vMFN model we have considered in the simulations.</p>
</section>
<section id="sec-def_cov" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="sec-def_cov"><span class="header-section-number">5.2</span> Choice of the auxiliary density <span class="math inline">g'</span> for the Gaussian model</h2>
<p>The goal is to get benchmark results to assess whether one can improve estimations of Gaussian IS auxiliary density by projecting the covariance matrix <span class="math inline">\Sigma^*</span> in the proposed directions <span class="math inline">\mathbf{d}^*_i</span>. The algorithm that we study here (Algorithms 1+2) aims more precisely at understanding whether:</p>
<ul>
<li>projecting can improve the situation with respect to the empirical covariance matrix;</li>
<li>the <span class="math inline">\mathbf{d}^*_i</span>’s are good candidates, in particular compared to the choice <span class="math inline">\mathbf{m}^*</span> suggested in <span class="citation" data-cites="MasriEtAl_ImprovementCrossentropyMethod_2020">(<a href="#ref-MasriEtAl_ImprovementCrossentropyMethod_2020" role="doc-biblioref">El Masri, Morio, and Simatos 2021</a>)</span>;</li>
<li>what is the impact in making errors in estimating the eigenpairs <span class="math inline">(\lambda^*_i, \mathbf{d}^*_i)</span>.</li>
</ul>
<p>Let us define the estimate <span class="math inline">\widehat{\mathbf{m}}^*</span> of <span class="math inline">\mathbf{m}^*</span> from the <span class="math inline">M</span> i.i.d. random samples <span class="math inline">\mathbf{X}_1,\ldots,\mathbf{X}_M</span> distributed from <span class="math inline">g^*</span> with <span id="eq-hatm"><span class="math display">
    \widehat{\mathbf{m}}^* = \frac{1}{M}\sum_{i=1}^M \mathbf{X}_i.
\tag{10}</span></span> In our numerical test cases, we will compare six different choices of Gaussian auxiliary distributions <span class="math inline">g'</span> with mean <span class="math inline">\widehat{\mathbf{m}}^*</span> and the following covariance matrices (see <a href="#tbl-sigma">Table&nbsp;1</a>):</p>
<ol type="1">
<li><p><span class="math inline">\Sigma^*</span>: the optimal covariance matrix given by <a href="#eq-mstar">Equation&nbsp;3</a>;</p></li>
<li><p><span class="math inline">\widehat{\Sigma}^*</span>: the empirical estimation of <span class="math inline">\Sigma^*</span> given by <span id="eq-hatSigma"><span class="math display">
\widehat{\Sigma}^* = \frac{1}{M}\sum_{i=1}^M (\mathbf{X}_i-\widehat{\mathbf{m}}^*)(\mathbf{X}_i-\widehat{\mathbf{m}}^*)^\top.
\tag{11}</span></span></p></li>
</ol>
<p>The four other covariance matrices considered in the numerical simulations are of the form <span class="math inline">\sum_{i=1}^k (v_i-1) \mathbf{d}_i \mathbf{d}^\top_i + I_n</span> where <span class="math inline">v_i</span> is the variance of <span class="math inline">\widehat{\Sigma}^*</span> in the direction <span class="math inline">\mathbf{d}_i</span>, <span class="math inline">v_i = \mathbf{d}_i^\top \widehat{\Sigma}^* \mathbf{d}_i</span>. The considered choice of <span class="math inline">k</span> and <span class="math inline">\mathbf{d}_i</span> gives the following covariance matrices:</p>
<ol start="3" type="1">
<li><p><span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{opt}}</span> is obtained by choosing <span class="math inline">\mathbf{d}_i = \mathbf{d}^*_i</span> of <a href="#thm-thm1">Theorem&nbsp;1</a>, which is supposed to be perfectly known from <span class="math inline">\Sigma^*</span> and <span class="math inline">k</span> is computed with Algorithm 2;</p></li>
<li><p><span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{opt}}</span> is obtained by choosing <span class="math inline">\mathbf{d}_i = {\widehat{\mathbf{d}}}^*_i</span> the <span class="math inline">i</span>-th eigenvector of <span class="math inline">\widehat{\Sigma}^*</span> (in <span class="math inline">\ell</span>-order), which is an estimation of <span class="math inline">\mathbf{d}^*_i</span>, and <span class="math inline">k</span> is computed with Algorithm 2;</p></li>
<li><p><span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{mean}}</span> is obtained by choosing <span class="math inline">k = 1</span> and <span class="math inline">\mathbf{d}_1 = \mathbf{m}^* / \lVert \mathbf{m}^* \rVert</span>;</p></li>
<li><p><span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{mean}}</span> is obtained by choosing <span class="math inline">k = 1</span> and <span class="math inline">\mathbf{d}_1 = {\widehat{\mathbf{m}}}^* / \lVert {\widehat{\mathbf{m}}}^* \rVert</span>, where <span class="math inline">\widehat{\mathbf{m}}^*</span> given by <a href="#eq-hatm">Equation&nbsp;10</a>.</p></li>
</ol>
<p>The matrices <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{opt}}</span> and <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{mean}}</span> use the estimation <span class="math inline">\widehat{\Sigma}^*</span> but the actual directions <span class="math inline">\mathbf{d}^*_i</span> or <span class="math inline">\mathbf{m}^*</span>, while the matrices <span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{opt}}</span> and <span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{mean}}</span> involve an additional estimation of the directions. By definition, <span class="math inline">\Sigma^*</span> will give optimal results, while results for <span class="math inline">\widehat{\Sigma}^*</span> will deteriorate as the dimension increases, which is the well-known behavior which we try to improve. Moreover, for <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{mean}}</span> and <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{opt}}</span>, the projection directions, if not known analytically, are obtained by a brute force Monte Carlo scheme with a very high simulation budget. Finally, we emphasize that Algorithm 1 corresponds to estimating and projecting on the <span class="math inline">\mathbf{d}^*_i</span>’s, and so the matrix <span class="math inline">\widehat{\Sigma}^*_k</span> of Algorithm 1 is equal to the matrix <span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{opt}}</span>, i.e., <span class="math inline">\widehat{\Sigma}^*_k = {\widehat{\Sigma}^{\text{+d}}_\text{opt}}</span>.</p>
<div id="tbl-sigma" class="anchored">
<table class="table">
<caption>Table&nbsp;1: Presentation of the six covariance matrices considered in the numerical examples. Except <span class="math inline">\Sigma^*</span>, the five other matrices involve one or two estimations: <span class="math inline">\widehat \Sigma^*</span> is the empirical estimation of <span class="math inline">\Sigma^*</span> given by <a href="#eq-hatSigma">Equation&nbsp;11</a>. The four others are obtained by projecting <span class="math inline">\widehat \Sigma^*</span> on: (i) the optimal directions <span class="math inline">\mathbf{d}^*_i</span> for <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{opt}}</span>; (ii) estimations <span class="math inline">\widehat{\mathbf{d}}^*_i</span> of the optimal directions <span class="math inline">\mathbf{d}^*_i</span> for <span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{opt}}</span>; (iii) <span class="math inline">\mathbf{m}^*</span> for <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{mean}}</span>; (iv) the estimation <span class="math inline">\widehat{\mathbf{m}}^*</span> in <a href="#eq-mstar">Equation&nbsp;3</a> of <span class="math inline">\mathbf{m}^*</span> for <span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{mean}}</span>. The subscript therefore indicates the choice for the projection direction, while the superscript +d indicates whether these directions are estimated or not.</caption>
<colgroup>
<col style="width: 25%">
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 10%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><span class="math inline">\Sigma^*</span></th>
<th><span class="math inline">\widehat{\Sigma}^*</span></th>
<th><span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{opt}}</span></th>
<th><span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{mean}}</span></th>
<th><span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{opt}}</span></th>
<th><span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{mean}}</span></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Initial covariance matrix</td>
<td><span class="math inline">\Sigma^*</span></td>
<td><span class="math inline">\widehat \Sigma^*</span></td>
<td><span class="math inline">\widehat \Sigma^*</span></td>
<td><span class="math inline">\widehat \Sigma^*</span></td>
<td><span class="math inline">\widehat \Sigma^*</span></td>
<td><span class="math inline">\widehat \Sigma^*</span></td>
<td></td>
</tr>
<tr class="even">
<td>Projection directions (exact or estimated)</td>
<td>-</td>
<td>-</td>
<td>Exact</td>
<td>Exact</td>
<td>Estimated</td>
<td>Estimated</td>
<td></td>
</tr>
<tr class="odd">
<td>Choice for the projection direction</td>
<td>None</td>
<td>None</td>
<td>Opt</td>
<td>Mean</td>
<td>Opt</td>
<td>Mean</td>
<td></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="choice-of-the-auxiliary-density-g-for-the-von-misesfishernakagami-model" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="choice-of-the-auxiliary-density-g-for-the-von-misesfishernakagami-model"><span class="header-section-number">5.3</span> Choice of the auxiliary density <span class="math inline">g'</span> for the von Mises–Fisher–Nakagami model</h2>
<p>Von Mises–Fisher–Nakagami (vMFN) distributions were proposed in <span class="citation" data-cites="PapaioannouEtAl_ImprovedCrossEntropybased_2019">(<a href="#ref-PapaioannouEtAl_ImprovedCrossEntropybased_2019" role="doc-biblioref">Papaioannou, Geyer, and Straub 2019</a>)</span> as an alternative to the Gaussian parametric family to perform IS for high dimensional probability estimation. A random vector <span class="math inline">\mathbf{X}</span> drawn according to the vMFN distribution can be written as <span class="math inline">\mathbf{X}=R {\bf A}</span> where <span class="math inline">{\bf A}=\frac{\mathbf{X}}{\lVert\mathbf{X}\rVert}</span> is a unit random vector following the von Mises-Fisher distribution, and <span class="math inline">R=\lVert\mathbf{X}\rVert</span> is a positive random variable with a Nakagami distribution; further, <span class="math inline">R</span> and <span class="math inline">\bf A</span> are independent. The vMFN pdf can be written as <span id="eq-vMFN"><span class="math display">
g_\text{vMFN}({\bf x})= g_\text{N}(\lVert{\bf x}\rVert, p, \omega) \times g_\text{vMF} \left( \frac{{\bf x}}{\lVert{\bf x}\rVert}, {\boldsymbol{\mu}}, \kappa \right).
\tag{12}</span></span> The density <span class="math inline">g_\text{N}(\lVert {\bf x}\rVert, p, \omega)</span> is the Nakagami distribution with shape parameter <span class="math inline">p \geq 0.5</span> and a spread parameter <span class="math inline">\omega&gt;0</span> defined by <span class="math display">
g_\text{N}(\lVert {\bf x}\rVert, p, \omega) = \frac{2 p^p}{\Gamma(p) \omega^p} \lVert {\bf x}\rVert^{2p-1} \exp\left( - \frac{p}{\omega}\lVert {\bf x}\rVert^2\right)
</span> and the density <span class="math inline">g_\text{vMF}(\frac{{\bf x}}{\lVert{\bf x}\rVert}, {\boldsymbol{\mu}}, \kappa)</span> is the von Mises-Fisher distribution, given by <span class="math display">g_\text{vMF} \left( \frac{{\bf x}}{\lVert{\bf x}\rVert}, {\boldsymbol{\mu}}, \kappa \right) = C_n(\kappa) \exp\left(\kappa {\boldsymbol{\mu}}^T \frac{{\bf x}}{\lVert{\bf x}\rvert\rvert} \right),
</span> where <span class="math inline">C_n(\kappa)</span> is a normalizing constant, <span class="math inline">\boldsymbol{\mu}</span> is a mean direction <span class="math inline">\boldsymbol{\mu}</span> (with <span class="math inline">\lvert\lvert\boldsymbol{\mu}\rvert\rvert=1</span>) and <span class="math inline">\kappa &gt; 0</span> is a concentration parameter <span class="math inline">\kappa&gt;0</span>.</p>
<p>Choosing a vMFN distribution therefore amounts to choosing the parameters <span class="math inline">p, \omega, {\boldsymbol{\mu}},</span> and <span class="math inline">\kappa</span>. There are therefore <span class="math inline">n+3</span> parameters to estimate, which is a significant reduction compared to the <span class="math inline">\frac{n(n+3)}{2}</span> required parameters of the Gaussian model with full covariance matrix.</p>
<p>Following <span class="citation" data-cites="PapaioannouEtAl_ImprovedCrossEntropybased_2019">(<a href="#ref-PapaioannouEtAl_ImprovedCrossEntropybased_2019" role="doc-biblioref">Papaioannou, Geyer, and Straub 2019</a>)</span>, given a sample <span class="math inline">\mathbf{X}_1,\ldots,\mathbf{X}_M</span> distributed from <span class="math inline">g^*</span>, the parameters <span class="math inline">\omega</span>, <span class="math inline">p</span>, <span class="math inline">\boldsymbol{\mu}</span> and <span class="math inline">\kappa</span> are set in the following way in order to define <span class="math inline">g'</span>: <span class="math display"> \widehat{\omega}=\frac{1}{M}\sum_{i=1}^M \lVert\mathbf{X}_i\rVert^2 \ \text{ and } \ \widehat{p}=\frac{\widehat{\omega}^2}{\widehat{\tau}-\widehat{\omega}^2} \text{ with } \widehat{\tau}=\frac{1}{M}\sum_{i=1}^M \lVert\mathbf{X}_i\rVert^4
</span> and <span class="math display"> \widehat{\boldsymbol{\mu}}=\frac{\sum_{i=1}^M \frac{\mathbf{X}_i}{\lvert\lvert\mathbf{X}_i\rvert\rvert}}{\lvert\lvert\sum_{i=1}^M \frac{\mathbf{X}_i}{\lvert\lvert\mathbf{X}_i\rvert\rvert} \rvert\rvert} \ \text{ and } \  \widehat{\kappa}=\dfrac{n\widehat{\chi}-\widehat{\chi}^3}{1-\widehat{\chi}^2} \text{ with } \widehat{\chi} = \min \left( \left \lVert \frac{1}{M}\sum_{i=1}^M \frac{\mathbf{X}_i}{\lVert \mathbf{X}_i \rVert} \right \rVert, 0.95 \right).
</span></p>
</section>
</section>
<section id="sec-test-cases" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Numerical results on five test cases</h1>
<p>The proposed numerical framework is applied on three examples that are often considered to assess the performance of importance sampling algorithms and also two test cases from the area of financial mathematics. Extended simulation results are given in the supplementary material associated with this article.</p>
<section id="sec-sub:sum" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="sec-sub:sum"><span class="header-section-number">6.1</span> Test case 1: one-dimensional optimal projection</h2>
<p>We consider a test case where all computations can be made exactly. This is a classical example of rare event probability estimation, often used to test the robustness of a method in high dimension. It is given by <span class="math inline">\phi(\mathbf{x})=\mathbb{I}_{\{\varphi(\mathbf{x})\geq 0\}}</span> with <span class="math inline">\varphi</span> the following affine function: <span id="eq-sum"><span class="math display">
    \varphi: \mathbf{x}=(x_1,\ldots,x_n)\in\mathbb{R}^n \mapsto\underset{j=1}{\overset{n}{\sum}} x_j-3\sqrt{n}.
\tag{13}</span></span> The quantity of interest <span class="math inline">E</span> is defined as <span class="math inline">E=\int_{\mathbb{R}^n} \phi(\mathbf{x}) f(\mathbf{x}) \textrm{d}\mathbf{x} = \mathbb{P}_f(\varphi(\mathbf{X})\geq 0)\simeq 1.35\cdot 10^{-3}</span> for all <span class="math inline">n</span> where the density <span class="math inline">f</span> is the standard <span class="math inline">n</span>-dimensional Gaussian distribution. Here, the zero-variance density is <span class="math inline">g^*(\mathbf{x})=\dfrac{f(\mathbf{x})\mathbb{I}_{\{\varphi(\mathbf{x})\geq 0\}}}{E}</span>, and the optimal parameters <span class="math inline">\mathbf{m}^*</span> and <span class="math inline">\Sigma^*</span> in <a href="#eq-mstar">Equation&nbsp;3</a> can be computed exactly, namely <span class="math inline">\mathbf{m}^* = \alpha \textbf{1}</span> with <span class="math inline">\alpha = e^{-9/2}/(E(2\pi)^{1/2})</span> and <span class="math inline">\textbf{1} = \frac{1}{\sqrt n} (1,\ldots,1) \in \mathbb{R}^n</span> the normalized constant vector, and <span class="math inline">\Sigma^* =(v-1) \mathbf{1} \mathbf{1}^\top + I_n</span> with <span class="math inline">v=3\alpha-\alpha^2+1</span>.</p>
<section id="evolution-of-the-partial-kl-divergence-and-spectrum" class="level3" data-number="6.1.1">
<h3 data-number="6.1.1" class="anchored" data-anchor-id="evolution-of-the-partial-kl-divergence-and-spectrum"><span class="header-section-number">6.1.1</span> Evolution of the partial KL divergence and spectrum</h3>
<p><a href="#fig-eigsum-1">Figure&nbsp;2 (a)</a> represents the evolution as the dimension varies between <span class="math inline">5</span> and <span class="math inline">100</span> of the partial KL divergence <span class="math inline">D'</span> for three different choices of covariance matrix: the optimal matrix <span class="math inline">\Sigma^*</span>, its empirical estimation <span class="math inline">\widehat{\Sigma}^*</span> and the estimation <span class="math inline">\widehat{\Sigma}^*_k</span> of the optimal lower-dimensional covariance matrix. We can notice that the partial KL divergence for <span class="math inline">\widehat{\Sigma}^*</span> grows much faster than the other two, and that the partial KL divergence for <span class="math inline">\widehat{\Sigma}^*_k</span> remains very close to the optimal value <span class="math inline">D'(\Sigma^*)</span>. As the KL divergence is a proxy for the efficiency of the auxiliary density (it is for instance closely related to the number of samples required for a given precision <span class="citation" data-cites="Chatterjee18:0">(<a href="#ref-Chatterjee18:0" role="doc-biblioref">Chatterjee and Diaconis 2018</a>)</span>), this suggests that using <span class="math inline">\widehat{\Sigma}^*_k</span> will provide results close to optimal.</p>
<p>We now check this claim. As <span class="math inline">\Sigma^* = (v-1) \textbf{1} \textbf{1}^\top + I_n</span>, its eigenpairs are <span class="math inline">(v, \textbf{1})</span> and <span class="math inline">(1,\mathbf{d}_i)</span> where the <span class="math inline">\mathbf{d}_i</span>’s form an orthonormal basis of the space orthogonal to the space spanned by <span class="math inline">\textbf{1}</span>. In particular, <span class="math inline">(v, \textbf{1})</span> is the largest (in <span class="math inline">\ell</span>-order) eigenpair of <span class="math inline">\Sigma^*</span> and <span class="math inline">\Sigma^*_k = \Sigma^*</span> for any <span class="math inline">k \geq 1</span>.</p>
<p>In practice, we do not use this theoretical knowledge and <span class="math inline">\Sigma^*</span>, <span class="math inline">\Sigma^*_k</span> and the eigenpairs are estimated. The six covariance matrices introduced in <a href="#sec-def_cov">Section&nbsp;5.2</a> and in which we are interested are as follows:</p>
<ul>
<li><span class="math inline">\Sigma^* = (v-1) \textbf{1} \textbf{1}^\top + I_n</span>;</li>
<li><span class="math inline">\widehat{\Sigma}^*</span> given by <a href="#eq-hatSigma">Equation&nbsp;11</a>;</li>
<li><span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{opt}}</span> and <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{mean}}</span> are equal and given by <span class="math inline">(\widehat \lambda-1) \textbf{1} \textbf{1}^\top + I_n</span> with <span class="math inline">\widehat{\lambda} = \textbf{1}^\top \widehat{\Sigma}^* \textbf{1}</span>. This amounts to assuming that the projection direction <span class="math inline">\textbf{1}</span> is perfectly known, whereas the variance in this direction is estimated;</li>
<li><span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{opt}} = (\widehat{\lambda} - 1) \widehat{\mathbf{d}} {\widehat{\mathbf{d}}}^\top + I_n</span> with <span class="math inline">(\widehat{\lambda}, \widehat{\mathbf{d}})</span> the smallest eigenpair of <span class="math inline">\widehat{\Sigma}^*</span>. The difference with the previous case is that we do not assume anymore that the optimal projection direction <span class="math inline">\textbf{1}</span> is known, and so it needs to be estimated;</li>
<li><span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{mean}} = (\widehat{\lambda} - 1) \frac{\widehat{\mathbf{m}}^* {(\widehat{\mathbf{m}}^*)}^\top}{\lVert \widehat{\mathbf{m}}^* \rVert^2} + I_n</span> with <span class="math inline">\widehat{\mathbf{m}}^*</span> given by <a href="#eq-hatm">Equation&nbsp;10</a> and <span class="math inline">\widehat{\lambda} = \frac{{(\widehat{\mathbf{m}}^*)}^\top \widehat{\Sigma}^* \widehat{\mathbf{m}}^*}{\lVert \widehat{\mathbf{m}}^* \rVert^2}</span>. Here we assume that <span class="math inline">\mathbf{m}^*</span> is a good projection direction, but is unknown and therefore needs to be estimated.</li>
</ul>
<p>Note that in the particularly simple case considered here, both <span class="math inline">\widehat{\mathbf{m}}^* / \lVert \widehat{\mathbf{m}}^* \rVert</span> and <span class="math inline">\widehat{\mathbf{d}}</span> are estimators of <span class="math inline">\textbf{1}</span> but they are obtained by different methods. In the next example we will consider a case where <span class="math inline">\mathbf{m}^*</span> is not an optimal projection direction as given by <a href="#thm-thm1">Theorem&nbsp;1</a>.</p>
<p><a href="#fig-eigsum-2">Figure&nbsp;2 (b)</a> represents the images by <span class="math inline">\ell</span> of the eigenvalues of <span class="math inline">\Sigma^*</span> and <span class="math inline">\widehat{\Sigma}^*</span>. This picture carries a very important insight. We notice that the estimation of most eigenvalues is poor: indeed, all the blue crosses except the leftmost one are meant to be estimator of <span class="math inline">1</span>, whereas we see that they are more or less uniformly spread between <span class="math inline">0.4</span> and <span class="math inline">1.8</span>. This means that the variance terms in the corresponding directions are poorly estimated, which could be the explanation on why the use of <span class="math inline">\widehat{\Sigma}^*</span> gives an inaccurate estimation. But what we remark also is that the function <span class="math inline">\ell</span> is quite flat around one: as a consequence, although the eigenvalues offer significant variability, this variability is smoothed by the action of <span class="math inline">\ell</span>. Indeed, the images of the eigenvalues by <span class="math inline">\ell</span> take values between <span class="math inline">0</span> and <span class="math inline">0.4</span> and have smaller variability. Moreover, <span class="math inline">\ell(x)</span> increases sharply as <span class="math inline">x</span> approaches <span class="math inline">0</span> and thus efficiently distinguishes between the two leftmost estimated eigenvalues and is able to separate them.</p>
<div>
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Figure 2. Evolution of the partial KL divergence and spectrum of the eigenvalues for the test case 1</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Somme(x):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span>np.shape(x)[<span class="dv">1</span>]</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(np.<span class="bu">sum</span>(x,axis<span class="op">=</span><span class="dv">1</span>)<span class="op">-</span><span class="dv">3</span><span class="op">*</span>np.sqrt(n))</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span><span class="dv">100</span>         <span class="co"># dimension</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>phi<span class="op">=</span>Somme</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>E<span class="op">=</span>sp.stats.norm.cdf(<span class="op">-</span><span class="dv">3</span>)   <span class="co"># exact value of the integral</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>DKL<span class="op">=</span>np.zeros(<span class="dv">20</span>)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>DKLp<span class="op">=</span>np.zeros(<span class="dv">20</span>)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>DKLm<span class="op">=</span>np.zeros(<span class="dv">20</span>)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>DKLstar<span class="op">=</span>np.zeros(<span class="dv">20</span>)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>M<span class="op">=</span><span class="dv">300</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>,n<span class="op">+</span><span class="dv">1</span>,<span class="dv">5</span>):</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mstar</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    alpha<span class="op">=</span>np.exp(<span class="op">-</span><span class="dv">3</span><span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)<span class="op">/</span>(E<span class="op">*</span>np.sqrt(<span class="dv">2</span><span class="op">*</span>np.pi))</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    Mstar<span class="op">=</span>alpha<span class="op">*</span>np.ones(d)<span class="op">/</span>np.sqrt(d)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sigmastar</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    vstar<span class="op">=</span><span class="dv">3</span><span class="op">*</span>alpha<span class="op">-</span>alpha<span class="op">**</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    Sigstar<span class="op">=</span> (vstar<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>np.ones((d,d))<span class="op">/</span>d<span class="op">+</span>np.eye(d)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">## g*-sample</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    VA0<span class="op">=</span>sp.stats.multivariate_normal(mean<span class="op">=</span>np.zeros(d),cov<span class="op">=</span>np.eye(d))</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>    X0<span class="op">=</span>VA0.rvs(size<span class="op">=</span>M<span class="op">*</span><span class="dv">1000</span>)</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>    ind<span class="op">=</span>(phi(X0)<span class="op">&gt;</span><span class="dv">0</span>)</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X0[ind,:]</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X[:M,:]            <span class="co"># g*-sample of size M</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">## estimated mean and covariance</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>    mm<span class="op">=</span>np.mean(X,axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>    Xc<span class="op">=</span>(X<span class="op">-</span>mm).T</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span>Xc <span class="op">@</span> Xc.T<span class="op">/</span>np.shape(Xc)[<span class="dv">1</span>]</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">## projection with the eigenvalues of sigma</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>    Eig<span class="op">=</span>np.linalg.eigh(sigma)</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>    logeig<span class="op">=</span>np.sort(np.log(Eig[<span class="dv">0</span>])<span class="op">-</span>Eig[<span class="dv">0</span>])</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>    delta<span class="op">=</span>np.zeros(<span class="bu">len</span>(logeig)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(logeig)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>        delta[j]<span class="op">=</span><span class="bu">abs</span>(logeig[j]<span class="op">-</span>logeig[j<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span>np.argmax(delta)<span class="op">+</span><span class="dv">1</span>         <span class="co"># biggest gap between the l(lambda_i)</span></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>    indi<span class="op">=</span>[]</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>        indi.append(np.where(np.log(Eig[<span class="dv">0</span>])<span class="op">-</span>Eig[<span class="dv">0</span>]<span class="op">==</span>logeig[l])[<span class="dv">0</span>][<span class="dv">0</span>])</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>    P1<span class="op">=</span>np.array(Eig[<span class="dv">1</span>][:,indi[<span class="dv">0</span>]],ndmin<span class="op">=</span><span class="dv">2</span>).T                  </span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,k):</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>        P1<span class="op">=</span>np.concatenate((P1,np.array(Eig[<span class="dv">1</span>][:,indi[l]],ndmin<span class="op">=</span><span class="dv">2</span>).T),axis<span class="op">=</span><span class="dv">1</span>)   <span class="co"># matrix of inflential directions of projection</span></span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>    diagsi<span class="op">=</span>np.diag(Eig[<span class="dv">0</span>][indi])</span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>    sig_opt_d<span class="op">=</span>P1.dot((diagsi<span class="op">-</span>np.eye(k))).dot(P1.T)<span class="op">+</span>np.eye(d)  </span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>    DKL[<span class="bu">int</span>((d<span class="op">-</span><span class="dv">5</span>)<span class="op">/</span><span class="dv">5</span>)]<span class="op">=</span>np.log(np.linalg.det(sigma))<span class="op">+</span>np.<span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(sigma))))</span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>    DKLp[<span class="bu">int</span>((d<span class="op">-</span><span class="dv">5</span>)<span class="op">/</span><span class="dv">5</span>)]<span class="op">=</span>np.log(np.linalg.det(sig_opt_d))<span class="op">+</span>np.<span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(sig_opt_d))))</span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>    DKLstar[<span class="bu">int</span>((d<span class="op">-</span><span class="dv">5</span>)<span class="op">/</span><span class="dv">5</span>)]<span class="op">=</span>np.log(np.linalg.det(Sigstar))<span class="op">+</span>d</span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a><span class="co">#### plot of partial KL divergence</span></span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">5</span>,<span class="dv">105</span>,<span class="dv">5</span>),DKL,<span class="st">'rs'</span>,label<span class="op">=</span><span class="vs">r"$D'(\hat{\Sigma}^*)$"</span>)</span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">5</span>,<span class="dv">105</span>,<span class="dv">5</span>),DKLp,<span class="st">'k^'</span>,label<span class="op">=</span><span class="vs">r"$D'(\hat{\Sigma}^*_k)$"</span>)</span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">5</span>,<span class="dv">105</span>,<span class="dv">5</span>),DKLstar,<span class="st">'bo'</span>,label<span class="op">=</span><span class="vs">r"$D'(\Sigma^*)$"</span>)</span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Dimension'</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="vs">r"Partial KL divergence $D'$"</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tickLabel <span class="kw">in</span> plt.gca().get_xticklabels() <span class="op">+</span> plt.gca().get_yticklabels():</span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a>    tickLabel.set_fontsize(<span class="dv">16</span>)</span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a><span class="co">#### plot of the eigenvalues</span></span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a>Eig1<span class="op">=</span>np.linalg.eigh(sigma)</span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true" tabindex="-1"></a>logeig1<span class="op">=</span>np.log(Eig1[<span class="dv">0</span>])<span class="op">-</span>Eig1[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span></span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true" tabindex="-1"></a>Table_eigv<span class="op">=</span>np.zeros((n,<span class="dv">2</span>))</span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a>Table_eigv[:,<span class="dv">0</span>]<span class="op">=</span>Eig1[<span class="dv">0</span>]</span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a>Table_eigv[:,<span class="dv">1</span>]<span class="op">=-</span>logeig1</span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true" tabindex="-1"></a>Eigst<span class="op">=</span>np.linalg.eigh(Sigstar)</span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true" tabindex="-1"></a>logeigst<span class="op">=</span>np.log(Eigst[<span class="dv">0</span>])<span class="op">-</span>Eigst[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span></span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true" tabindex="-1"></a>Table_eigv_st<span class="op">=</span>np.zeros((n,<span class="dv">2</span>))</span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true" tabindex="-1"></a>Table_eigv_st[:,<span class="dv">0</span>]<span class="op">=</span>Eigst[<span class="dv">0</span>]</span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true" tabindex="-1"></a>Table_eigv_st[:,<span class="dv">1</span>]<span class="op">=-</span>logeigst</span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"Eigenvalues $\lambda_i$"</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="vs">r"$\ell(\lambda_i)$"</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tickLabel <span class="kw">in</span> plt.gca().get_xticklabels() <span class="op">+</span> plt.gca().get_yticklabels():</span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true" tabindex="-1"></a>    tickLabel.set_fontsize(<span class="dv">16</span>)</span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true" tabindex="-1"></a>plt.plot(Table_eigv[:,<span class="dv">0</span>],Table_eigv[:,<span class="dv">1</span>],<span class="st">'bx'</span>,label<span class="op">=</span><span class="vs">r"Eigenvalues of $\hat{\Sigma}^*$"</span>)</span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true" tabindex="-1"></a>plt.plot(Table_eigv_st[:,<span class="dv">0</span>],Table_eigv_st[:,<span class="dv">1</span>],<span class="st">'rs'</span>,label<span class="op">=</span><span class="vs">r"Eigenvalues of $\Sigma^*$"</span>)</span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="fig-eigsum" class="cell quarto-layout-panel" data-execution_count="3">
<figure class="figure">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="cell-output cell-output-display quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 50.0%;justify-content: center;">
<div id="fig-eigsum-1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="content_files/figure-html/fig-eigsum-output-1.png" class="img-fluid figure-img" data-ref-parent="fig-eigsum"></p>
<p></p><figcaption class="figure-caption">(a) Evolution of the partial KL divergence as the dimension increases, with the optimal covariance matrix <span class="math inline">\Sigma^*</span> (blue circles), the sample covariance <span class="math inline">\widehat{\Sigma}^*</span> (red squares), and the projected covariance <span class="math inline">\widehat{\Sigma}^*_k</span> (black triangles).</figcaption><p></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 50.0%;justify-content: center;">
<div id="fig-eigsum-2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="content_files/figure-html/fig-eigsum-output-2.png" class="img-fluid figure-img" data-ref-parent="fig-eigsum"></p>
<p></p><figcaption class="figure-caption">(b) Computation of <span class="math inline">\ell(\lambda_i)</span> for the eigenvalues of <span class="math inline">\Sigma^*</span> (red squares) and <span class="math inline">\widehat{\Sigma}^*</span> (blue crosses) in dimension <span class="math inline">n = 100</span>.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p></p><figcaption class="figure-caption">Figure&nbsp;2: Partial KL divergence and spectrum for the function <span class="math inline">\phi = \mathbb{I}_{\varphi \geq 0}</span> with <span class="math inline">\varphi</span> the linear function given by <a href="#eq-sum">Equation&nbsp;13</a>.</figcaption><p></p>
</figure>
</div>
</div>
</section>
<section id="numerical-results" class="level3" data-number="6.1.2">
<h3 data-number="6.1.2" class="anchored" data-anchor-id="numerical-results"><span class="header-section-number">6.1.2</span> Numerical results</h3>
<p>We report in <a href="#tbl-sum">Table&nbsp;2</a> the numerical results for the six different matrices and the vMFN model for the dimension <span class="math inline">n=100</span>. The column <span class="math inline">\Sigma^*</span> gives the optimal results, while the column <span class="math inline">\widehat{\Sigma}^*</span> corresponds to the results that we are trying to improve. Comparing these two columns, we notice as expected that the estimation of <span class="math inline">E</span> with <span class="math inline">\widehat{\Sigma}^*</span> is significantly degraded. Compared to the first column <span class="math inline">\Sigma^*</span>, the third and fourth column with <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{opt}} = {\widehat{\Sigma}^{\text{}}_\text{mean}}</span> correspond to the best projection direction <span class="math inline">\textbf{1}</span> (as for <span class="math inline">\Sigma^*</span>) but estimating the variance in this direction (instead of the true variance) with <span class="math inline">\textbf{1}^\top \widehat{\Sigma}^* \textbf{1}</span>. This choice performs very well, with numerical results similar to the optimal ones. This can be understood since in this case, both <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{opt}}</span> and <span class="math inline">\Sigma^*</span> are of the form <span class="math inline">\alpha \textbf{1} \textbf{1}^\top + I_n</span> and so estimating <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{opt}}</span> requires only a one-dimensional estimation (namely, the estimation of <span class="math inline">\alpha</span>). Next, the last two columns <span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{opt}}</span> and <span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{mean}}</span> highlight the impact of having to estimate the projection directions in addition to the variance since these two matrices are of the form <span class="math inline">\widehat \alpha \widehat{\textbf{1}} {\widehat{\textbf{1}}}^\top + I_n</span> with both <span class="math inline">\widehat{\alpha}</span> (the variance term) and <span class="math inline">\widehat{\textbf{1}}</span> (the direction) being estimated. We observe that these matrices yield results which are close to optimal and greatly improve the estimation obtained using <span class="math inline">\widehat{\Sigma}^*</span>. In dimension <span class="math inline">100</span>, the coefficient of variation is around <span class="math inline">4</span>% for <span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{mean}}</span>, and around <span class="math inline">5</span>% for <span class="math inline">\widehat{\Sigma}^{\text{+d}}_{\text{opt}}</span>, compared to <span class="math inline">2.5</span>% for <span class="math inline">\widehat{\Sigma}^*</span>.</p>
<p>Moreover, we observe that <span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{mean}}</span> gives slightly better results than <span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{opt}}</span>. We suggest that this is because <span class="math inline">\widehat{\mathbf{m}}^* / \lVert \widehat{\mathbf{m}}^* \rVert</span> is a better estimator of <span class="math inline">\textbf{1}</span> than the eigenvector of <span class="math inline">\widehat{\Sigma}^*</span>. Indeed, evaluating <span class="math inline">\widehat{\mathbf{m}}^*</span> requires the estimation of <span class="math inline">n</span> parameters, whereas <span class="math inline">\widehat{\Sigma}^*</span> needs around <span class="math inline">n^2/2</span> parameters to estimate, so the eigenvector is finally more noisy than the mean vector. In the last column, we present the vMFN results that are similar to the estimation obtained with <span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{mean}}</span>.</p>
<p>Thus, the proposed idea improves significantly the probability estimation in high dimension. But we see that the method taken in <span class="citation" data-cites="MasriEtAl_ImprovementCrossentropyMethod_2020">(<a href="#ref-MasriEtAl_ImprovementCrossentropyMethod_2020" role="doc-biblioref">El Masri, Morio, and Simatos 2021</a>)</span> with the projection <span class="math inline">\mathbf{m}^*</span> is at least as much efficient in this example where we need only a one-dimensional projection. The next case shows that the projection on more than one direction can outperform the one-dimensional projection on <span class="math inline">\mathbf{m}^*</span>.</p>
<div class="cell" data-execution_count="4">
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Table 2. Numerical comparison on test case 1</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display, Math, Latex</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Markdown</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tabulate <span class="im">import</span> tabulate</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span><span class="dv">100</span>         <span class="co"># dimension</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>phi<span class="op">=</span>Somme</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mypi(X):                   </span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span>np.shape(X)[<span class="dv">1</span>]</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    f0<span class="op">=</span>sp.stats.multivariate_normal.pdf(X,mean<span class="op">=</span>np.zeros(n),cov<span class="op">=</span>np.eye(n))</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>((phi(X)<span class="op">&gt;</span><span class="dv">0</span>)<span class="op">*</span>f0)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>N<span class="op">=</span><span class="dv">2000</span>   </span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>M<span class="op">=</span><span class="dv">500</span>   </span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>B<span class="op">=</span><span class="dv">50</span>    <span class="co"># number of runs</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>Eopt<span class="op">=</span>np.zeros(B)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>EIS<span class="op">=</span>np.zeros(B)</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>Eprj<span class="op">=</span>np.zeros(B)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>Eprm<span class="op">=</span>np.zeros(B)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>Eprjst<span class="op">=</span>np.zeros(B)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>Eprmst<span class="op">=</span>np.zeros(B)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>Evmfn<span class="op">=</span>np.zeros(B)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>SI<span class="op">=</span>[]</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>SIP<span class="op">=</span>[]</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>SIPst<span class="op">=</span>[]</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>SIM<span class="op">=</span>[]</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>SIMst<span class="op">=</span>[]</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Mstar</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>alpha<span class="op">=</span>np.exp(<span class="op">-</span><span class="dv">3</span><span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)<span class="op">/</span>(E<span class="op">*</span>np.sqrt(<span class="dv">2</span><span class="op">*</span>np.pi))</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>Mstar<span class="op">=</span>alpha<span class="op">*</span>np.ones(d)<span class="op">/</span>np.sqrt(d)</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Sigmastar</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>vstar<span class="op">=</span><span class="dv">3</span><span class="op">*</span>alpha<span class="op">-</span>alpha<span class="op">**</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>Sigstar<span class="op">=</span> (vstar<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>np.ones((d,d))<span class="op">/</span>d<span class="op">+</span>np.eye(d)</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>Eigst<span class="op">=</span>np.linalg.eigh(Sigstar)                        </span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>logeigst<span class="op">=</span>np.sort(np.log(Eigst[<span class="dv">0</span>])<span class="op">-</span>Eigst[<span class="dv">0</span>])         </span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>deltast<span class="op">=</span>np.zeros(<span class="bu">len</span>(logeigst)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(logeigst)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>    deltast[i]<span class="op">=</span><span class="bu">abs</span>(logeigst[i]<span class="op">-</span>logeigst[i<span class="op">+</span><span class="dv">1</span>])         </span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a><span class="co">## choice of the number of dimension</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>k_st<span class="op">=</span>np.argmax(deltast)<span class="op">+</span><span class="dv">1</span>     </span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>indist<span class="op">=</span>[]</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(k_st):</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>    indist.append(np.where(np.log(Eigst[<span class="dv">0</span>])<span class="op">-</span>Eigst[<span class="dv">0</span>]<span class="op">==</span>logeigst[i])[<span class="dv">0</span>][<span class="dv">0</span>])           </span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>P1st<span class="op">=</span>np.array(Eigst[<span class="dv">1</span>][:,indist[<span class="dv">0</span>]],ndmin<span class="op">=</span><span class="dv">2</span>).T</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,k_st):</span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>    P1st<span class="op">=</span>np.concatenate((P1st,np.array(Eigst[<span class="dv">1</span>][:,indist[i]],ndmin<span class="op">=</span><span class="dv">2</span>).T),axis<span class="op">=</span><span class="dv">1</span>)    <span class="co"># matrix of influential directions   </span></span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a><span class="co">#np.random.seed(0)</span></span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(B):</span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a><span class="co">############################# Estimation of the matrices</span></span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>   <span class="co">## g*-sample of size M</span></span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>    VA<span class="op">=</span>sp.stats.multivariate_normal(np.zeros(n),np.eye(n))      </span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>    X0<span class="op">=</span>VA.rvs(size<span class="op">=</span>M<span class="op">*</span><span class="dv">1000</span>)                   </span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a>    ind<span class="op">=</span>(phi(X0)<span class="op">&gt;</span><span class="dv">0</span>)          </span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a>    X1<span class="op">=</span>X0[ind,:]                             </span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X1[:M,:]           </span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a>    R<span class="op">=</span>np.sqrt(np.<span class="bu">sum</span>(X<span class="op">**</span><span class="dv">2</span>,axis<span class="op">=</span><span class="dv">1</span>))   </span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a>    Xu<span class="op">=</span>(X.T<span class="op">/</span>R).T                </span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a>   <span class="co">## estimated gaussian mean and covariance </span></span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true" tabindex="-1"></a>    mm<span class="op">=</span>np.mean(X,axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true" tabindex="-1"></a>    Xc<span class="op">=</span>(X<span class="op">-</span>mm).T</span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span>Xc <span class="op">@</span> Xc.T<span class="op">/</span>np.shape(Xc)[<span class="dv">1</span>]  </span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true" tabindex="-1"></a>    SI.append(sigma)</span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true" tabindex="-1"></a>   <span class="co">## von Mises Fisher parameters</span></span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true" tabindex="-1"></a>    normu<span class="op">=</span>np.sqrt(np.mean(Xu,axis<span class="op">=</span><span class="dv">0</span>).dot(np.mean(Xu,axis<span class="op">=</span><span class="dv">0</span>).T))</span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true" tabindex="-1"></a>    mu<span class="op">=</span>np.mean(Xu,axis<span class="op">=</span><span class="dv">0</span>)<span class="op">/</span>normu</span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true" tabindex="-1"></a>    mu<span class="op">=</span>np.array(mu,ndmin<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true" tabindex="-1"></a>    chi<span class="op">=</span><span class="bu">min</span>(normu,<span class="fl">0.95</span>)</span>
<span id="cb6-84"><a href="#cb6-84" aria-hidden="true" tabindex="-1"></a>    kappa<span class="op">=</span>(chi<span class="op">*</span>n<span class="op">-</span>chi<span class="op">**</span><span class="dv">3</span>)<span class="op">/</span>(<span class="dv">1</span><span class="op">-</span>chi<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb6-85"><a href="#cb6-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-86"><a href="#cb6-86" aria-hidden="true" tabindex="-1"></a>   <span class="co">## Nakagami parameters</span></span>
<span id="cb6-87"><a href="#cb6-87" aria-hidden="true" tabindex="-1"></a>    omega<span class="op">=</span>np.mean(R<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb6-88"><a href="#cb6-88" aria-hidden="true" tabindex="-1"></a>    tau4<span class="op">=</span>np.mean(R<span class="op">**</span><span class="dv">4</span>)</span>
<span id="cb6-89"><a href="#cb6-89" aria-hidden="true" tabindex="-1"></a>    pp<span class="op">=</span>omega<span class="op">**</span><span class="dv">2</span><span class="op">/</span>(tau4<span class="op">-</span>omega<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb6-90"><a href="#cb6-90" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-91"><a href="#cb6-91" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb6-92"><a href="#cb6-92" aria-hidden="true" tabindex="-1"></a>    Eig<span class="op">=</span>np.linalg.eigh(sigma)                     </span>
<span id="cb6-93"><a href="#cb6-93" aria-hidden="true" tabindex="-1"></a>    logeig<span class="op">=</span>np.sort(np.log(Eig[<span class="dv">0</span>])<span class="op">-</span>Eig[<span class="dv">0</span>])     </span>
<span id="cb6-94"><a href="#cb6-94" aria-hidden="true" tabindex="-1"></a>    delta<span class="op">=</span>np.zeros(<span class="bu">len</span>(logeig)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb6-95"><a href="#cb6-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(logeig)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb6-96"><a href="#cb6-96" aria-hidden="true" tabindex="-1"></a>        delta[j]<span class="op">=</span><span class="bu">abs</span>(logeig[j]<span class="op">-</span>logeig[j<span class="op">+</span><span class="dv">1</span>])    </span>
<span id="cb6-97"><a href="#cb6-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-98"><a href="#cb6-98" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span>np.argmax(delta)<span class="op">+</span><span class="dv">1</span>         </span>
<span id="cb6-99"><a href="#cb6-99" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-100"><a href="#cb6-100" aria-hidden="true" tabindex="-1"></a>    indi<span class="op">=</span>[]</span>
<span id="cb6-101"><a href="#cb6-101" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb6-102"><a href="#cb6-102" aria-hidden="true" tabindex="-1"></a>        indi.append(np.where(np.log(Eig[<span class="dv">0</span>])<span class="op">-</span>Eig[<span class="dv">0</span>]<span class="op">==</span>logeig[l])[<span class="dv">0</span>][<span class="dv">0</span>])</span>
<span id="cb6-103"><a href="#cb6-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-104"><a href="#cb6-104" aria-hidden="true" tabindex="-1"></a>    P1<span class="op">=</span>np.array(Eig[<span class="dv">1</span>][:,indi[<span class="dv">0</span>]],ndmin<span class="op">=</span><span class="dv">2</span>).T</span>
<span id="cb6-105"><a href="#cb6-105" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,k):</span>
<span id="cb6-106"><a href="#cb6-106" aria-hidden="true" tabindex="-1"></a>        P1<span class="op">=</span>np.concatenate((P1,np.array(Eig[<span class="dv">1</span>][:,indi[l]],ndmin<span class="op">=</span><span class="dv">2</span>).T),axis<span class="op">=</span><span class="dv">1</span>)     </span>
<span id="cb6-107"><a href="#cb6-107" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-108"><a href="#cb6-108" aria-hidden="true" tabindex="-1"></a>    diagsi<span class="op">=</span>np.diag(Eig[<span class="dv">0</span>][indi])                           </span>
<span id="cb6-109"><a href="#cb6-109" aria-hidden="true" tabindex="-1"></a>    sig_opt_d<span class="op">=</span>P1.dot((diagsi<span class="op">-</span>np.eye(k))).dot(P1.T)<span class="op">+</span>np.eye(n)</span>
<span id="cb6-110"><a href="#cb6-110" aria-hidden="true" tabindex="-1"></a>    SIP.append(sig_opt_d)</span>
<span id="cb6-111"><a href="#cb6-111" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-112"><a href="#cb6-112" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb6-113"><a href="#cb6-113" aria-hidden="true" tabindex="-1"></a>    diagsist<span class="op">=</span>P1st.T.dot(sigma).dot(P1st)                   </span>
<span id="cb6-114"><a href="#cb6-114" aria-hidden="true" tabindex="-1"></a>    sig_opt<span class="op">=</span>P1st.dot(diagsist<span class="op">-</span>np.eye(k_st)).dot(P1st.T)<span class="op">+</span>np.eye(n)</span>
<span id="cb6-115"><a href="#cb6-115" aria-hidden="true" tabindex="-1"></a>    SIPst.append(sig_opt)</span>
<span id="cb6-116"><a href="#cb6-116" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-117"><a href="#cb6-117" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb6-118"><a href="#cb6-118" aria-hidden="true" tabindex="-1"></a>    Norm_mm<span class="op">=</span>np.linalg.norm(mm)               </span>
<span id="cb6-119"><a href="#cb6-119" aria-hidden="true" tabindex="-1"></a>    normalised_mm<span class="op">=</span>np.array(mm,ndmin<span class="op">=</span><span class="dv">2</span>).T<span class="op">/</span>Norm_mm        </span>
<span id="cb6-120"><a href="#cb6-120" aria-hidden="true" tabindex="-1"></a>    vhat<span class="op">=</span>normalised_mm.T.dot(sigma).dot(normalised_mm)          </span>
<span id="cb6-121"><a href="#cb6-121" aria-hidden="true" tabindex="-1"></a>    sig_mean_d<span class="op">=</span>(vhat<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>normalised_mm.dot(normalised_mm.T)<span class="op">+</span>np.eye(n) </span>
<span id="cb6-122"><a href="#cb6-122" aria-hidden="true" tabindex="-1"></a>    SIM.append(sig_mean_d)</span>
<span id="cb6-123"><a href="#cb6-123" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-124"><a href="#cb6-124" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb6-125"><a href="#cb6-125" aria-hidden="true" tabindex="-1"></a>    Norm_Mstar<span class="op">=</span>np.linalg.norm(Mstar)               </span>
<span id="cb6-126"><a href="#cb6-126" aria-hidden="true" tabindex="-1"></a>    normalised_Mstar<span class="op">=</span>np.array(Mstar,ndmin<span class="op">=</span><span class="dv">2</span>).T<span class="op">/</span>Norm_Mstar   </span>
<span id="cb6-127"><a href="#cb6-127" aria-hidden="true" tabindex="-1"></a>    vhatst<span class="op">=</span>normalised_Mstar.T.dot(sigma).dot(normalised_Mstar)      </span>
<span id="cb6-128"><a href="#cb6-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-129"><a href="#cb6-129" aria-hidden="true" tabindex="-1"></a>    sig_mean<span class="op">=</span>(vhatst<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>normalised_Mstar.dot(normalised_Mstar.T)<span class="op">+</span>np.eye(n) </span>
<span id="cb6-130"><a href="#cb6-130" aria-hidden="true" tabindex="-1"></a>    SIMst.append(sig_mean)</span>
<span id="cb6-131"><a href="#cb6-131" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-132"><a href="#cb6-132" aria-hidden="true" tabindex="-1"></a><span class="co">############################################# Estimation of the integral</span></span>
<span id="cb6-133"><a href="#cb6-133" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb6-134"><a href="#cb6-134" aria-hidden="true" tabindex="-1"></a>    Xop<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>Sigstar,size<span class="op">=</span>N)              </span>
<span id="cb6-135"><a href="#cb6-135" aria-hidden="true" tabindex="-1"></a>    wop<span class="op">=</span>mypi(Xop)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xop,mean<span class="op">=</span>mm, cov<span class="op">=</span>Sigstar)       </span>
<span id="cb6-136"><a href="#cb6-136" aria-hidden="true" tabindex="-1"></a>    Eopt[i]<span class="op">=</span>np.mean(wop)                                                     </span>
<span id="cb6-137"><a href="#cb6-137" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-138"><a href="#cb6-138" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb6-139"><a href="#cb6-139" aria-hidden="true" tabindex="-1"></a>    Xis<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sigma,size<span class="op">=</span>N)</span>
<span id="cb6-140"><a href="#cb6-140" aria-hidden="true" tabindex="-1"></a>    wis<span class="op">=</span>mypi(Xis)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xis,mean<span class="op">=</span>mm, cov<span class="op">=</span>sigma)</span>
<span id="cb6-141"><a href="#cb6-141" aria-hidden="true" tabindex="-1"></a>    EIS[i]<span class="op">=</span>np.mean(wis)</span>
<span id="cb6-142"><a href="#cb6-142" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-143"><a href="#cb6-143" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb6-144"><a href="#cb6-144" aria-hidden="true" tabindex="-1"></a>    Xpr<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_opt_d,size<span class="op">=</span>N)</span>
<span id="cb6-145"><a href="#cb6-145" aria-hidden="true" tabindex="-1"></a>    wpr<span class="op">=</span>mypi(Xpr)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xpr,mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_opt_d)</span>
<span id="cb6-146"><a href="#cb6-146" aria-hidden="true" tabindex="-1"></a>    Eprj[i]<span class="op">=</span>np.mean(wpr)</span>
<span id="cb6-147"><a href="#cb6-147" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-148"><a href="#cb6-148" aria-hidden="true" tabindex="-1"></a>   <span class="co">###   </span></span>
<span id="cb6-149"><a href="#cb6-149" aria-hidden="true" tabindex="-1"></a>    Xpm<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_mean_d,size<span class="op">=</span>N)</span>
<span id="cb6-150"><a href="#cb6-150" aria-hidden="true" tabindex="-1"></a>    wpm<span class="op">=</span>mypi(Xpm)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xpm,mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_mean_d)</span>
<span id="cb6-151"><a href="#cb6-151" aria-hidden="true" tabindex="-1"></a>    Eprm[i]<span class="op">=</span>np.mean(wpm)</span>
<span id="cb6-152"><a href="#cb6-152" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-153"><a href="#cb6-153" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb6-154"><a href="#cb6-154" aria-hidden="true" tabindex="-1"></a>    Xprst<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_opt,size<span class="op">=</span>N)</span>
<span id="cb6-155"><a href="#cb6-155" aria-hidden="true" tabindex="-1"></a>    wprst<span class="op">=</span>mypi(Xprst)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xprst,mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_opt)</span>
<span id="cb6-156"><a href="#cb6-156" aria-hidden="true" tabindex="-1"></a>    Eprjst[i]<span class="op">=</span>np.mean(wprst)</span>
<span id="cb6-157"><a href="#cb6-157" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-158"><a href="#cb6-158" aria-hidden="true" tabindex="-1"></a>   <span class="co">###    </span></span>
<span id="cb6-159"><a href="#cb6-159" aria-hidden="true" tabindex="-1"></a>    Xpmst<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_mean,size<span class="op">=</span>N)</span>
<span id="cb6-160"><a href="#cb6-160" aria-hidden="true" tabindex="-1"></a>    wpmst<span class="op">=</span>mypi(Xpmst)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xpmst,mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_mean)</span>
<span id="cb6-161"><a href="#cb6-161" aria-hidden="true" tabindex="-1"></a>    Eprmst[i]<span class="op">=</span>np.mean(wpmst)</span>
<span id="cb6-162"><a href="#cb6-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-163"><a href="#cb6-163" aria-hidden="true" tabindex="-1"></a>   <span class="co">###</span></span>
<span id="cb6-164"><a href="#cb6-164" aria-hidden="true" tabindex="-1"></a>    Xvmfn <span class="op">=</span> vMFNM_sample(mu, kappa, omega, pp, <span class="dv">1</span>, N)</span>
<span id="cb6-165"><a href="#cb6-165" aria-hidden="true" tabindex="-1"></a>    Rvn<span class="op">=</span>np.sqrt(np.<span class="bu">sum</span>(Xvmfn<span class="op">**</span><span class="dv">2</span>,axis<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb6-166"><a href="#cb6-166" aria-hidden="true" tabindex="-1"></a>    Xvnu<span class="op">=</span>Xvmfn.T<span class="op">/</span>Rvn</span>
<span id="cb6-167"><a href="#cb6-167" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb6-168"><a href="#cb6-168" aria-hidden="true" tabindex="-1"></a>    h_log<span class="op">=</span>vMF_logpdf(Xvnu,mu.T,kappa)<span class="op">+</span>nakagami_logpdf(Rvn,pp,omega)</span>
<span id="cb6-169"><a href="#cb6-169" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> np.log(n) <span class="op">+</span> np.log(np.pi <span class="op">**</span> (n <span class="op">/</span> <span class="dv">2</span>)) <span class="op">-</span> sp.special.gammaln(n <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb6-170"><a href="#cb6-170" aria-hidden="true" tabindex="-1"></a>    f_u <span class="op">=</span> <span class="op">-</span>A       </span>
<span id="cb6-171"><a href="#cb6-171" aria-hidden="true" tabindex="-1"></a>    f_chi <span class="op">=</span> (np.log(<span class="dv">2</span>) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> n <span class="op">/</span> <span class="dv">2</span>) <span class="op">+</span> np.log(Rvn) <span class="op">*</span> (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> Rvn <span class="op">**</span> <span class="dv">2</span> <span class="op">-</span> sp.special.gammaln(n <span class="op">/</span> <span class="dv">2</span>)) </span>
<span id="cb6-172"><a href="#cb6-172" aria-hidden="true" tabindex="-1"></a>    f_log <span class="op">=</span> f_u <span class="op">+</span> f_chi</span>
<span id="cb6-173"><a href="#cb6-173" aria-hidden="true" tabindex="-1"></a>    W_log <span class="op">=</span> f_log <span class="op">-</span> h_log</span>
<span id="cb6-174"><a href="#cb6-174" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-175"><a href="#cb6-175" aria-hidden="true" tabindex="-1"></a>    wvmfn<span class="op">=</span>(phi(Xvmfn)<span class="op">&gt;</span><span class="dv">0</span>)<span class="op">*</span>np.exp(W_log)          </span>
<span id="cb6-176"><a href="#cb6-176" aria-hidden="true" tabindex="-1"></a>    Evmfn[i]<span class="op">=</span>np.mean(wvmfn)</span>
<span id="cb6-177"><a href="#cb6-177" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-178"><a href="#cb6-178" aria-hidden="true" tabindex="-1"></a><span class="co">### KL divergences    </span></span>
<span id="cb6-179"><a href="#cb6-179" aria-hidden="true" tabindex="-1"></a>dkli<span class="op">=</span>np.zeros(B)</span>
<span id="cb6-180"><a href="#cb6-180" aria-hidden="true" tabindex="-1"></a>dklp<span class="op">=</span>np.zeros(B)</span>
<span id="cb6-181"><a href="#cb6-181" aria-hidden="true" tabindex="-1"></a>dklm<span class="op">=</span>np.zeros(B)</span>
<span id="cb6-182"><a href="#cb6-182" aria-hidden="true" tabindex="-1"></a>dklpst<span class="op">=</span>np.zeros(B)</span>
<span id="cb6-183"><a href="#cb6-183" aria-hidden="true" tabindex="-1"></a>dklmst<span class="op">=</span>np.zeros(B)</span>
<span id="cb6-184"><a href="#cb6-184" aria-hidden="true" tabindex="-1"></a>dklpca<span class="op">=</span>np.zeros(B)</span>
<span id="cb6-185"><a href="#cb6-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-186"><a href="#cb6-186" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(B):</span>
<span id="cb6-187"><a href="#cb6-187" aria-hidden="true" tabindex="-1"></a>    dkli[i]<span class="op">=</span>np.log(np.linalg.det(SI[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SI[i]))))      </span>
<span id="cb6-188"><a href="#cb6-188" aria-hidden="true" tabindex="-1"></a>    dklp[i]<span class="op">=</span>np.log(np.linalg.det(SIP[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SIP[i]))))        </span>
<span id="cb6-189"><a href="#cb6-189" aria-hidden="true" tabindex="-1"></a>    dklm[i]<span class="op">=</span>np.log(np.linalg.det(SIM[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SIM[i]))))</span>
<span id="cb6-190"><a href="#cb6-190" aria-hidden="true" tabindex="-1"></a>    dklpst[i]<span class="op">=</span>np.log(np.linalg.det(SIPst[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SIPst[i]))))</span>
<span id="cb6-191"><a href="#cb6-191" aria-hidden="true" tabindex="-1"></a>    dklmst[i]<span class="op">=</span>np.log(np.linalg.det(SIMst[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SIMst[i]))))</span>
<span id="cb6-192"><a href="#cb6-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-193"><a href="#cb6-193" aria-hidden="true" tabindex="-1"></a>Tabresult<span class="op">=</span>np.zeros((<span class="dv">3</span>,<span class="dv">7</span>)) <span class="co"># table of results</span></span>
<span id="cb6-194"><a href="#cb6-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-195"><a href="#cb6-195" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">0</span>]<span class="op">=</span>np.log(np.linalg.det(Sigstar))<span class="op">+</span>n</span>
<span id="cb6-196"><a href="#cb6-196" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">1</span>]<span class="op">=</span>np.mean(dkli)</span>
<span id="cb6-197"><a href="#cb6-197" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">2</span>]<span class="op">=</span>np.mean(dklpst)</span>
<span id="cb6-198"><a href="#cb6-198" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">3</span>]<span class="op">=</span>np.mean(dklmst)</span>
<span id="cb6-199"><a href="#cb6-199" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">4</span>]<span class="op">=</span>np.mean(dklp)</span>
<span id="cb6-200"><a href="#cb6-200" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">5</span>]<span class="op">=</span>np.mean(dklm)</span>
<span id="cb6-201"><a href="#cb6-201" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">6</span>]<span class="op">=</span><span class="va">None</span></span>
<span id="cb6-202"><a href="#cb6-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-203"><a href="#cb6-203" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">0</span>]<span class="op">=</span>np.mean(Eopt<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb6-204"><a href="#cb6-204" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">1</span>]<span class="op">=</span>np.mean(EIS<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb6-205"><a href="#cb6-205" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">2</span>]<span class="op">=</span>np.mean(Eprjst<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb6-206"><a href="#cb6-206" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">3</span>]<span class="op">=</span>np.mean(Eprmst<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb6-207"><a href="#cb6-207" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">4</span>]<span class="op">=</span>np.mean(Eprj<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb6-208"><a href="#cb6-208" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">5</span>]<span class="op">=</span>np.mean(Eprm<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb6-209"><a href="#cb6-209" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">6</span>]<span class="op">=</span>np.mean(Evmfn<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb6-210"><a href="#cb6-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-211"><a href="#cb6-211" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">0</span>]<span class="op">=</span>np.sqrt(np.mean((Eopt<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb6-212"><a href="#cb6-212" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">1</span>]<span class="op">=</span>np.sqrt(np.mean((EIS<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb6-213"><a href="#cb6-213" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">2</span>]<span class="op">=</span>np.sqrt(np.mean((Eprjst<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb6-214"><a href="#cb6-214" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">3</span>]<span class="op">=</span>np.sqrt(np.mean((Eprmst<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb6-215"><a href="#cb6-215" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">4</span>]<span class="op">=</span>np.sqrt(np.mean((Eprj<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb6-216"><a href="#cb6-216" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">5</span>]<span class="op">=</span>np.sqrt(np.mean((Eprm<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb6-217"><a href="#cb6-217" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">6</span>]<span class="op">=</span>np.sqrt(np.mean((Evmfn<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb6-218"><a href="#cb6-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-219"><a href="#cb6-219" aria-hidden="true" tabindex="-1"></a>Tabresult<span class="op">=</span>np.<span class="bu">round</span>(Tabresult,<span class="dv">1</span>)</span>
<span id="cb6-220"><a href="#cb6-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-221"><a href="#cb6-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-222"><a href="#cb6-222" aria-hidden="true" tabindex="-1"></a>table<span class="op">=</span>[[<span class="st">"D'"</span>,Tabresult[<span class="dv">0</span>,<span class="dv">0</span>],Tabresult[<span class="dv">0</span>,<span class="dv">1</span>],Tabresult[<span class="dv">0</span>,<span class="dv">2</span>],Tabresult[<span class="dv">0</span>,<span class="dv">3</span>],Tabresult[<span class="dv">0</span>,<span class="dv">4</span>],Tabresult[<span class="dv">0</span>,<span class="dv">5</span>],Tabresult[<span class="dv">0</span>,<span class="dv">6</span>]],</span>
<span id="cb6-223"><a href="#cb6-223" aria-hidden="true" tabindex="-1"></a>      [<span class="st">"Relative error (\%)"</span>,Tabresult[<span class="dv">1</span>,<span class="dv">0</span>],Tabresult[<span class="dv">1</span>,<span class="dv">1</span>],Tabresult[<span class="dv">1</span>,<span class="dv">2</span>],Tabresult[<span class="dv">1</span>,<span class="dv">3</span>],Tabresult[<span class="dv">1</span>,<span class="dv">4</span>],Tabresult[<span class="dv">1</span>,<span class="dv">5</span>],Tabresult[<span class="dv">1</span>,<span class="dv">6</span>]],</span>
<span id="cb6-224"><a href="#cb6-224" aria-hidden="true" tabindex="-1"></a>    [<span class="st">"Coefficient of variation (\%)"</span>,Tabresult[<span class="dv">2</span>,<span class="dv">0</span>],Tabresult[<span class="dv">2</span>,<span class="dv">1</span>],Tabresult[<span class="dv">2</span>,<span class="dv">2</span>],Tabresult[<span class="dv">2</span>,<span class="dv">3</span>],Tabresult[<span class="dv">2</span>,<span class="dv">4</span>],Tabresult[<span class="dv">2</span>,<span class="dv">5</span>],Tabresult[<span class="dv">2</span>,<span class="dv">6</span>]]]</span>
<span id="cb6-225"><a href="#cb6-225" aria-hidden="true" tabindex="-1"></a>Markdown(tabulate(</span>
<span id="cb6-226"><a href="#cb6-226" aria-hidden="true" tabindex="-1"></a>  table, </span>
<span id="cb6-227"><a href="#cb6-227" aria-hidden="true" tabindex="-1"></a>  headers<span class="op">=</span>[<span class="st">""</span>,<span class="st">"$\Sigma^*$"</span>, <span class="st">"$\hat{\Sigma}^*$"</span>, <span class="st">"$\hat{\Sigma}_</span><span class="sc">{opt}</span><span class="st">$"</span>, <span class="st">"$\hat{\Sigma}_</span><span class="sc">{mean}</span><span class="st">$"</span>, <span class="st">"${\hat{\Sigma}^{+d}_</span><span class="sc">{opt}</span><span class="st">}$"</span>, <span class="st">"$\hat{\Sigma}^{+d}_</span><span class="sc">{mean}</span><span class="st">$"</span>, <span class="st">"vMFN"</span>],</span>
<span id="cb6-228"><a href="#cb6-228" aria-hidden="true" tabindex="-1"></a>    tablefmt<span class="op">=</span><span class="st">"pipe"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="4">
<div id="tbl-sum" class="anchored">
<table class="table table-sm table-striped">
<caption>Table&nbsp;2: Numerical comparison of the estimation of <span class="math inline">E \approx 1.35\cdot 10^{-3}</span> considering the Gaussian model with the six covariance matrices defined in <a href="#sec-def_cov">Section&nbsp;5.2</a> and the vFMN model, when <span class="math inline">\phi = \mathbb{I}_{{\varphi\geq 0}}</span> with <span class="math inline">\varphi</span> the linear function given by <a href="#eq-sum">Equation&nbsp;13</a>. As explained in the text, <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{mean}}</span> and <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{opt}}</span> are actually equal in this case.</caption>
<colgroup>
<col style="width: 16%">
<col style="width: 7%">
<col style="width: 10%">
<col style="width: 13%">
<col style="width: 13%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 4%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;"><span class="math inline">\Sigma^*</span></th>
<th style="text-align: right;"><span class="math inline">\hat{\Sigma}^*</span></th>
<th style="text-align: right;"><span class="math inline">\hat{\Sigma}_{opt}</span></th>
<th style="text-align: right;"><span class="math inline">\hat{\Sigma}_{mean}</span></th>
<th style="text-align: right;"><span class="math inline">{\hat{\Sigma}^{+d}_{opt}}</span></th>
<th style="text-align: right;"><span class="math inline">\hat{\Sigma}^{+d}_{mean}</span></th>
<th style="text-align: right;">vMFN</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">D’</td>
<td style="text-align: right;">97.3</td>
<td style="text-align: right;">111.9</td>
<td style="text-align: right;">97.4</td>
<td style="text-align: right;">97.4</td>
<td style="text-align: right;">97.7</td>
<td style="text-align: right;">97.6</td>
<td style="text-align: right;">nan</td>
</tr>
<tr class="even">
<td style="text-align: left;">Relative error (%)</td>
<td style="text-align: right;">-0.3</td>
<td style="text-align: right;">-36.5</td>
<td style="text-align: right;">-0.6</td>
<td style="text-align: right;">-0.1</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">-0.1</td>
<td style="text-align: right;">-0.2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coefficient of variation (%)</td>
<td style="text-align: right;">2.5</td>
<td style="text-align: right;">59.4</td>
<td style="text-align: right;">2.6</td>
<td style="text-align: right;">2.8</td>
<td style="text-align: right;">8.4</td>
<td style="text-align: right;">3.1</td>
<td style="text-align: right;">3.7</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</section>
</section>
<section id="sec-sub:parabol" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="sec-sub:parabol"><span class="header-section-number">6.2</span> Test case 2: projection in 2 directions</h2>
<p>The second test case is again a probability estimation, i.e., it is of the form <span class="math inline">\phi = \mathbb{I}_{\{\varphi \geq 0\}}</span> with now the function <span class="math inline">\varphi</span> having some quadratic terms: <span id="eq-parabol"><span class="math display">
    \varphi: \mathbf{x}=(x_1,\ldots,x_n) \in \mathbb{R}^n \mapsto x_1 - 25 x_2^2 - 30 x_3^2 - 1.
\tag{14}</span></span> The quantity of interest <span class="math inline">E</span> is defined as <span class="math inline">E=\int_{\mathbb{R}^n} \phi(\mathbf{x}) f(\mathbf{x}) \textrm{d}\mathbf{x} = \mathbb{P}_f(\varphi(\mathbf{X})\geq 0)</span> for all <span class="math inline">n</span> where the density <span class="math inline">f</span> is the standard <span class="math inline">n</span>-dimensional Gaussian distribution. This function is motivated in part because <span class="math inline">\mathbf{m}^*</span> and <span class="math inline">\mathbf{d}^*_1</span> are different and also because Algorithm 2 chooses two projection directions. Thus, this is an example where <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{mean}}</span> and <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{opt}}</span> are significantly different.</p>
<section id="evolution-of-the-partial-kl-divergence-and-spectrum-1" class="level3" data-number="6.2.1">
<h3 data-number="6.2.1" class="anchored" data-anchor-id="evolution-of-the-partial-kl-divergence-and-spectrum-1"><span class="header-section-number">6.2.1</span> Evolution of the partial KL divergence and spectrum</h3>
<p>We check on <a href="#fig-inefficiency-parab-1">Figure&nbsp;3 (a)</a> that the partial KL divergence obeys the same behavior as for the previous example, namely the one associated with <span class="math inline">\widehat{\Sigma}^*</span> increases much faster than the ones associated with <span class="math inline">\Sigma^*</span> and <span class="math inline">\widehat \Sigma^*_k</span>, which again suggests that projecting can improve the situation. Since the function <span class="math inline">\varphi</span> only depends on the first three variables and is even in <span class="math inline">x_2</span> and <span class="math inline">x_3</span>, one gets that <span class="math inline">\mathbf{m}^* = \alpha  \textbf{e}_1</span> with <span class="math inline">\alpha = \mathbb{E}(X_1 \mid X_1 \geq 25 X^2_2 + 30 X^2_3 + 1) \approx 1.9</span> (here and in the sequel, <span class="math inline">\textbf{e}_i</span> denotes the <span class="math inline">i</span>th canonical vector of <span class="math inline">\mathbb{R}^n</span>, i.e., all its coordinates are <span class="math inline">0</span> except the <span class="math inline">i</span>-th one which is equal to one), and that <span class="math inline">\Sigma^*</span> is diagonal with <span class="math display"> \Sigma^* =
    \begin{pmatrix}
    \lambda_1 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\
    0 &amp; \lambda_2 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\
    0 &amp; 0 &amp; \lambda_3 &amp; 0 &amp; \cdots &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; \cdots &amp; 0 \\
    \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1 \\
    \end{pmatrix}.
</span> Note that the off-diagonal elements of the submatrix <span class="math inline">(\Sigma^*_{ij})_{1 \leq i, j \leq 3}</span> are indeed <span class="math inline">0</span> since they result from integrating an odd function of an odd random variable with an even conditioning. For instance, if <span class="math inline">F(x) = \mathbb{P}(30 X^2_3 + 1 \leq x)</span>, then by conditioning on <span class="math inline">(X_1, X_3)</span> we obtain <span class="math display">
    \Sigma^*_{12} = \mathbb{E} \left( (X_1 - \alpha) X_2 \mid X_1 - 25 X_2^2 \geq 30 X^2_3 + 1 \right)\\
     = \frac{1}{E} \mathbb{E} \left[ (X_1 - \alpha) \mathbb{E} \left( X_2 F(X_1 - 25 X^2_2) \mid X_1 \right) \right]
</span> which is <span class="math inline">0</span> as <span class="math inline">x_2 F(x_1 - x^2_2)</span> is an odd function of <span class="math inline">x_2</span> for fixed <span class="math inline">x_1</span>, and <span class="math inline">X_2</span> has an even density.</p>
<p>We can numerically compute <span class="math inline">\lambda_1 \approx 0.278</span>, <span class="math inline">\lambda_2 \approx 0.009</span> and <span class="math inline">\lambda_3 \approx 0.0075</span>. These values correspond to the red squares in <a href="#fig-inefficiency-parab-2">Figure&nbsp;3 (b)</a> which shows that the smallest eigenvalues are properly estimated. Moreover, Algorithm 2 selects the two largest eigenvalues, which have the highest <span class="math inline">\ell</span>-values. These two eigenvalues thus correspond to the eigenvectors <span class="math inline">\mathbf{e}_2</span> and <span class="math inline">\mathbf{e}_3</span>, and so we see that on this example, the optimal directions predicted by <a href="#thm-thm1">Theorem&nbsp;1</a> are significantly different (actually, orthogonal) from <span class="math inline">\mathbf{m}^*</span> which is proportional to <span class="math inline">\textbf{e}_1</span>.</p>
<div>
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Figure 3. Evolution of the partial KL divergence and spectrum of the eigenvalues for the test case 2</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">#E=1.51*10**-3</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parabol(X):</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span>np.shape(X)[<span class="dv">1</span>]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(X[:,<span class="dv">0</span>]<span class="op">-</span><span class="dv">25</span><span class="op">*</span>X[:,<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span><span class="op">-</span><span class="dv">30</span><span class="op">*</span>X[:,<span class="dv">2</span>]<span class="op">**</span><span class="dv">2</span><span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>bigsample<span class="op">=</span><span class="dv">1</span><span class="op">*</span><span class="dv">10</span><span class="op">**</span><span class="dv">8</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>phi<span class="op">=</span>parabol</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>VA0<span class="op">=</span>sp.stats.multivariate_normal(mean<span class="op">=</span>np.zeros(<span class="dv">3</span>),cov<span class="op">=</span>np.eye(<span class="dv">3</span>))</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>X0<span class="op">=</span>VA0.rvs(size<span class="op">=</span>bigsample)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>ind<span class="op">=</span>(phi(X0)<span class="op">&gt;</span><span class="dv">0</span>)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>X<span class="op">=</span>X0[ind,:]</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>E<span class="op">=</span><span class="fl">1.51</span><span class="op">*</span><span class="dv">10</span><span class="op">**-</span><span class="dv">3</span>   <span class="co"># reference value of the integral</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>Mstar_dim3<span class="op">=</span>np.zeros(<span class="dv">3</span>)</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>Mstar_dim3[<span class="dv">0</span>]<span class="op">=</span>np.mean(X,axis<span class="op">=</span><span class="dv">0</span>)[<span class="dv">0</span>]   <span class="co"># accurate value of optimal mean in dimension 3</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>Xc<span class="op">=</span>(X<span class="op">-</span>Mstar_dim3).T</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>Sigstar_dim3<span class="op">=</span>Xc <span class="op">@</span> Xc.T<span class="op">/</span>np.shape(Xc)[<span class="dv">1</span>]    <span class="co"># accurate value of optimal covariance in dimension 3</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>DKL<span class="op">=</span>np.zeros(<span class="dv">20</span>)</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>DKLp<span class="op">=</span>np.zeros(<span class="dv">20</span>)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>DKLm<span class="op">=</span>np.zeros(<span class="dv">20</span>)</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>DKLstar<span class="op">=</span>np.zeros(<span class="dv">20</span>)</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>M<span class="op">=</span><span class="dv">300</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>,n<span class="op">+</span><span class="dv">1</span>,<span class="dv">5</span>):</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mstar</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>    Mstar<span class="op">=</span>np.zeros(d)</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>    Mstar[:<span class="dv">3</span>]<span class="op">=</span>Mstar_dim3</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sigmastar</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>    Sigstar<span class="op">=</span>np.eye(d)</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>    Sigstar[:<span class="dv">3</span>,:<span class="dv">3</span>]<span class="op">=</span>Sigstar_dim3</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">## g*-sample</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>    VA0<span class="op">=</span>sp.stats.multivariate_normal(mean<span class="op">=</span>np.zeros(d),cov<span class="op">=</span>np.eye(d))</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>    X0<span class="op">=</span>VA0.rvs(size<span class="op">=</span>M<span class="op">*</span><span class="dv">1000</span>)</span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>    ind<span class="op">=</span>(phi(X0)<span class="op">&gt;</span><span class="dv">0</span>)</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X0[ind,:]</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X[:M,:]</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>    <span class="co">## estimated mean and covariance</span></span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>    mm<span class="op">=</span>np.mean(X,axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>    Xc<span class="op">=</span>(X<span class="op">-</span>mm).T</span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span>Xc <span class="op">@</span> Xc.T<span class="op">/</span>np.shape(Xc)[<span class="dv">1</span>]</span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>    <span class="co">## projection with the eigenvalues of sigma</span></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>    Eig<span class="op">=</span>np.linalg.eigh(sigma)</span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>    logeig<span class="op">=</span>np.sort(np.log(Eig[<span class="dv">0</span>])<span class="op">-</span>Eig[<span class="dv">0</span>])</span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>    delta<span class="op">=</span>np.zeros(<span class="bu">len</span>(logeig)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(logeig)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>        delta[j]<span class="op">=</span><span class="bu">abs</span>(logeig[j]<span class="op">-</span>logeig[j<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span>np.argmax(delta)<span class="op">+</span><span class="dv">1</span>         <span class="co"># biggest gap between the l(lambda_i)</span></span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a>    indi<span class="op">=</span>[]</span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a>        indi.append(np.where(np.log(Eig[<span class="dv">0</span>])<span class="op">-</span>Eig[<span class="dv">0</span>]<span class="op">==</span>logeig[l])[<span class="dv">0</span>][<span class="dv">0</span>])</span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>    P1<span class="op">=</span>np.array(Eig[<span class="dv">1</span>][:,indi[<span class="dv">0</span>]],ndmin<span class="op">=</span><span class="dv">2</span>).T                  </span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,k):</span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a>        P1<span class="op">=</span>np.concatenate((P1,np.array(Eig[<span class="dv">1</span>][:,indi[l]],ndmin<span class="op">=</span><span class="dv">2</span>).T),axis<span class="op">=</span><span class="dv">1</span>)    <span class="co"># matrix od influential directions of projections</span></span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a>    diagsi<span class="op">=</span>np.diag(Eig[<span class="dv">0</span>][indi])</span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a>    sig_opt_d<span class="op">=</span>P1.dot((diagsi<span class="op">-</span>np.eye(k))).dot(P1.T)<span class="op">+</span>np.eye(d)  </span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a>    DKL[<span class="bu">int</span>((d<span class="op">-</span><span class="dv">5</span>)<span class="op">/</span><span class="dv">5</span>)]<span class="op">=</span>np.log(np.linalg.det(sigma))<span class="op">+</span>np.<span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(sigma))))</span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a>    DKLp[<span class="bu">int</span>((d<span class="op">-</span><span class="dv">5</span>)<span class="op">/</span><span class="dv">5</span>)]<span class="op">=</span>np.log(np.linalg.det(sig_opt_d))<span class="op">+</span>np.<span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(sig_opt_d))))</span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a>    DKLstar[<span class="bu">int</span>((d<span class="op">-</span><span class="dv">5</span>)<span class="op">/</span><span class="dv">5</span>)]<span class="op">=</span>np.log(np.linalg.det(Sigstar))<span class="op">+</span>d</span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a><span class="co">#### plot of partial KL divergence</span></span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">5</span>,<span class="dv">105</span>,<span class="dv">5</span>),DKL,<span class="st">'rs'</span>,label<span class="op">=</span><span class="vs">r"$D'(\hat{\Sigma}^*)$"</span>)</span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">5</span>,<span class="dv">105</span>,<span class="dv">5</span>),DKLp,<span class="st">'k^'</span>,label<span class="op">=</span><span class="vs">r"$D'(\hat{\Sigma}^*_k)$"</span>)</span>
<span id="cb7-83"><a href="#cb7-83" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">5</span>,<span class="dv">105</span>,<span class="dv">5</span>),DKLstar,<span class="st">'bo'</span>,label<span class="op">=</span><span class="vs">r"$D'(\Sigma^*)$"</span>)</span>
<span id="cb7-84"><a href="#cb7-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-85"><a href="#cb7-85" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb7-86"><a href="#cb7-86" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Dimension'</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb7-87"><a href="#cb7-87" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="vs">r"Partial KL divergence $D'$"</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb7-88"><a href="#cb7-88" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb7-89"><a href="#cb7-89" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tickLabel <span class="kw">in</span> plt.gca().get_xticklabels() <span class="op">+</span> plt.gca().get_yticklabels():</span>
<span id="cb7-90"><a href="#cb7-90" aria-hidden="true" tabindex="-1"></a>    tickLabel.set_fontsize(<span class="dv">16</span>)</span>
<span id="cb7-91"><a href="#cb7-91" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb7-92"><a href="#cb7-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-93"><a href="#cb7-93" aria-hidden="true" tabindex="-1"></a><span class="co">#### plot of the eigenvalues</span></span>
<span id="cb7-94"><a href="#cb7-94" aria-hidden="true" tabindex="-1"></a>Eig1<span class="op">=</span>np.linalg.eigh(sigma)</span>
<span id="cb7-95"><a href="#cb7-95" aria-hidden="true" tabindex="-1"></a>logeig1<span class="op">=</span>np.log(Eig1[<span class="dv">0</span>])<span class="op">-</span>Eig1[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span></span>
<span id="cb7-96"><a href="#cb7-96" aria-hidden="true" tabindex="-1"></a>Table_eigv<span class="op">=</span>np.zeros((n,<span class="dv">2</span>))</span>
<span id="cb7-97"><a href="#cb7-97" aria-hidden="true" tabindex="-1"></a>Table_eigv[:,<span class="dv">0</span>]<span class="op">=</span>Eig1[<span class="dv">0</span>]</span>
<span id="cb7-98"><a href="#cb7-98" aria-hidden="true" tabindex="-1"></a>Table_eigv[:,<span class="dv">1</span>]<span class="op">=-</span>logeig1</span>
<span id="cb7-99"><a href="#cb7-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-100"><a href="#cb7-100" aria-hidden="true" tabindex="-1"></a>Eigst<span class="op">=</span>np.linalg.eigh(Sigstar)</span>
<span id="cb7-101"><a href="#cb7-101" aria-hidden="true" tabindex="-1"></a>logeigst<span class="op">=</span>np.log(Eigst[<span class="dv">0</span>])<span class="op">-</span>Eigst[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span></span>
<span id="cb7-102"><a href="#cb7-102" aria-hidden="true" tabindex="-1"></a>Table_eigv_st<span class="op">=</span>np.zeros((n,<span class="dv">2</span>))</span>
<span id="cb7-103"><a href="#cb7-103" aria-hidden="true" tabindex="-1"></a>Table_eigv_st[:,<span class="dv">0</span>]<span class="op">=</span>Eigst[<span class="dv">0</span>]</span>
<span id="cb7-104"><a href="#cb7-104" aria-hidden="true" tabindex="-1"></a>Table_eigv_st[:,<span class="dv">1</span>]<span class="op">=-</span>logeigst</span>
<span id="cb7-105"><a href="#cb7-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-106"><a href="#cb7-106" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb7-107"><a href="#cb7-107" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"Eigenvalues $\lambda_i$"</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb7-108"><a href="#cb7-108" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="vs">r"$\ell(\lambda_i)$"</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb7-109"><a href="#cb7-109" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tickLabel <span class="kw">in</span> plt.gca().get_xticklabels() <span class="op">+</span> plt.gca().get_yticklabels():</span>
<span id="cb7-110"><a href="#cb7-110" aria-hidden="true" tabindex="-1"></a>    tickLabel.set_fontsize(<span class="dv">16</span>)</span>
<span id="cb7-111"><a href="#cb7-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-112"><a href="#cb7-112" aria-hidden="true" tabindex="-1"></a>plt.plot(Table_eigv[:,<span class="dv">0</span>],Table_eigv[:,<span class="dv">1</span>],<span class="st">'bx'</span>,label<span class="op">=</span><span class="vs">r"Eigenvalues of $\hat{\Sigma}^*$"</span>)</span>
<span id="cb7-113"><a href="#cb7-113" aria-hidden="true" tabindex="-1"></a>plt.plot(Table_eigv_st[:,<span class="dv">0</span>],Table_eigv_st[:,<span class="dv">1</span>],<span class="st">'rs'</span>,label<span class="op">=</span><span class="vs">r"Eigenvalues of $\Sigma^*$"</span>)</span>
<span id="cb7-114"><a href="#cb7-114" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb7-115"><a href="#cb7-115" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="fig-inefficiency-parab" class="cell quarto-layout-panel" data-execution_count="5">
<figure class="figure">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="cell-output cell-output-display quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 50.0%;justify-content: center;">
<div id="fig-inefficiency-parab-1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="content_files/figure-html/fig-inefficiency-parab-output-1.png" class="img-fluid figure-img" data-ref-parent="fig-inefficiency-parab"></p>
<p></p><figcaption class="figure-caption">(a) Evolution of the partial KL divergence as the dimension increases, with the optimal covariance matrix <span class="math inline">\Sigma^*</span> (blue circles), the sample covariance <span class="math inline">\widehat{\Sigma}^*</span> (red squares), and the projected covariance <span class="math inline">\widehat{\Sigma}^*_k</span> (black triangles).</figcaption><p></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 50.0%;justify-content: center;">
<div id="fig-inefficiency-parab-2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="content_files/figure-html/fig-inefficiency-parab-output-2.png" class="img-fluid figure-img" data-ref-parent="fig-inefficiency-parab"></p>
<p></p><figcaption class="figure-caption">(b) Computation of <span class="math inline">\ell(\lambda_i)</span> for the eigenvalues of <span class="math inline">\Sigma^*</span> (red squares) and <span class="math inline">\widehat{\Sigma}^*</span> (blue crosses) in dimension <span class="math inline">n = 100</span>.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p></p><figcaption class="figure-caption">Figure&nbsp;3: Partial KL divergence and spectrum for the function <span class="math inline">\phi = \mathbb{I}_{\varphi \geq 0}</span> with <span class="math inline">\varphi</span> given by <a href="#eq-parabol">Equation&nbsp;14</a>. in dimension <span class="math inline">n=100</span>. Left: same behavior as for the first test case. Right: we now have two eigenvalues that stand out, and the behavior of <span class="math inline">\ell</span> is such that Algorithm 2 selects <span class="math inline">k = 2</span> which corresponds to the leftmost two.</figcaption><p></p>
</figure>
</div>
</div>
</section>
<section id="numerical-results-1" class="level3" data-number="6.2.2">
<h3 data-number="6.2.2" class="anchored" data-anchor-id="numerical-results-1"><span class="header-section-number">6.2.2</span> Numerical results</h3>
<p>The numerical results of our simulations are presented in <a href="#tbl-parabol">Table&nbsp;3</a>. We remark as before that, when using <span class="math inline">\widehat{\Sigma}^*</span>, the accuracy quickly deteriorates as the dimension increases as shows the coefficient of variation of <span class="math inline">84 \%</span> in dimension <span class="math inline">n = 100</span>. In contrast, <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{opt}}</span> leads to very accurate results, which remain close to optimal up to the same dimension <span class="math inline">n = 100</span>. This behavior is to compare with the evolution of the relative KL divergence: contrary to <span class="math inline">\widehat{\Sigma}^*</span>, <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{opt}}</span> gives a partial KL divergence close to optimal in dimension <span class="math inline">n = 100</span>. This confirms that the KL divergence is indeed a good proxy to assess the relevance of an auxiliary density.</p>
<p>It is also interesting to note that the direction <span class="math inline">\mathbf{m}^*</span> improves the situation compared to not projecting (column <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{mean}}</span> compared to <span class="math inline">\widehat{\Sigma}^*</span>), but using <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{opt}}</span> gives significantly better results, with for instance a coefficient of variation around <span class="math inline">3 \%</span> for <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{opt}}</span> and around <span class="math inline">25 \%</span> for <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{mean}}</span> in dimension <span class="math inline">n = 100</span>. Thus, this confirms our theoretical result that the <span class="math inline">\mathbf{d}^*_i</span>’s are good directions on which to project.</p>
<p>Finally, we notice that performing estimations of the projection directions instead of taking the true ones (columns <span class="math inline">{\widehat{\Sigma}^{\text{+d}}_\text{opt}}</span> vs <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{opt}}</span>) slightly degrades the situation, making the coefficient of variation increase from <span class="math inline">3</span> to <span class="math inline">7 \%</span> even if the accuracy remains satisfactory. The vMFN model is also not really adapted to this example as it gives results similar to <span class="math inline">{\widehat{\Sigma}^{\text{}}_\text{mean}}</span>. Gaussian density family are more able to fit <span class="math inline">g^*</span> than vMFN parametric model in this test case.</p>
<div class="cell" data-execution_count="6">
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Table 3. Numerical comparison on test case 2</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span><span class="dv">100</span>         <span class="co"># dimension</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>phi<span class="op">=</span>parabol</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mypi(X):                   </span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span>np.shape(X)[<span class="dv">1</span>]</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    f0<span class="op">=</span>sp.stats.multivariate_normal.pdf(X,mean<span class="op">=</span>np.zeros(n),cov<span class="op">=</span>np.eye(n))</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>((phi(X)<span class="op">&gt;</span><span class="dv">0</span>)<span class="op">*</span>f0)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>N<span class="op">=</span><span class="dv">2000</span>   </span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>M<span class="op">=</span><span class="dv">500</span>   </span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>B<span class="op">=</span><span class="dv">50</span>    <span class="co"># number of runs</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>Eopt<span class="op">=</span>np.zeros(B)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>EIS<span class="op">=</span>np.zeros(B)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>Eprj<span class="op">=</span>np.zeros(B)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>Eprm<span class="op">=</span>np.zeros(B)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>Eprjst<span class="op">=</span>np.zeros(B)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>Eprmst<span class="op">=</span>np.zeros(B)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>Evmfn<span class="op">=</span>np.zeros(B)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>SI<span class="op">=</span>[]</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>SIP<span class="op">=</span>[]</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>SIPst<span class="op">=</span>[]</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>SIM<span class="op">=</span>[]</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>SIMst<span class="op">=</span>[]</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>bigsample<span class="op">=</span><span class="dv">1</span><span class="op">*</span><span class="dv">10</span><span class="op">**</span><span class="dv">8</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>VA0<span class="op">=</span>sp.stats.multivariate_normal(mean<span class="op">=</span>np.zeros(<span class="dv">3</span>),cov<span class="op">=</span>np.eye(<span class="dv">3</span>))</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>X0<span class="op">=</span>VA0.rvs(size<span class="op">=</span>bigsample)</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>ind<span class="op">=</span>(phi(X0)<span class="op">&gt;</span><span class="dv">0</span>)</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>X<span class="op">=</span>X0[ind,:]</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>E<span class="op">=</span><span class="fl">1.51</span><span class="op">*</span><span class="dv">10</span><span class="op">**-</span><span class="dv">3</span>   <span class="co"># reference value of the integral</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>Mstar_dim3<span class="op">=</span>np.zeros(<span class="dv">3</span>)</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>Mstar_dim3[<span class="dv">0</span>]<span class="op">=</span>np.mean(X,axis<span class="op">=</span><span class="dv">0</span>)[<span class="dv">0</span>]   <span class="co"># accurate value of optimal mean in dimension 3</span></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>Xc<span class="op">=</span>(X<span class="op">-</span>Mstar_dim3).T</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>Sigstar_dim3<span class="op">=</span>Xc <span class="op">@</span> Xc.T<span class="op">/</span>np.shape(Xc)[<span class="dv">1</span>]    <span class="co"># accurate value of optimal covariance in dimension 3</span></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Mstar</span></span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a>Mstar<span class="op">=</span>np.zeros(n)</span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a>Mstar[:<span class="dv">3</span>]<span class="op">=</span>Mstar_dim3</span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a><span class="co"># Sigmastar</span></span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>Sigstar<span class="op">=</span>np.eye(n)</span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>Sigstar[:<span class="dv">3</span>,:<span class="dv">3</span>]<span class="op">=</span>Sigstar_dim3</span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a>Eigst<span class="op">=</span>np.linalg.eigh(Sigstar)                        </span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a>logeigst<span class="op">=</span>np.sort(np.log(Eigst[<span class="dv">0</span>])<span class="op">-</span>Eigst[<span class="dv">0</span>])         </span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a>deltast<span class="op">=</span>np.zeros(<span class="bu">len</span>(logeigst)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(logeigst)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a>    deltast[i]<span class="op">=</span><span class="bu">abs</span>(logeigst[i]<span class="op">-</span>logeigst[i<span class="op">+</span><span class="dv">1</span>])         </span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a><span class="co">## choice of the number of dimension</span></span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a>k_st<span class="op">=</span>np.argmax(deltast)<span class="op">+</span><span class="dv">1</span>     </span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a>indist<span class="op">=</span>[]</span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(k_st):</span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a>    indist.append(np.where(np.log(Eigst[<span class="dv">0</span>])<span class="op">-</span>Eigst[<span class="dv">0</span>]<span class="op">==</span>logeigst[i])[<span class="dv">0</span>][<span class="dv">0</span>])           </span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-67"><a href="#cb8-67" aria-hidden="true" tabindex="-1"></a>P1st<span class="op">=</span>np.array(Eigst[<span class="dv">1</span>][:,indist[<span class="dv">0</span>]],ndmin<span class="op">=</span><span class="dv">2</span>).T                          </span>
<span id="cb8-68"><a href="#cb8-68" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,k_st):</span>
<span id="cb8-69"><a href="#cb8-69" aria-hidden="true" tabindex="-1"></a>    P1st<span class="op">=</span>np.concatenate((P1st,np.array(Eigst[<span class="dv">1</span>][:,indist[i]],ndmin<span class="op">=</span><span class="dv">2</span>).T),axis<span class="op">=</span><span class="dv">1</span>)       <span class="co"># matrix of influential directions</span></span>
<span id="cb8-70"><a href="#cb8-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-71"><a href="#cb8-71" aria-hidden="true" tabindex="-1"></a><span class="co">#np.random.seed(0)</span></span>
<span id="cb8-72"><a href="#cb8-72" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(B):</span>
<span id="cb8-73"><a href="#cb8-73" aria-hidden="true" tabindex="-1"></a><span class="co">############################# Estimation of the matrices</span></span>
<span id="cb8-74"><a href="#cb8-74" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-75"><a href="#cb8-75" aria-hidden="true" tabindex="-1"></a>   <span class="co">## g*-sample of size M</span></span>
<span id="cb8-76"><a href="#cb8-76" aria-hidden="true" tabindex="-1"></a>    VA<span class="op">=</span>sp.stats.multivariate_normal(np.zeros(n),np.eye(n))      </span>
<span id="cb8-77"><a href="#cb8-77" aria-hidden="true" tabindex="-1"></a>    X0<span class="op">=</span>VA.rvs(size<span class="op">=</span>M<span class="op">*</span><span class="dv">1000</span>)                   </span>
<span id="cb8-78"><a href="#cb8-78" aria-hidden="true" tabindex="-1"></a>    ind<span class="op">=</span>(phi(X0)<span class="op">&gt;</span><span class="dv">0</span>)          </span>
<span id="cb8-79"><a href="#cb8-79" aria-hidden="true" tabindex="-1"></a>    X1<span class="op">=</span>X0[ind,:]                             </span>
<span id="cb8-80"><a href="#cb8-80" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X1[:M,:]           </span>
<span id="cb8-81"><a href="#cb8-81" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-82"><a href="#cb8-82" aria-hidden="true" tabindex="-1"></a>    R<span class="op">=</span>np.sqrt(np.<span class="bu">sum</span>(X<span class="op">**</span><span class="dv">2</span>,axis<span class="op">=</span><span class="dv">1</span>))   </span>
<span id="cb8-83"><a href="#cb8-83" aria-hidden="true" tabindex="-1"></a>    Xu<span class="op">=</span>(X.T<span class="op">/</span>R).T                </span>
<span id="cb8-84"><a href="#cb8-84" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-85"><a href="#cb8-85" aria-hidden="true" tabindex="-1"></a>   <span class="co">## estimated gaussian mean and covariance </span></span>
<span id="cb8-86"><a href="#cb8-86" aria-hidden="true" tabindex="-1"></a>    mm<span class="op">=</span>np.mean(X,axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb8-87"><a href="#cb8-87" aria-hidden="true" tabindex="-1"></a>    Xc<span class="op">=</span>(X<span class="op">-</span>mm).T</span>
<span id="cb8-88"><a href="#cb8-88" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span>Xc <span class="op">@</span> Xc.T<span class="op">/</span>np.shape(Xc)[<span class="dv">1</span>]  </span>
<span id="cb8-89"><a href="#cb8-89" aria-hidden="true" tabindex="-1"></a>    SI.append(sigma)</span>
<span id="cb8-90"><a href="#cb8-90" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-91"><a href="#cb8-91" aria-hidden="true" tabindex="-1"></a>   <span class="co">## von Mises Fisher parameters</span></span>
<span id="cb8-92"><a href="#cb8-92" aria-hidden="true" tabindex="-1"></a>    normu<span class="op">=</span>np.sqrt(np.mean(Xu,axis<span class="op">=</span><span class="dv">0</span>).dot(np.mean(Xu,axis<span class="op">=</span><span class="dv">0</span>).T))</span>
<span id="cb8-93"><a href="#cb8-93" aria-hidden="true" tabindex="-1"></a>    mu<span class="op">=</span>np.mean(Xu,axis<span class="op">=</span><span class="dv">0</span>)<span class="op">/</span>normu</span>
<span id="cb8-94"><a href="#cb8-94" aria-hidden="true" tabindex="-1"></a>    mu<span class="op">=</span>np.array(mu,ndmin<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb8-95"><a href="#cb8-95" aria-hidden="true" tabindex="-1"></a>    chi<span class="op">=</span><span class="bu">min</span>(normu,<span class="fl">0.95</span>)</span>
<span id="cb8-96"><a href="#cb8-96" aria-hidden="true" tabindex="-1"></a>    kappa<span class="op">=</span>(chi<span class="op">*</span>n<span class="op">-</span>chi<span class="op">**</span><span class="dv">3</span>)<span class="op">/</span>(<span class="dv">1</span><span class="op">-</span>chi<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb8-97"><a href="#cb8-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-98"><a href="#cb8-98" aria-hidden="true" tabindex="-1"></a>   <span class="co">## Nakagami parameters</span></span>
<span id="cb8-99"><a href="#cb8-99" aria-hidden="true" tabindex="-1"></a>    omega<span class="op">=</span>np.mean(R<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb8-100"><a href="#cb8-100" aria-hidden="true" tabindex="-1"></a>    tau4<span class="op">=</span>np.mean(R<span class="op">**</span><span class="dv">4</span>)</span>
<span id="cb8-101"><a href="#cb8-101" aria-hidden="true" tabindex="-1"></a>    pp<span class="op">=</span>omega<span class="op">**</span><span class="dv">2</span><span class="op">/</span>(tau4<span class="op">-</span>omega<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb8-102"><a href="#cb8-102" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-103"><a href="#cb8-103" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb8-104"><a href="#cb8-104" aria-hidden="true" tabindex="-1"></a>    Eig<span class="op">=</span>np.linalg.eigh(sigma)                     </span>
<span id="cb8-105"><a href="#cb8-105" aria-hidden="true" tabindex="-1"></a>    logeig<span class="op">=</span>np.sort(np.log(Eig[<span class="dv">0</span>])<span class="op">-</span>Eig[<span class="dv">0</span>])     </span>
<span id="cb8-106"><a href="#cb8-106" aria-hidden="true" tabindex="-1"></a>    delta<span class="op">=</span>np.zeros(<span class="bu">len</span>(logeig)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb8-107"><a href="#cb8-107" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(logeig)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb8-108"><a href="#cb8-108" aria-hidden="true" tabindex="-1"></a>        delta[j]<span class="op">=</span><span class="bu">abs</span>(logeig[j]<span class="op">-</span>logeig[j<span class="op">+</span><span class="dv">1</span>])    </span>
<span id="cb8-109"><a href="#cb8-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-110"><a href="#cb8-110" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span>np.argmax(delta)<span class="op">+</span><span class="dv">1</span>         </span>
<span id="cb8-111"><a href="#cb8-111" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-112"><a href="#cb8-112" aria-hidden="true" tabindex="-1"></a>    indi<span class="op">=</span>[]</span>
<span id="cb8-113"><a href="#cb8-113" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb8-114"><a href="#cb8-114" aria-hidden="true" tabindex="-1"></a>        indi.append(np.where(np.log(Eig[<span class="dv">0</span>])<span class="op">-</span>Eig[<span class="dv">0</span>]<span class="op">==</span>logeig[l])[<span class="dv">0</span>][<span class="dv">0</span>])</span>
<span id="cb8-115"><a href="#cb8-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-116"><a href="#cb8-116" aria-hidden="true" tabindex="-1"></a>    P1<span class="op">=</span>np.array(Eig[<span class="dv">1</span>][:,indi[<span class="dv">0</span>]],ndmin<span class="op">=</span><span class="dv">2</span>).T</span>
<span id="cb8-117"><a href="#cb8-117" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,k):</span>
<span id="cb8-118"><a href="#cb8-118" aria-hidden="true" tabindex="-1"></a>        P1<span class="op">=</span>np.concatenate((P1,np.array(Eig[<span class="dv">1</span>][:,indi[l]],ndmin<span class="op">=</span><span class="dv">2</span>).T),axis<span class="op">=</span><span class="dv">1</span>)     </span>
<span id="cb8-119"><a href="#cb8-119" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-120"><a href="#cb8-120" aria-hidden="true" tabindex="-1"></a>    diagsi<span class="op">=</span>np.diag(Eig[<span class="dv">0</span>][indi])                           </span>
<span id="cb8-121"><a href="#cb8-121" aria-hidden="true" tabindex="-1"></a>    sig_opt_d<span class="op">=</span>P1.dot((diagsi<span class="op">-</span>np.eye(k))).dot(P1.T)<span class="op">+</span>np.eye(n)</span>
<span id="cb8-122"><a href="#cb8-122" aria-hidden="true" tabindex="-1"></a>    SIP.append(sig_opt_d)</span>
<span id="cb8-123"><a href="#cb8-123" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-124"><a href="#cb8-124" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb8-125"><a href="#cb8-125" aria-hidden="true" tabindex="-1"></a>    diagsist<span class="op">=</span>P1st.T.dot(sigma).dot(P1st)                   </span>
<span id="cb8-126"><a href="#cb8-126" aria-hidden="true" tabindex="-1"></a>    sig_opt<span class="op">=</span>P1st.dot(diagsist<span class="op">-</span>np.eye(k_st)).dot(P1st.T)<span class="op">+</span>np.eye(n)</span>
<span id="cb8-127"><a href="#cb8-127" aria-hidden="true" tabindex="-1"></a>    SIPst.append(sig_opt)</span>
<span id="cb8-128"><a href="#cb8-128" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-129"><a href="#cb8-129" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb8-130"><a href="#cb8-130" aria-hidden="true" tabindex="-1"></a>    Norm_mm<span class="op">=</span>np.linalg.norm(mm)               </span>
<span id="cb8-131"><a href="#cb8-131" aria-hidden="true" tabindex="-1"></a>    normalised_mm<span class="op">=</span>np.array(mm,ndmin<span class="op">=</span><span class="dv">2</span>).T<span class="op">/</span>Norm_mm        </span>
<span id="cb8-132"><a href="#cb8-132" aria-hidden="true" tabindex="-1"></a>    vhat<span class="op">=</span>normalised_mm.T.dot(sigma).dot(normalised_mm)          </span>
<span id="cb8-133"><a href="#cb8-133" aria-hidden="true" tabindex="-1"></a>    sig_mean_d<span class="op">=</span>(vhat<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>normalised_mm.dot(normalised_mm.T)<span class="op">+</span>np.eye(n) </span>
<span id="cb8-134"><a href="#cb8-134" aria-hidden="true" tabindex="-1"></a>    SIM.append(sig_mean_d)</span>
<span id="cb8-135"><a href="#cb8-135" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-136"><a href="#cb8-136" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb8-137"><a href="#cb8-137" aria-hidden="true" tabindex="-1"></a>    Norm_Mstar<span class="op">=</span>np.linalg.norm(Mstar)               </span>
<span id="cb8-138"><a href="#cb8-138" aria-hidden="true" tabindex="-1"></a>    normalised_Mstar<span class="op">=</span>np.array(Mstar,ndmin<span class="op">=</span><span class="dv">2</span>).T<span class="op">/</span>Norm_Mstar   </span>
<span id="cb8-139"><a href="#cb8-139" aria-hidden="true" tabindex="-1"></a>    vhatst<span class="op">=</span>normalised_Mstar.T.dot(sigma).dot(normalised_Mstar)      </span>
<span id="cb8-140"><a href="#cb8-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-141"><a href="#cb8-141" aria-hidden="true" tabindex="-1"></a>    sig_mean<span class="op">=</span>(vhatst<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>normalised_Mstar.dot(normalised_Mstar.T)<span class="op">+</span>np.eye(n) </span>
<span id="cb8-142"><a href="#cb8-142" aria-hidden="true" tabindex="-1"></a>    SIMst.append(sig_mean)</span>
<span id="cb8-143"><a href="#cb8-143" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-144"><a href="#cb8-144" aria-hidden="true" tabindex="-1"></a><span class="co">############################################# Estimation of the integral</span></span>
<span id="cb8-145"><a href="#cb8-145" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb8-146"><a href="#cb8-146" aria-hidden="true" tabindex="-1"></a>    Xop<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>Sigstar,size<span class="op">=</span>N)              </span>
<span id="cb8-147"><a href="#cb8-147" aria-hidden="true" tabindex="-1"></a>    wop<span class="op">=</span>mypi(Xop)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xop,mean<span class="op">=</span>mm, cov<span class="op">=</span>Sigstar)       </span>
<span id="cb8-148"><a href="#cb8-148" aria-hidden="true" tabindex="-1"></a>    Eopt[i]<span class="op">=</span>np.mean(wop)                                                     </span>
<span id="cb8-149"><a href="#cb8-149" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-150"><a href="#cb8-150" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb8-151"><a href="#cb8-151" aria-hidden="true" tabindex="-1"></a>    Xis<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sigma,size<span class="op">=</span>N)</span>
<span id="cb8-152"><a href="#cb8-152" aria-hidden="true" tabindex="-1"></a>    wis<span class="op">=</span>mypi(Xis)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xis,mean<span class="op">=</span>mm, cov<span class="op">=</span>sigma)</span>
<span id="cb8-153"><a href="#cb8-153" aria-hidden="true" tabindex="-1"></a>    EIS[i]<span class="op">=</span>np.mean(wis)</span>
<span id="cb8-154"><a href="#cb8-154" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-155"><a href="#cb8-155" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb8-156"><a href="#cb8-156" aria-hidden="true" tabindex="-1"></a>    Xpr<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_opt_d,size<span class="op">=</span>N)</span>
<span id="cb8-157"><a href="#cb8-157" aria-hidden="true" tabindex="-1"></a>    wpr<span class="op">=</span>mypi(Xpr)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xpr,mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_opt_d)</span>
<span id="cb8-158"><a href="#cb8-158" aria-hidden="true" tabindex="-1"></a>    Eprj[i]<span class="op">=</span>np.mean(wpr)</span>
<span id="cb8-159"><a href="#cb8-159" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-160"><a href="#cb8-160" aria-hidden="true" tabindex="-1"></a>   <span class="co">###   </span></span>
<span id="cb8-161"><a href="#cb8-161" aria-hidden="true" tabindex="-1"></a>    Xpm<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_mean_d,size<span class="op">=</span>N)</span>
<span id="cb8-162"><a href="#cb8-162" aria-hidden="true" tabindex="-1"></a>    wpm<span class="op">=</span>mypi(Xpm)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xpm,mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_mean_d)</span>
<span id="cb8-163"><a href="#cb8-163" aria-hidden="true" tabindex="-1"></a>    Eprm[i]<span class="op">=</span>np.mean(wpm)</span>
<span id="cb8-164"><a href="#cb8-164" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-165"><a href="#cb8-165" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb8-166"><a href="#cb8-166" aria-hidden="true" tabindex="-1"></a>    Xprst<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_opt,size<span class="op">=</span>N)</span>
<span id="cb8-167"><a href="#cb8-167" aria-hidden="true" tabindex="-1"></a>    wprst<span class="op">=</span>mypi(Xprst)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xprst,mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_opt)</span>
<span id="cb8-168"><a href="#cb8-168" aria-hidden="true" tabindex="-1"></a>    Eprjst[i]<span class="op">=</span>np.mean(wprst)</span>
<span id="cb8-169"><a href="#cb8-169" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-170"><a href="#cb8-170" aria-hidden="true" tabindex="-1"></a>   <span class="co">###    </span></span>
<span id="cb8-171"><a href="#cb8-171" aria-hidden="true" tabindex="-1"></a>    Xpmst<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_mean,size<span class="op">=</span>N)</span>
<span id="cb8-172"><a href="#cb8-172" aria-hidden="true" tabindex="-1"></a>    wpmst<span class="op">=</span>mypi(Xpmst)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xpmst,mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_mean)</span>
<span id="cb8-173"><a href="#cb8-173" aria-hidden="true" tabindex="-1"></a>    Eprmst[i]<span class="op">=</span>np.mean(wpmst)</span>
<span id="cb8-174"><a href="#cb8-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-175"><a href="#cb8-175" aria-hidden="true" tabindex="-1"></a>   <span class="co">###</span></span>
<span id="cb8-176"><a href="#cb8-176" aria-hidden="true" tabindex="-1"></a>    Xvmfn <span class="op">=</span> vMFNM_sample(mu, kappa, omega, pp, <span class="dv">1</span>, N)</span>
<span id="cb8-177"><a href="#cb8-177" aria-hidden="true" tabindex="-1"></a>    Rvn<span class="op">=</span>np.sqrt(np.<span class="bu">sum</span>(Xvmfn<span class="op">**</span><span class="dv">2</span>,axis<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb8-178"><a href="#cb8-178" aria-hidden="true" tabindex="-1"></a>    Xvnu<span class="op">=</span>Xvmfn.T<span class="op">/</span>Rvn</span>
<span id="cb8-179"><a href="#cb8-179" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb8-180"><a href="#cb8-180" aria-hidden="true" tabindex="-1"></a>    h_log<span class="op">=</span>vMF_logpdf(Xvnu,mu.T,kappa)<span class="op">+</span>nakagami_logpdf(Rvn,pp,omega)</span>
<span id="cb8-181"><a href="#cb8-181" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> np.log(n) <span class="op">+</span> np.log(np.pi <span class="op">**</span> (n <span class="op">/</span> <span class="dv">2</span>)) <span class="op">-</span> sp.special.gammaln(n <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb8-182"><a href="#cb8-182" aria-hidden="true" tabindex="-1"></a>    f_u <span class="op">=</span> <span class="op">-</span>A       </span>
<span id="cb8-183"><a href="#cb8-183" aria-hidden="true" tabindex="-1"></a>    f_chi <span class="op">=</span> (np.log(<span class="dv">2</span>) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> n <span class="op">/</span> <span class="dv">2</span>) <span class="op">+</span> np.log(Rvn) <span class="op">*</span> (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> Rvn <span class="op">**</span> <span class="dv">2</span> <span class="op">-</span> sp.special.gammaln(n <span class="op">/</span> <span class="dv">2</span>)) </span>
<span id="cb8-184"><a href="#cb8-184" aria-hidden="true" tabindex="-1"></a>    f_log <span class="op">=</span> f_u <span class="op">+</span> f_chi</span>
<span id="cb8-185"><a href="#cb8-185" aria-hidden="true" tabindex="-1"></a>    W_log <span class="op">=</span> f_log <span class="op">-</span> h_log</span>
<span id="cb8-186"><a href="#cb8-186" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-187"><a href="#cb8-187" aria-hidden="true" tabindex="-1"></a>    wvmfn<span class="op">=</span>(phi(Xvmfn)<span class="op">&gt;</span><span class="dv">0</span>)<span class="op">*</span>np.exp(W_log)          </span>
<span id="cb8-188"><a href="#cb8-188" aria-hidden="true" tabindex="-1"></a>    Evmfn[i]<span class="op">=</span>np.mean(wvmfn)</span>
<span id="cb8-189"><a href="#cb8-189" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-190"><a href="#cb8-190" aria-hidden="true" tabindex="-1"></a><span class="co">### KL divergences    </span></span>
<span id="cb8-191"><a href="#cb8-191" aria-hidden="true" tabindex="-1"></a>dkli<span class="op">=</span>np.zeros(B)</span>
<span id="cb8-192"><a href="#cb8-192" aria-hidden="true" tabindex="-1"></a>dklp<span class="op">=</span>np.zeros(B)</span>
<span id="cb8-193"><a href="#cb8-193" aria-hidden="true" tabindex="-1"></a>dklm<span class="op">=</span>np.zeros(B)</span>
<span id="cb8-194"><a href="#cb8-194" aria-hidden="true" tabindex="-1"></a>dklpst<span class="op">=</span>np.zeros(B)</span>
<span id="cb8-195"><a href="#cb8-195" aria-hidden="true" tabindex="-1"></a>dklmst<span class="op">=</span>np.zeros(B)</span>
<span id="cb8-196"><a href="#cb8-196" aria-hidden="true" tabindex="-1"></a>dklpca<span class="op">=</span>np.zeros(B)</span>
<span id="cb8-197"><a href="#cb8-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-198"><a href="#cb8-198" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(B):</span>
<span id="cb8-199"><a href="#cb8-199" aria-hidden="true" tabindex="-1"></a>    dkli[i]<span class="op">=</span>np.log(np.linalg.det(SI[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SI[i]))))      </span>
<span id="cb8-200"><a href="#cb8-200" aria-hidden="true" tabindex="-1"></a>    dklp[i]<span class="op">=</span>np.log(np.linalg.det(SIP[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SIP[i]))))        </span>
<span id="cb8-201"><a href="#cb8-201" aria-hidden="true" tabindex="-1"></a>    dklm[i]<span class="op">=</span>np.log(np.linalg.det(SIM[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SIM[i]))))</span>
<span id="cb8-202"><a href="#cb8-202" aria-hidden="true" tabindex="-1"></a>    dklpst[i]<span class="op">=</span>np.log(np.linalg.det(SIPst[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SIPst[i]))))</span>
<span id="cb8-203"><a href="#cb8-203" aria-hidden="true" tabindex="-1"></a>    dklmst[i]<span class="op">=</span>np.log(np.linalg.det(SIMst[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SIMst[i]))))</span>
<span id="cb8-204"><a href="#cb8-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-205"><a href="#cb8-205" aria-hidden="true" tabindex="-1"></a>Tabresult<span class="op">=</span>np.zeros((<span class="dv">3</span>,<span class="dv">7</span>)) <span class="co"># table of results</span></span>
<span id="cb8-206"><a href="#cb8-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-207"><a href="#cb8-207" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">0</span>]<span class="op">=</span>np.log(np.linalg.det(Sigstar))<span class="op">+</span>n</span>
<span id="cb8-208"><a href="#cb8-208" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">1</span>]<span class="op">=</span>np.mean(dkli)</span>
<span id="cb8-209"><a href="#cb8-209" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">2</span>]<span class="op">=</span>np.mean(dklpst)</span>
<span id="cb8-210"><a href="#cb8-210" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">3</span>]<span class="op">=</span>np.mean(dklmst)</span>
<span id="cb8-211"><a href="#cb8-211" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">4</span>]<span class="op">=</span>np.mean(dklp)</span>
<span id="cb8-212"><a href="#cb8-212" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">5</span>]<span class="op">=</span>np.mean(dklm)</span>
<span id="cb8-213"><a href="#cb8-213" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">6</span>]<span class="op">=</span><span class="va">None</span></span>
<span id="cb8-214"><a href="#cb8-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-215"><a href="#cb8-215" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">0</span>]<span class="op">=</span>np.mean(Eopt<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb8-216"><a href="#cb8-216" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">1</span>]<span class="op">=</span>np.mean(EIS<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb8-217"><a href="#cb8-217" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">2</span>]<span class="op">=</span>np.mean(Eprjst<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb8-218"><a href="#cb8-218" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">3</span>]<span class="op">=</span>np.mean(Eprmst<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb8-219"><a href="#cb8-219" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">4</span>]<span class="op">=</span>np.mean(Eprj<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb8-220"><a href="#cb8-220" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">5</span>]<span class="op">=</span>np.mean(Eprm<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb8-221"><a href="#cb8-221" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">6</span>]<span class="op">=</span>np.mean(Evmfn<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb8-222"><a href="#cb8-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-223"><a href="#cb8-223" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">0</span>]<span class="op">=</span>np.sqrt(np.mean((Eopt<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb8-224"><a href="#cb8-224" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">1</span>]<span class="op">=</span>np.sqrt(np.mean((EIS<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb8-225"><a href="#cb8-225" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">2</span>]<span class="op">=</span>np.sqrt(np.mean((Eprjst<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb8-226"><a href="#cb8-226" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">3</span>]<span class="op">=</span>np.sqrt(np.mean((Eprmst<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb8-227"><a href="#cb8-227" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">4</span>]<span class="op">=</span>np.sqrt(np.mean((Eprj<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb8-228"><a href="#cb8-228" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">5</span>]<span class="op">=</span>np.sqrt(np.mean((Eprm<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb8-229"><a href="#cb8-229" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">6</span>]<span class="op">=</span>np.sqrt(np.mean((Evmfn<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb8-230"><a href="#cb8-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-231"><a href="#cb8-231" aria-hidden="true" tabindex="-1"></a>Tabresult<span class="op">=</span>np.<span class="bu">round</span>(Tabresult,<span class="dv">1</span>)</span>
<span id="cb8-232"><a href="#cb8-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-233"><a href="#cb8-233" aria-hidden="true" tabindex="-1"></a>table<span class="op">=</span>[[<span class="st">"D'"</span>,Tabresult[<span class="dv">0</span>,<span class="dv">0</span>],Tabresult[<span class="dv">0</span>,<span class="dv">1</span>],Tabresult[<span class="dv">0</span>,<span class="dv">2</span>],Tabresult[<span class="dv">0</span>,<span class="dv">3</span>],Tabresult[<span class="dv">0</span>,<span class="dv">4</span>],Tabresult[<span class="dv">0</span>,<span class="dv">5</span>],Tabresult[<span class="dv">0</span>,<span class="dv">6</span>]],</span>
<span id="cb8-234"><a href="#cb8-234" aria-hidden="true" tabindex="-1"></a>      [<span class="st">"Relative error (\%)"</span>,Tabresult[<span class="dv">1</span>,<span class="dv">0</span>],Tabresult[<span class="dv">1</span>,<span class="dv">1</span>],Tabresult[<span class="dv">1</span>,<span class="dv">2</span>],Tabresult[<span class="dv">1</span>,<span class="dv">3</span>],Tabresult[<span class="dv">1</span>,<span class="dv">4</span>],Tabresult[<span class="dv">1</span>,<span class="dv">5</span>],Tabresult[<span class="dv">1</span>,<span class="dv">6</span>]],</span>
<span id="cb8-235"><a href="#cb8-235" aria-hidden="true" tabindex="-1"></a>    [<span class="st">"Coefficient of variation (\%)"</span>,Tabresult[<span class="dv">2</span>,<span class="dv">0</span>],Tabresult[<span class="dv">2</span>,<span class="dv">1</span>],Tabresult[<span class="dv">2</span>,<span class="dv">2</span>],Tabresult[<span class="dv">2</span>,<span class="dv">3</span>],Tabresult[<span class="dv">2</span>,<span class="dv">4</span>],Tabresult[<span class="dv">2</span>,<span class="dv">5</span>],Tabresult[<span class="dv">2</span>,<span class="dv">6</span>]]]</span>
<span id="cb8-236"><a href="#cb8-236" aria-hidden="true" tabindex="-1"></a>Markdown(tabulate(</span>
<span id="cb8-237"><a href="#cb8-237" aria-hidden="true" tabindex="-1"></a>  table, </span>
<span id="cb8-238"><a href="#cb8-238" aria-hidden="true" tabindex="-1"></a>  headers<span class="op">=</span>[<span class="st">""</span>,<span class="st">"$\Sigma^*$"</span>, <span class="st">"$\hat{\Sigma}^*$"</span>, <span class="st">"$\hat{\Sigma}_</span><span class="sc">{opt}</span><span class="st">$"</span>, <span class="st">"$\hat{\Sigma}_</span><span class="sc">{mean}</span><span class="st">$"</span>, <span class="st">"${\hat{\Sigma}^{+d}_</span><span class="sc">{opt}</span><span class="st">}$"</span>, <span class="st">"$\hat{\Sigma}^{+d}_</span><span class="sc">{mean}</span><span class="st">$"</span>, <span class="st">"vMFN"</span>],</span>
<span id="cb8-239"><a href="#cb8-239" aria-hidden="true" tabindex="-1"></a>    tablefmt<span class="op">=</span><span class="st">"pipe"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="6">
<div id="tbl-parabol" class="anchored">
<table class="table table-sm table-striped">
<caption>Table&nbsp;3: Numerical comparison of the estimation of <span class="math inline">E \approx 1.51\cdot 10^{-3}</span> considering the Gaussian density with the six covariance matrices defined in <a href="#sec-def_cov">Section&nbsp;5.2</a> and the vFMN model, when <span class="math inline">\phi = \mathbb{I}_{{\varphi\geq 0}}</span> with <span class="math inline">\varphi</span> the quadratic function given by <a href="#eq-parabol">Equation&nbsp;14</a>.</caption>
<colgroup>
<col style="width: 16%">
<col style="width: 7%">
<col style="width: 10%">
<col style="width: 13%">
<col style="width: 13%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 4%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;"><span class="math inline">\Sigma^*</span></th>
<th style="text-align: right;"><span class="math inline">\hat{\Sigma}^*</span></th>
<th style="text-align: right;"><span class="math inline">\hat{\Sigma}_{opt}</span></th>
<th style="text-align: right;"><span class="math inline">\hat{\Sigma}_{mean}</span></th>
<th style="text-align: right;"><span class="math inline">{\hat{\Sigma}^{+d}_{opt}}</span></th>
<th style="text-align: right;"><span class="math inline">\hat{\Sigma}^{+d}_{mean}</span></th>
<th style="text-align: right;">vMFN</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">D’</td>
<td style="text-align: right;">89.1</td>
<td style="text-align: right;">103.7</td>
<td style="text-align: right;">89.7</td>
<td style="text-align: right;">96.7</td>
<td style="text-align: right;">90.4</td>
<td style="text-align: right;">96.8</td>
<td style="text-align: right;">nan</td>
</tr>
<tr class="even">
<td style="text-align: left;">Relative error (%)</td>
<td style="text-align: right;">-0.5</td>
<td style="text-align: right;">133.2</td>
<td style="text-align: right;">-0.1</td>
<td style="text-align: right;">2.1</td>
<td style="text-align: right;">-0.5</td>
<td style="text-align: right;">6.1</td>
<td style="text-align: right;">-2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coefficient of variation (%)</td>
<td style="text-align: right;">3.3</td>
<td style="text-align: right;">716.6</td>
<td style="text-align: right;">3.6</td>
<td style="text-align: right;">24.7</td>
<td style="text-align: right;">9.3</td>
<td style="text-align: right;">31.6</td>
<td style="text-align: right;">26.3</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<!-- -->

</section>
</section>
</section>
<section id="bibliography" class="level1 unnumbered">


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">Bibliography</h2><div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-AgapiouEtAl_ImportanceSamplingIntrinsic_2017" class="csl-entry" role="doc-biblioentry">
Agapiou, S., O. Papaspiliopoulos, D. Sanz-Alonso, and A. M. Stuart. 2017. <span>“Importance <span>Sampling</span> : <span>Intrinsic Dimension</span> and <span>Computational Cost</span>.”</span> <em>Statistical Science, Volume 32, P405-431</em>. <a href="https://doi.org/10.1214/17-STS611">https://doi.org/10.1214/17-STS611</a>.
</div>
<div id="ref-AshurbekovaEtAl_OptimalShrinkageRobust_" class="csl-entry" role="doc-biblioentry">
Ashurbekova, Karina, Antoine Usseglio-Carleve, Florence Forbes, and Sophie Achard. 2020. <span>“Optimal Shrinkage for Robust Covariance Matrix Estimators in a Small Sample Size Setting.”</span>
</div>
<div id="ref-AuBeck_ImportantSamplingHigh_2003" class="csl-entry" role="doc-biblioentry">
Au, S. K., and J. L. Beck. 2003. <span>“Important Sampling in High Dimensions.”</span> <em>Structural Safety</em> 25 (2): 139–63. <a href="https://doi.org/10.1016/S0167-4730(02)00047-4">https://doi.org/10.1016/S0167-4730(02)00047-4</a>.
</div>
<div id="ref-BengtssonEtAl_CurseofdimensionalityRevisitedCollapse_2008" class="csl-entry" role="doc-biblioentry">
Bengtsson, Thomas, Peter Bickel, and Bo Li. 2008. <span>“Curse-of-Dimensionality Revisited: <span>Collapse</span> of the Particle Filter in Very Large Scale Systems.”</span> In <em>Institute of <span>Mathematical Statistics Collections</span></em>, 316–34. <span>Beachwood, Ohio, USA</span>: <span>Institute of Mathematical Statistics</span>. <a href="https://doi.org/10.1214/193940307000000518">https://doi.org/10.1214/193940307000000518</a>.
</div>
<div id="ref-bucklew2013introduction" class="csl-entry" role="doc-biblioentry">
Bucklew, James. 2013. <em>Introduction to Rare Event Simulation</em>. Springer Science &amp; Business Media. <a href="https://doi.org/10.1007/978-1-4757-4078-3">https://doi.org/10.1007/978-1-4757-4078-3</a>.
</div>
<div id="ref-BugalloEtAl_AdaptiveImportanceSampling_2017" class="csl-entry" role="doc-biblioentry">
Bugallo, Monica F., Victor Elvira, Luca Martino, David Luengo, Joaquin Miguez, and Petar M. Djuric. 2017. <span>“Adaptive <span>Importance Sampling</span>: <span>The</span> Past, the Present, and the Future.”</span> <em>IEEE Signal Processing Magazine</em> 34 (4): 60–79. <a href="https://doi.org/10.1109/MSP.2017.2699226">https://doi.org/10.1109/MSP.2017.2699226</a>.
</div>
<div id="ref-CappeEtAl_AdaptiveImportanceSampling_2008" class="csl-entry" role="doc-biblioentry">
Cappé, Olivier, Randal Douc, Arnaud Guillin, Jean-Michel Marin, and Christian P. Robert. 2008. <span>“Adaptive Importance Sampling in General Mixture Classes.”</span> <em>Statistics and Computing</em> 18 (4): 447–59. <a href="https://doi.org/10.1007/s11222-008-9059-x">https://doi.org/10.1007/s11222-008-9059-x</a>.
</div>
<div id="ref-ChanKroese_ImprovedCrossentropyMethod_2012" class="csl-entry" role="doc-biblioentry">
Chan, Joshua C. C., and Dirk P. Kroese. 2012. <span>“Improved Cross-Entropy Method for Estimation.”</span> <em>Statistics and Computing</em> 22 (5): 1031–40. <a href="https://doi.org/10.1007/s11222-011-9275-7">https://doi.org/10.1007/s11222-011-9275-7</a>.
</div>
<div id="ref-Chatterjee18:0" class="csl-entry" role="doc-biblioentry">
Chatterjee, Sourav, and Persi Diaconis. 2018. <span>“The Sample Size Required in Importance Sampling.”</span> <em>Ann. Appl. Probab.</em> 28 (2): 1099–1135. <a href="https://doi.org/10.1214/17-AAP1326">https://doi.org/10.1214/17-AAP1326</a>.
</div>
<div id="ref-CornuetEtAl_AdaptiveMultipleImportance_2012" class="csl-entry" role="doc-biblioentry">
Cornuet, Jean-Marie, Jean-Michel Marin, Antonietta Mira, and Christian P. Robert. 2012. <span>“Adaptive <span>Multiple Importance Sampling</span>: <span><em>Adaptive</em></span><span> <em>Multiple Importance Sampling</em></span>.”</span> <em>Scandinavian Journal of Statistics</em> 39 (4): 798–812. <a href="https://doi.org/10.1111/j.1467-9469.2011.00756.x">https://doi.org/10.1111/j.1467-9469.2011.00756.x</a>.
</div>
<div id="ref-MasriEtAl_ImprovementCrossentropyMethod_2020" class="csl-entry" role="doc-biblioentry">
El Masri, Maxime, Jérôme Morio, and Florian Simatos. 2021. <span>“Improvement of the Cross-Entropy Method in High Dimension for Failure Probability Estimation Through a One-Dimensional Projection Without Gradient Estimation.”</span> <em>Reliability Engineering &amp; System Safety</em> 216: 107991. <a href="https://doi.org/10.1016/j.ress.2021.107991">https://doi.org/10.1016/j.ress.2021.107991</a>.
</div>
<div id="ref-El-LahamEtAl_RecursiveShrinkageCovariance_" class="csl-entry" role="doc-biblioentry">
El-Laham, Yousef, Vı́ctor Elvira, and Mónica Bugallo. 2019. <span>“Recursive Shrinkage Covariance Learning in Adaptive Importance Sampling.”</span> In <em>2019 IEEE 8th International Workshop on Computational Advances in Multi-Sensor Adaptive Processing (CAMSAP)</em>, 624–28. IEEE. <a href="https://doi.org/10.1109/CAMSAP45676.2019.9022450">https://doi.org/10.1109/CAMSAP45676.2019.9022450</a>.
</div>
<div id="ref-GraceEtAl_AutomatedStateDependentImportance_2014" class="csl-entry" role="doc-biblioentry">
Grace, Adam W., Dirk P. Kroese, and Werner Sandmann. 2014. <span>“Automated <span>State</span>-<span>Dependent Importance Sampling</span> for <span>Markov Jump Processes</span> via <span>Sampling</span> from the <span>Zero</span>-<span>Variance Distribution</span>.”</span> <em>Journal of Applied Probability</em> 51 (3): 741–55. <a href="https://doi.org/10.1239/jap/1409932671">https://doi.org/10.1239/jap/1409932671</a>.
</div>
<div id="ref-HohenbichlerRackwitz_NonNormalDependentVectors_1981" class="csl-entry" role="doc-biblioentry">
Hohenbichler, Michael, and Rüdiger Rackwitz. 1981. <span>“Non-<span>Normal Dependent Vectors</span> in <span>Structural Safety</span>.”</span> <em>Journal of the Engineering Mechanics Division</em> 107 (6): 1227–38. <a href="https://doi.org/10.1061/JMCEA3.0002777">https://doi.org/10.1061/JMCEA3.0002777</a>.
</div>
<div id="ref-LedoitWolf_WellconditionedEstimatorLargedimensional_2004" class="csl-entry" role="doc-biblioentry">
Ledoit, Olivier, and Michael Wolf. 2004. <span>“A Well-Conditioned Estimator for Large-Dimensional Covariance Matrices.”</span> <em>Journal of Multivariate Analysis</em> 88 (2): 365–411. <a href="https://doi.org/10.1016/S0047-259X(03)00096-4">https://doi.org/10.1016/S0047-259X(03)00096-4</a>.
</div>
<div id="ref-LiuDerKiureghian_MultivariateDistributionModels_1986" class="csl-entry" role="doc-biblioentry">
Liu, Pei-Ling, and Armen Der Kiureghian. 1986. <span>“Multivariate Distribution Models with Prescribed Marginals and Covariances.”</span> <em>Probabilistic Engineering Mechanics</em> 1 (2): 105–12. <a href="https://doi.org/10.1016/0266-8920(86)90033-0">https://doi.org/10.1016/0266-8920(86)90033-0</a>.
</div>
<div id="ref-OwenZhou_SafeEffectiveImportance_2000" class="csl-entry" role="doc-biblioentry">
Owen, Art, and Yi Zhou. 2000. <span>“Safe and <span>Effective Importance Sampling</span>.”</span> <em>Journal of the American Statistical Association</em> 95 (449): 135–43. <a href="https://doi.org/10.1080/01621459.2000.10473909">https://doi.org/10.1080/01621459.2000.10473909</a>.
</div>
<div id="ref-PapaioannouEtAl_ImprovedCrossEntropybased_2019" class="csl-entry" role="doc-biblioentry">
Papaioannou, Iason, Sebastian Geyer, and Daniel Straub. 2019. <span>“Improved Cross Entropy-Based Importance Sampling with a Flexible Mixture Model.”</span> <em>Reliability Engineering &amp; System Safety</em> 191 (November): 106564. <a href="https://doi.org/10.1016/j.ress.2019.106564">https://doi.org/10.1016/j.ress.2019.106564</a>.
</div>
<div id="ref-RubinsteinKroese_SimulationMonteCarlo_2017" class="csl-entry" role="doc-biblioentry">
Rubinstein, Reuven Y., and Dirk P. Kroese. 2017. <em>Simulation and the <span>Monte Carlo</span> Method</em>. Third edition. Wiley Series in Probability and Statistics. <span>Hoboken, New Jersey</span>: <span>Wiley</span>. <a href="https://doi.org/10.1002/9781118631980">https://doi.org/10.1002/9781118631980</a>.
</div>
<div id="ref-RubinsteinKroese_CrossentropyMethodUnified_2011" class="csl-entry" role="doc-biblioentry">
Rubinstein, Reuven Y, and Dirk P Kroese. 2011. <em>The Cross-Entropy Method: A Unified Approach to Combinatorial Optimization, <span>Monte</span>-<span>Carlo</span> Simulation and Machine Learning</em>. <span>New York; London</span>: <span>Springer</span>. <a href="https://doi.org/10.1007/978-1-4757-4321-0">https://doi.org/10.1007/978-1-4757-4321-0</a>.
</div>
<div id="ref-UribeEtAl_CrossentropybasedImportanceSampling_2020" class="csl-entry" role="doc-biblioentry">
Uribe, Felipe, Iason Papaioannou, Youssef M. Marzouk, and Daniel Straub. 2021. <span>“Cross-Entropy-Based Importance Sampling with Failure-Informed Dimension Reduction for Rare Event Simulation.”</span> <em>SIAM/ASA Journal on Uncertainty Quantification</em> 9 (2): 818–47. <a href="https://doi.org/10.1137/20M1344585">https://doi.org/10.1137/20M1344585</a>.
</div>
</div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div quarto-reuse="quarto-reuse" class="quarto-appendix-contents"><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
    var links = window.document.querySelectorAll('a:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
      }
    }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb9" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> Optimal projection for parametric importance sampling in high dimension</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Maxime El Masri</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliation: '[ONERA/DTIS](https://www.onera.fr/), [ISAE-SUPAERO](https://www.isae-supaero.fr/), [Université de Toulouse](https://www.univ-toulouse.fr/)'</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-9127-4503</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Jérôme Morio</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">    url: 'https://www.onera.fr/en/staff/jerome-morio?destination=node/981'</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliation: '[ONERA/DTIS](https://www.onera.fr/), [Université de Toulouse](https://www.univ-toulouse.fr/)'</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-8811-8956</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Florian Simatos</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="co">    url: 'https://pagespro.isae-supaero.fr/florian-simatos/'</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliation: '[ISAE-SUPAERO](https://www.isae-supaero.fr/), [Université de Toulouse](https://www.univ-toulouse.fr/)'</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> last-modified</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="an">description:</span><span class="co"> |</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co">  This document provides a dimension-reduction strategy in order to improve the performance of importance sampling in high dimension.</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> |</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="co">  In this paper we propose a dimension-reduction strategy in order to improve the performance of importance sampling in high dimension. The idea is to estimate variance terms in a small number of suitably chosen directions. We first prove that the optimal directions, i.e., the ones that minimize the Kullback--Leibler divergence with the optimal auxiliary density, are the eigenvectors associated to extreme (small or large) eigenvalues of the optimal covariance matrix. We then perform extensive numerical experiments that show that as dimension increases, these directions give estimations which are very close to optimal. Moreover, we show that the estimation remains accurate even when a simple empirical estimator of the covariance matrix is used to estimate these directions. These theoretical and numerical results open the way for different generalizations, in particular the incorporation of such ideas in adaptive importance sampling schemes.</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="an">keywords:</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="co">  - Importance sampling</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="co">  - High dimension</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="co">  - Gaussian covariance matrix</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="co">  - Kullback-Leibler divergence</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="co">  - Projection</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="an">github-user:</span><span class="co"> jmorio44</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a><span class="an">repo:</span><span class="co"> optimal-projection-IS</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> true</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a><span class="an">published:</span><span class="co"> false</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-html: default</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-pdf: default</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a><span class="an">execute:</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a><span class="co">  keep-ipynb: true</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a><span class="co">  jupytext:</span></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a><span class="co">    text_representation:</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a><span class="co">      extension: .qmd</span></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a><span class="co">      format_name: quarto</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a><span class="co">      format_version: '1.0'</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a><span class="co">      jupytext_version: 1.14.2</span></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a><span class="co">  kernelspec:</span></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a><span class="co">    display_name: Python 3 (ipykernel)</span></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a><span class="co">    language: python</span></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a><span class="co">    name: python3</span></span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy <span class="im">as</span> sp</span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats</span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> CEIS_vMFNM <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display, Math, Latex</span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Markdown</span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tabulate <span class="im">import</span> tabulate</span>
<span id="cb9-59"><a href="#cb9-59" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">10</span>)</span>
<span id="cb9-60"><a href="#cb9-60" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb9-61"><a href="#cb9-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-62"><a href="#cb9-62" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction  </span></span>
<span id="cb9-63"><a href="#cb9-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-64"><a href="#cb9-64" aria-hidden="true" tabindex="-1"></a>Importance Sampling (IS) is a widely considered stochastic method to estimate integrals of the form $E = \int \phi f$ with a black-box function $\phi$ and a probability density function (pdf) $f$. It rests upon the choice of an auxiliary density which, when suitably chosen, can significantly improve the situation compared to the naive Monte Carlo (MC) method <span class="co">[</span><span class="ot">@AgapiouEtAl_ImportanceSamplingIntrinsic_2017</span><span class="co">]</span>, <span class="co">[</span><span class="ot">@OwenZhou_SafeEffectiveImportance_2000</span><span class="co">]</span>. The theoretical optimal IS density, also called zero-variance density, is defined by $\phi f / E$ when $\phi$ is a positive function. This density is not available in practice as it involves the unknown integral $E$, but a classical strategy consists in searching an optimal approximation in a parametric family of densities. By minimising a ''distance'' with the optimal IS density, such as the Kullback--Leibler divergence, one can find optimal parameters in this family to get an efficient sampling pdf. Adaptive Importance Sampling (AIS) algorithms, such as the Mixture Population Monte Carlo method <span class="co">[</span><span class="ot">@CappeEtAl_AdaptiveImportanceSampling_2008</span><span class="co">]</span>, the Adaptive Multiple Importance Sampling method <span class="co">[</span><span class="ot">@CornuetEtAl_AdaptiveMultipleImportance_2012</span><span class="co">]</span>, or the Cross Entropy method <span class="co">[</span><span class="ot">@RubinsteinKroese_CrossentropyMethodUnified_2011</span><span class="co">]</span>, estimate the optimal parameters adaptively by updating intermediate parameters <span class="co">[</span><span class="ot">@BugalloEtAl_AdaptiveImportanceSampling_2017</span><span class="co">]</span>.</span>
<span id="cb9-65"><a href="#cb9-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-66"><a href="#cb9-66" aria-hidden="true" tabindex="-1"></a>An intense research activity has made these techniques work very well, but only for moderate dimensions. In high dimension, most of these techniques actually fail to give efficient parameters for two reasons. The first one is the so-called weight degeneracy problem, which is that in high dimension, the weights appearing in the IS densities (which are self-normalized likelihood ratios) degenerate. More precisely, the largest weight takes all the mass, while all other weights are negligible so that the final estimation essentially uses only one sample, see for instance <span class="co">[</span><span class="ot">@BengtssonEtAl_CurseofdimensionalityRevisitedCollapse_2008</span><span class="co">]</span> for a theoretical analysis in the related context of particle filtering. But even without likelihood ratios, such techniques may fail if they need to estimate high-dimensional parameters such as covariance matrices, whose size increases quadratically in the dimension <span class="co">[</span><span class="ot">@AshurbekovaEtAl_OptimalShrinkageRobust_</span><span class="co">]</span>, <span class="co">[</span><span class="ot">@LedoitWolf_WellconditionedEstimatorLargedimensional_2004</span><span class="co">]</span>. The conditions under which importance sampling is applicable in high dimension are notably investigated in a reliability context in <span class="co">[</span><span class="ot">@AuBeck_ImportantSamplingHigh_2003</span><span class="co">]</span>: it is remarked that the optimal covariance matrix should not deviate significantly from the identity matrix. <span class="co">[</span><span class="ot">@El-LahamEtAl_RecursiveShrinkageCovariance_</span><span class="co">]</span> tackle the weight degeneracy problem by applying a recursive shrinkage of the covariance matrix, which is constructed iteratively with a weighted sum of the sample covariance estimator and a biased, but more stable, estimator. Concerning the second problem of having to estimate high-dimensional parameters, the idea was recently put forth to reduce the effective dimension by only estimating these parameters (in particular the covariance matrix) in suitable directions <span class="co">[</span><span class="ot">@MasriEtAl_ImprovementCrossentropyMethod_2020</span><span class="co">]</span>, <span class="co">[</span><span class="ot">@UribeEtAl_CrossentropybasedImportanceSampling_2020</span><span class="co">]</span>. In this paper we seek to delve deeper into this idea. The main contribution of the present paper is to identify the optimal directions in the fundamental case when the parametric family is Gaussian, and perform numerical simulations in order to understand how they behave in practice. In particular, we propose directions which, in contrast to the recent paper <span class="co">[</span><span class="ot">@UribeEtAl_CrossentropybasedImportanceSampling_2020</span><span class="co">]</span>, does not require the objective function to be differentiable, and moreover optimizes the Kullback--Leibler distance with the optimal density instead of simply an upper bound on it, as in <span class="co">[</span><span class="ot">@UribeEtAl_CrossentropybasedImportanceSampling_2020</span><span class="co">]</span>. In @sec-proj we elaborate in more details on the differences between the two approaches.</span>
<span id="cb9-67"><a href="#cb9-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-68"><a href="#cb9-68" aria-hidden="true" tabindex="-1"></a>The paper is organised as follows: in @sec-IS we recall the foundations of IS. In @sec-main-result, we state our main theoretical result and we compare it with the current state-of-the-art. @sec-proof presents the proof of our theoretical result; @sec-num-results-framework introduces the numerical framework that we have adopted, and @sec-test-cases presents the numerical results obtained on five different test cases to assess the efficiency of the directions that we propose. We conclude in @sec-Ccl with a summary and research perspectives. </span>
<span id="cb9-69"><a href="#cb9-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-70"><a href="#cb9-70" aria-hidden="true" tabindex="-1"></a><span class="fu"># Importance Sampling {#sec-IS}</span></span>
<span id="cb9-71"><a href="#cb9-71" aria-hidden="true" tabindex="-1"></a>We consider the problem of estimating the following integral:</span>
<span id="cb9-72"><a href="#cb9-72" aria-hidden="true" tabindex="-1"></a>    $$</span>
<span id="cb9-73"><a href="#cb9-73" aria-hidden="true" tabindex="-1"></a>    E=\mathbb{E}_f(\phi(\mathbf{X}))=\int \phi(\mathbf{x})f(\mathbf{x})\textrm{d} \mathbf{x},</span>
<span id="cb9-74"><a href="#cb9-74" aria-hidden="true" tabindex="-1"></a>    $$</span>
<span id="cb9-75"><a href="#cb9-75" aria-hidden="true" tabindex="-1"></a>where $\mathbf{X}$ is a random vector in $\mathbb{R}^n$ with Gaussian standard pdf $f$, and $\phi: \mathbb{R}^n\rightarrow\mathbb{R}_+$ is a real-valued, non-negative function. If one were to relax this Gaussian standard assumption, one would need to look for covariance matrices in a different auxiliary set. The function $\phi$ is considered as a black-box function which is potentially expensive to evaluate, which means the number of calls to $\phi$ should be limited.</span>
<span id="cb9-76"><a href="#cb9-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-77"><a href="#cb9-77" aria-hidden="true" tabindex="-1"></a>IS is a widely considered approach to reduce the variance of the classical Monte Carlo estimator of $E$. The idea of IS is to generate a random sample $\mathbf{X}_1,\ldots,\mathbf{X}_N$ from an auxiliary density $g$, instead of $f$, and to compute the following estimator: </span>
<span id="cb9-78"><a href="#cb9-78" aria-hidden="true" tabindex="-1"></a>    $$</span>
<span id="cb9-79"><a href="#cb9-79" aria-hidden="true" tabindex="-1"></a>    \widehat{E}_N=\frac{1}{N}\sum_{i=1}^N \phi(\mathbf{X}_i)L(\mathbf{X}_i),</span>
<span id="cb9-80"><a href="#cb9-80" aria-hidden="true" tabindex="-1"></a>    $$ {#eq-hatE}</span>
<span id="cb9-81"><a href="#cb9-81" aria-hidden="true" tabindex="-1"></a>    with $L=f/g$ the likelihood ratio, or importance weight, and the density $g$, called importance sampling density, is such that $g(\mathbf{x})=0$ implies $\phi(\mathbf{x}) f(\mathbf{x})=0$ for every $\mathbf{x}$ (which makes the product $\phi L$ well-defined). This estimator is consistent and unbiased but its accuracy strongly depends on the choice of the auxiliary density $g$. It is well known that the optimal choice for $g$ is <span class="co">[</span><span class="ot">@bucklew2013introduction</span><span class="co">]</span></span>
<span id="cb9-82"><a href="#cb9-82" aria-hidden="true" tabindex="-1"></a>    $$</span>
<span id="cb9-83"><a href="#cb9-83" aria-hidden="true" tabindex="-1"></a>    g^*(\mathbf{x})=\dfrac{\phi(\mathbf{x})f(\mathbf{x})}{E}, \ \mathbf{x}\in\mathbb{R}^n.</span>
<span id="cb9-84"><a href="#cb9-84" aria-hidden="true" tabindex="-1"></a>    $$</span>
<span id="cb9-85"><a href="#cb9-85" aria-hidden="true" tabindex="-1"></a>Indeed, for this choice we have $\phi L = E$ and so $\widehat E_N$ is actually the deterministic estimator $E$. For this reason, $g^*$ is sometimes called zero-variance density, a terminology that we will adopt here. Of course, $g^*$ is only of theoretical interest as it depends on the unknown integral $E$. However, it gives an idea of good choices for the auxiliary density $g$, and we will seek to approximate $g^*$ by an auxiliary density that minimizes a distance between $g^*$ and a given parametric family of densities.</span>
<span id="cb9-86"><a href="#cb9-86" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-87"><a href="#cb9-87" aria-hidden="true" tabindex="-1"></a>In this paper, the parametric family of densities is the Gaussian family $<span class="sc">\{</span>g_{\mathbf{m}, \Sigma}: \mathbf{m} \in \mathbb{R}^n, \Sigma \in \mathcal{S}^+_n\}$, where $g_{\mathbf{m}, \Sigma}$ denotes the Gaussian density with mean $\mathbf{m} \in \mathbb{R}^n$ and covariance matrix $\Sigma \in \mathcal{S}^+_n$ with $\mathcal{S}^+_n \subset \mathbb{R}^{n \times n}$ the set of symmetric, positive-definite matrices:</span>
<span id="cb9-88"><a href="#cb9-88" aria-hidden="true" tabindex="-1"></a>    $$</span>
<span id="cb9-89"><a href="#cb9-89" aria-hidden="true" tabindex="-1"></a>    g_{\mathbf{m},\Sigma}(\mathbf{x})=\dfrac{1}{ (2\pi)^{n/2} \lvert \Sigma \rvert^{1/2}} \exp\left(-\frac{1}{2}(\mathbf{x}-\mathbf{m})^\top\Sigma^{-1}(\mathbf{x}-\mathbf{m})\right), \ \mathbf{x} \in \mathbb{R}^n.</span>
<span id="cb9-90"><a href="#cb9-90" aria-hidden="true" tabindex="-1"></a>    $$</span>
<span id="cb9-91"><a href="#cb9-91" aria-hidden="true" tabindex="-1"></a>with $\lvert \Sigma \rvert$ the determinant of $\Sigma$. Moreover, we will consider the Kullback--Leibler (KL) divergence to measure a ''distance'' between $g^*$ and  $g_{\mathbf{m}, \Sigma}$. Recall that for two densities $f$ and $h$, with $f$ absolutely continuous with respect to $h$, the KL divergence $D(f,h)$ between $f$ and $h$ is defined by: </span>
<span id="cb9-92"><a href="#cb9-92" aria-hidden="true" tabindex="-1"></a>    $$</span>
<span id="cb9-93"><a href="#cb9-93" aria-hidden="true" tabindex="-1"></a>    D(f,h)=\mathbb{E}_{f}\left<span class="co">[</span><span class="ot">\log \left( \frac{f(\mathbf{X})}{h(\mathbf{X})} \right) \right</span><span class="co">]</span> = \int \log \left( \frac{f(\mathbf{x})}{h(\mathbf{x})} \right)f(\mathbf{x}) \textrm{d} \mathbf{x}.</span>
<span id="cb9-94"><a href="#cb9-94" aria-hidden="true" tabindex="-1"></a>    $$</span>
<span id="cb9-95"><a href="#cb9-95" aria-hidden="true" tabindex="-1"></a>Thus, our goal is to approximate $g^*$ by $g_{\mathbf{m}^*, \Sigma^*}$ with the optimal mean vector $\mathbf{m}^*$ and the optimal covariance matrix $\Sigma^*$ given by:</span>
<span id="cb9-96"><a href="#cb9-96" aria-hidden="true" tabindex="-1"></a>    $$</span>
<span id="cb9-97"><a href="#cb9-97" aria-hidden="true" tabindex="-1"></a>    (\mathbf{m}^*,\Sigma^*) = \arg\min \left\{ D(g^*,g_{\mathbf{m},\Sigma}): \mathbf{m} \in \mathbb{R}^n, \Sigma \in \mathcal{S}_n^+ \right<span class="sc">\}</span>.</span>
<span id="cb9-98"><a href="#cb9-98" aria-hidden="true" tabindex="-1"></a>    $$ {#eq-argminDkl}</span>
<span id="cb9-99"><a href="#cb9-99" aria-hidden="true" tabindex="-1"></a>In the Gaussian case of the present setting, it is well-known that $\mathbf{m}^*$ and $\Sigma^*$ are simply the mean and variance of the zero-variance density <span class="co">[</span><span class="ot">@RubinsteinKroese_CrossentropyMethodUnified_2011</span><span class="co">]</span>, <span class="co">[</span><span class="ot">@RubinsteinKroese_SimulationMonteCarlo_2017</span><span class="co">]</span>:</span>
<span id="cb9-100"><a href="#cb9-100" aria-hidden="true" tabindex="-1"></a>    $$</span>
<span id="cb9-101"><a href="#cb9-101" aria-hidden="true" tabindex="-1"></a>    \mathbf{m}^*=\mathbb{E}_{g^*}(\mathbf{X}) \hspace{0.5cm} \text{ and } \hspace{0.5cm} \Sigma^* = \textrm{Var}_{g^*} \left(\mathbf{X}\right).</span>
<span id="cb9-102"><a href="#cb9-102" aria-hidden="true" tabindex="-1"></a>    $$ {#eq-mstar}</span>
<span id="cb9-103"><a href="#cb9-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-104"><a href="#cb9-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-105"><a href="#cb9-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-106"><a href="#cb9-106" aria-hidden="true" tabindex="-1"></a><span class="fu"># Main result and positioning of the paper {#sec-main-result} </span></span>
<span id="cb9-107"><a href="#cb9-107" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-108"><a href="#cb9-108" aria-hidden="true" tabindex="-1"></a><span class="fu">## Projecting on a low dimensional subspace {#sec-proj} </span></span>
<span id="cb9-109"><a href="#cb9-109" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-110"><a href="#cb9-110" aria-hidden="true" tabindex="-1"></a>As $g^*$ is unknown (although, as will be considered below, we can in principle sample from it since it is known up to a multiplicative constant), the optimal parameters $\mathbf{m}^*$ and $\Sigma^*$ given by @eq-mstar are not directly computable. Therefore, usual estimation schemes start with estimating $\mathbf{m}^*$ and $\Sigma^*$, say through $\widehat{\mathbf{m}}^*$ and $\widehat{\Sigma}^*$, respectively, and then use these approximations to estimate $E$ through @eq-hatE with the auxiliary density $g_{\widehat{\mathbf{m}}^*, \widehat{\Sigma}^*}$. Although the estimation of $E$ with the auxiliary density $g_{\mathbf{m}^*, \Sigma^*}$ usually provides very good results, it is well-known that in high dimension, the additional error induced by the estimations of $\mathbf{m}^*$ and $\Sigma^*$ severely degrades the accuracy of the final estimation [@PapaioannouEtAl_ImprovedCrossEntropybased_2019], [@UribeEtAl_CrossentropybasedImportanceSampling_2020]. The main problem lies in the estimation of $\Sigma^*$ which, in dimension $n$, involves the estimation of a quadratic (in the dimension) number of terms, namely $n(n+1)/2$.</span>
<span id="cb9-111"><a href="#cb9-111" aria-hidden="true" tabindex="-1"></a>Recently, the idea to overcome this problem by only evaluating variance terms in a small number of influential directions was explored in <span class="co">[</span><span class="ot">@MasriEtAl_ImprovementCrossentropyMethod_2020</span><span class="co">]</span> and <span class="co">[</span><span class="ot">@UribeEtAl_CrossentropybasedImportanceSampling_2020</span><span class="co">]</span>. In these two papers, the auxiliary covariance matrix $\Sigma$ is modeled in the form</span>
<span id="cb9-112"><a href="#cb9-112" aria-hidden="true" tabindex="-1"></a>    $$</span>
<span id="cb9-113"><a href="#cb9-113" aria-hidden="true" tabindex="-1"></a>    \Sigma = \sum_{i=1}^k (v_i-1) \mathbf{d}_i \mathbf{d}_i^\top + I_n</span>
<span id="cb9-114"><a href="#cb9-114" aria-hidden="true" tabindex="-1"></a>    $$ {#eq-Sigmak}</span>
<span id="cb9-115"><a href="#cb9-115" aria-hidden="true" tabindex="-1"></a>where the $\mathbf{d}_i$'s are the $k$ orthonormal directions which are deemed influential. It is easy to check that $\Sigma$ is the covariance matrix of the Gaussian vector</span>
<span id="cb9-116"><a href="#cb9-116" aria-hidden="true" tabindex="-1"></a>    $$ v^{1/2}_1 Y_1 \mathbf{d}_1 + \cdots + v^{1/2}_k Y_k \mathbf{d}_k + Y_{k+1} \mathbf{d}_{k+1} + \cdots + Y_n \mathbf{d}_n $$</span>
<span id="cb9-117"><a href="#cb9-117" aria-hidden="true" tabindex="-1"></a>where the $Y_i$'s are i.i.d. standard normal random variables (one-dimensional), and the $n-k$ vectors $(\mathbf{d}_{k+1}, \ldots, \mathbf{d}_n)$ complete $(\mathbf{d}_1, \ldots, \mathbf{d}_k)$ into an orthonormal basis. In particular, $v_i$ is the variance in the direction of $\mathbf{d}_i$, i.e., $v_i = \mathbf{d}_i^\top \Sigma \mathbf{d}_i$. In @eq-Sigmak, $k$ can be considered as the effective dimension in which variance terms are estimated. In other words, in [@MasriEtAl_ImprovementCrossentropyMethod_2020] and [@UribeEtAl_CrossentropybasedImportanceSampling_2020], the optimal variance parameter is not sought in $\mathcal{S}^+_n$ as in @eq-argminDkl}, but rather in the subset of matrices of the form</span>
<span id="cb9-118"><a href="#cb9-118" aria-hidden="true" tabindex="-1"></a>    $$ \mathcal{L}_{n,k} = \left\{ \sum_{i=1}^k (\alpha_i-1) \frac{\mathbf{d}_i \mathbf{d}_i^\top}{\lVert \mathbf{d}_i \rVert^2} + I_n: \alpha_1, \ldots, \alpha_k &gt;0 \ \text{ and the $\mathbf{d}_i$'s are orthogonal} \right<span class="sc">\}</span>. $$</span>
<span id="cb9-119"><a href="#cb9-119" aria-hidden="true" tabindex="-1"></a>The relevant minimization problem thus becomes</span>
<span id="cb9-120"><a href="#cb9-120" aria-hidden="true" tabindex="-1"></a>    $$ </span>
<span id="cb9-121"><a href="#cb9-121" aria-hidden="true" tabindex="-1"></a>    (\mathbf{m}^*_k, \Sigma^*_k) = \arg\min \left\{ D(g^*,g_{\mathbf{m},\Sigma}): \mathbf{m} \in \mathbb{R}^n, \ \Sigma \in \mathcal{L}_{n,k} \right<span class="sc">\}</span></span>
<span id="cb9-122"><a href="#cb9-122" aria-hidden="true" tabindex="-1"></a>    $$ {#eq-argminDkl-k}</span>
<span id="cb9-123"><a href="#cb9-123" aria-hidden="true" tabindex="-1"></a>instead of @eq-argminDkl, with the effective dimension $k$ being allowed to be adjusted dynamically. By restricting the space in which the variance is looked up, one seeks to limit the number of variance terms to be estimated. The idea is that if the directions are suitably chosen, then the improvement of the accuracy due to the smaller error in estimating the variance terms will compensate the fact that we consider less candidates for the covariance matrix.</span>
<span id="cb9-124"><a href="#cb9-124" aria-hidden="true" tabindex="-1"></a>In <span class="co">[</span><span class="ot">@MasriEtAl_ImprovementCrossentropyMethod_2020</span><span class="co">]</span>, the authors consider $k = 1$ and $\mathbf{d}_1 = \mathbf{m}^* / \lVert \mathbf{m}^* \rVert$. When $f$ is Gaussian, this choice is motivated by the fact that, due to the light tail of the Gaussian random variable and the reliability context, the variance should vary significantly in the direction of $\mathbf{m}^*$ and so estimating the variance in this direction can bring information. (In @sec-mm, we actually use the techniques of the present paper to provide a stronger theoretical justification of this choice, see @thm-thm2 and the discussion following it). The method in [@UribeEtAl_CrossentropybasedImportanceSampling_2020] is more involved: $k$ is adjusted dynamically, while the directions $\mathbf{d}_i$ are the eigenvectors associated to the largest eigenvalues of a certain matrix. They span a low-dimensional subspace called Failure-Informed Subspace, and the authors in [@UribeEtAl_CrossentropybasedImportanceSampling_2020] prove that this choice minimizes an upper bound on the minimal KL divergence. In practice, this algorithm yields very accurate results. However, we will not consider it further in the present paper for two reasons. First, this algorithm is tailored for the reliability case where $\phi = \mathbb{I}_{<span class="sc">\{</span>\varphi \geq 0<span class="sc">\}</span>}$, with a function $\varphi: \mathbb{R}^n \to \mathbb{R}$, whereas our method is more general and applies to the general problem of estimating an integral (see for instance our test case of @sec-sub:payoff). Second, the algorithm in <span class="co">[</span><span class="ot">@UribeEtAl_CrossentropybasedImportanceSampling_2020</span><span class="co">]</span> requires the evaluation of the gradient of the function $\varphi$. However, this gradient is not always known and can be expensive to evaluate in high dimension; in some cases, the function $\varphi$ is even not differentiable, as will be the case in our numerical example in @sec-sub:portfolio. </span>
<span id="cb9-125"><a href="#cb9-125" aria-hidden="true" tabindex="-1"></a>In contrast, our method makes no assumption on the form or smoothness of $\phi$: it does not need to assume that it is of the form $\mathbb{I}_{<span class="sc">\{</span>\varphi \geq 0<span class="sc">\}</span>}$, or to assume that $\nabla \varphi$ is tractable. For completeness, whenever  the algorithm of <span class="co">[</span><span class="ot">@UribeEtAl_CrossentropybasedImportanceSampling_2020</span><span class="co">]</span> was applicable and computing the gradient of $\varphi$ did not require any additional simulation budget, we have run it on the test cases considered here and found that it outperformed our algorithm. In more realistic settings, computing $\nabla \varphi$ would likely increase the simulation budget, and it would be interesting to compare the two algorithms in more details to understand when this extra computation cost is worthwhile. We reserve such a question for future research and will not consider the algorithm of <span class="co">[</span><span class="ot">@UribeEtAl_CrossentropybasedImportanceSampling_2020</span><span class="co">]</span> further, as our aim in this paper is to establish benchmark results for a general algorithm which works for any function $\phi$. </span>
<span id="cb9-126"><a href="#cb9-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-127"><a href="#cb9-127" aria-hidden="true" tabindex="-1"></a><span class="fu">## Main result of the paper {#sec-main-result-positioning} </span></span>
<span id="cb9-128"><a href="#cb9-128" aria-hidden="true" tabindex="-1"></a>The main result of the present paper is to actually compute the exact value for $\Sigma^*_k$ in @eq-argminDkl-k, which therefore paves the way for efficient high-dimensional estimation schemes. The statement of our result involves the following function $\ell$, which is represented in @fig-l:</span>
<span id="cb9-129"><a href="#cb9-129" aria-hidden="true" tabindex="-1"></a>    $$</span>
<span id="cb9-130"><a href="#cb9-130" aria-hidden="true" tabindex="-1"></a>    \ell: x \in (0,\infty) \mapsto -\log(x) + x - 1.</span>
<span id="cb9-131"><a href="#cb9-131" aria-hidden="true" tabindex="-1"></a>    $$ {#eq-l}</span>
<span id="cb9-132"><a href="#cb9-132" aria-hidden="true" tabindex="-1"></a>In the following, $(\lambda, \mathbf{d}) \in \mathbb{R} \times \mathbb{R}^n$ is an eigenpair of a matrix $A$ if $A\mathbf{d} = \lambda \mathbf{d}$ and $\lVert \mathbf{d} \rVert = 1$. A diagonalizable matrix has $n$ distinct eigenpairs, say $((\lambda^*_i, \mathbf{d}^*_i), i = 1, \ldots, n)$, and we say that these eigenpairs are ranked in decreasing $\ell$-order if $\ell(\lambda^*_1) \geq \cdots \geq \ell(\lambda^*_n)$.</span>
<span id="cb9-133"><a href="#cb9-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-136"><a href="#cb9-136" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb9-137"><a href="#cb9-137" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-l</span></span>
<span id="cb9-138"><a href="#cb9-138" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Plot of the function $\ell=-\log(x) + x - 1$ given by @eq-l</span></span>
<span id="cb9-139"><a href="#cb9-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-140"><a href="#cb9-140" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb9-141"><a href="#cb9-141" aria-hidden="true" tabindex="-1"></a><span class="co"># Figure 1. Plot of the function "l"</span></span>
<span id="cb9-142"><a href="#cb9-142" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb9-143"><a href="#cb9-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-144"><a href="#cb9-144" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(np.finfo(<span class="bu">float</span>).eps,<span class="fl">4.0</span>,<span class="dv">100</span>)</span>
<span id="cb9-145"><a href="#cb9-145" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="op">-</span>np.log(x) <span class="op">+</span> x <span class="op">-</span><span class="dv">1</span></span>
<span id="cb9-146"><a href="#cb9-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-147"><a href="#cb9-147" aria-hidden="true" tabindex="-1"></a><span class="co"># plot</span></span>
<span id="cb9-148"><a href="#cb9-148" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb9-149"><a href="#cb9-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-150"><a href="#cb9-150" aria-hidden="true" tabindex="-1"></a>ax.plot(x, y, linewidth<span class="op">=</span><span class="fl">2.0</span>)</span>
<span id="cb9-151"><a href="#cb9-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-152"><a href="#cb9-152" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(xlim<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">4</span>), xticks<span class="op">=</span>[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],</span>
<span id="cb9-153"><a href="#cb9-153" aria-hidden="true" tabindex="-1"></a>       ylim<span class="op">=</span>(<span class="dv">0</span>, <span class="fl">0.5</span>), yticks<span class="op">=</span>[<span class="dv">0</span>,<span class="fl">0.5</span>,<span class="dv">1</span>,<span class="fl">1.5</span>])</span>
<span id="cb9-154"><a href="#cb9-154" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb9-155"><a href="#cb9-155" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"$x$"</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb9-156"><a href="#cb9-156" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="vs">r"$\ell(x)$"</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb9-157"><a href="#cb9-157" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tickLabel <span class="kw">in</span> plt.gca().get_xticklabels() <span class="op">+</span> plt.gca().get_yticklabels():</span>
<span id="cb9-158"><a href="#cb9-158" aria-hidden="true" tabindex="-1"></a>    tickLabel.set_fontsize(<span class="dv">16</span>)</span>
<span id="cb9-159"><a href="#cb9-159" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb9-160"><a href="#cb9-160" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb9-161"><a href="#cb9-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-162"><a href="#cb9-162" aria-hidden="true" tabindex="-1"></a>::: {#thm-thm1}</span>
<span id="cb9-163"><a href="#cb9-163" aria-hidden="true" tabindex="-1"></a>Let $(\lambda^*_i, \mathbf{d}^*_i)$ be the eigenpairs of $\Sigma^*$ ranked in decreasing $\ell$-order. Then for $1 \leq k \leq n$, the solution $(\mathbf{m}^*_k, \Sigma^*_k)$ to @eq-argminDkl-k is given by</span>
<span id="cb9-164"><a href="#cb9-164" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-165"><a href="#cb9-165" aria-hidden="true" tabindex="-1"></a>\mathbf{m}^*_k = \mathbf{m}^* \ \text{ and } \ \Sigma^*_k = I_n + \sum_{i=1}^k \left( \lambda^*_i - 1 \right) \mathbf{d}^*_i (\mathbf{d}^*_i)^\top. </span>
<span id="cb9-166"><a href="#cb9-166" aria-hidden="true" tabindex="-1"></a>$$ {#eq-Sigma*k}</span>
<span id="cb9-167"><a href="#cb9-167" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb9-168"><a href="#cb9-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-169"><a href="#cb9-169" aria-hidden="true" tabindex="-1"></a>For $k = 1$ for instance, the shape of the function $\ell$ depicted in @fig-l implies that $\Sigma^*_1 = I_n + (\lambda^*-1) \mathbf{d}^* (\mathbf{d}^*)^\top$ with $(\lambda^*, \mathbf{d}^*)$ the eigenpair of $\Sigma^*$ with $\lambda^*$ either the largest or the smallest eigenvalue of $\Sigma^*$, depending on which one maximizes $\ell$.</span>
<span id="cb9-170"><a href="#cb9-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-171"><a href="#cb9-171" aria-hidden="true" tabindex="-1"></a>This theoretical result therefore suggests to reduce dimension by estimating eigenpairs of $\Sigma^*$, rank them in decreasing $\ell$-order and then use the $k$ first eigenpairs $(({\widehat{\lambda}}^*_i, {\widehat{\mathbf{d}}}^*_i), i = 1, \ldots, k)$ to build the covariance matrix $\widehat \Sigma^*_k = \sum_{i=1}^k ({\widehat{\lambda}}^*_i-1) {\widehat{\mathbf{d}}}^*_i ({{\widehat{\mathbf{d}}}^*}_i)^\top + I_n$ and the corresponding auxiliary density. This scheme is summarized in Algorithm 1. The effective dimension $k$ is obtained by Algorithm 2, see @sec-choicek below.</span>
<span id="cb9-172"><a href="#cb9-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-173"><a href="#cb9-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-174"><a href="#cb9-174" aria-hidden="true" tabindex="-1"></a><span class="in">```{.pseudocode}</span></span>
<span id="cb9-175"><a href="#cb9-175" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb9-176"><a href="#cb9-176" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Algorithm suggested by Theorem 1.}</span></span>
<span id="cb9-177"><a href="#cb9-177" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb9-178"><a href="#cb9-178" aria-hidden="true" tabindex="-1"></a><span class="in">\State \textbf{Data}: Sample sizes $N$ and $M$</span></span>
<span id="cb9-179"><a href="#cb9-179" aria-hidden="true" tabindex="-1"></a><span class="in">\State \textbf{Result}: Estimation $\widehat{E}_N$ of integral $E$</span></span>
<span id="cb9-180"><a href="#cb9-180" aria-hidden="true" tabindex="-1"></a><span class="in">\State Generate a sample $\mathbf{X}_1,\ldots,\mathbf{X}_M$  on $\mathbb{R}^n$ independently according to $g^*$</span></span>
<span id="cb9-181"><a href="#cb9-181" aria-hidden="true" tabindex="-1"></a><span class="in">\State  Estimate $\widehat{\mathbf{m}}^*$ and $\widehat{\Sigma}^*$ defined in Equation 10 and Equation 11 with this sample</span></span>
<span id="cb9-182"><a href="#cb9-182" aria-hidden="true" tabindex="-1"></a><span class="in">\State Compute the eigenpairs $(\widehat{\lambda}^*_i, \widehat{\mathbf{d}}^*_i)$ of $\widehat{\Sigma}^*$ ranked in decreasing $\ell$-order</span></span>
<span id="cb9-183"><a href="#cb9-183" aria-hidden="true" tabindex="-1"></a><span class="in">\State Compute the matrix $\widehat{\Sigma}^*_k = \sum_{i=1}^k ({\widehat{\lambda}}^*_i-1) {\widehat{\mathbf{d}}}^*_i ({{\widehat{\mathbf{d}}}^*}_i)^\top + I_n$ with $k$ obtained by applying Algorithm 2 with input $({\widehat{\lambda}}^*_1, \ldots, {\widehat{\lambda}}^*_n)$</span></span>
<span id="cb9-184"><a href="#cb9-184" aria-hidden="true" tabindex="-1"></a><span class="in">\State Generate a new sample $\mathbf{X}_1,\ldots,\mathbf{X}_N$ independently from $g' = g_{\widehat{\mathbf{m}}^*,\widehat{\Sigma}^*_k}$</span></span>
<span id="cb9-185"><a href="#cb9-185" aria-hidden="true" tabindex="-1"></a><span class="in">\State Return $\displaystyle \widehat{E}_N=\frac{1}{N}\underset{i=1}{\overset{N}{\sum}} \phi(\mathbf{X}_i)\frac{f(\mathbf{X}_i)}{g'(\mathbf{X}_i)}$</span></span>
<span id="cb9-186"><a href="#cb9-186" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb9-187"><a href="#cb9-187" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb9-188"><a href="#cb9-188" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb9-189"><a href="#cb9-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-190"><a href="#cb9-190" aria-hidden="true" tabindex="-1"></a>::: {.remark}</span>
<span id="cb9-191"><a href="#cb9-191" aria-hidden="true" tabindex="-1"></a> The value $1$ plays a particular role in @thm-thm1, in that, as $\ell$ is minimized in $1$, eigenvectors with eigenvalues $1$ will only be selected once all other eigenvalues will have been picked: in other words, if $\lambda^*_i = 1$ then $\lambda^*_j = 1$ for all $j \geq i$. The reason why $1$ plays this special role is due to the form of the covariance matrix that we impose. More precisely, looking for covariance matrices in the set $\mathcal{L}_{n,k}$ amounts to looking for covariance matrices which, once diagonalized, have one's on the diagonal except possibly for $k$ values (the $\alpha_i$'s). As $k$ will be small, typically $k = 1$ or $2$, this amounts to looking for covariance matrices which are perturbation of the identity. This is particularly relevant as we assume $f$ is a standard Gaussian density. What @thm-thm1 tells is that, when trying to approximate $\Sigma^*$ by such matrices, we should first consider eigenvectors with eigenvalues as different as possible from $1$, the ''distance'' to $1$ being measured by $\ell$. If one was imposing a different form on $\Sigma^*_k$ (which can be interesting if the distribution $f$ is not standardized), then a different result would arise. For instance, if one was looking for matrices where the ''default'' choice would be some $\lambda &gt; 0$ for the diagonal entries that are not estimated, i.e., a matrix of the form $\sum_i (\alpha_i-\lambda) \mathbf{d}_i \mathbf{d}_i^\top + \lambda I_n$, then eigenpairs would be ranked according to the function $\ell(\cdot/\lambda)$, meaning that one would look for eigenvectors associated to eigenvalues as different as possible from $\lambda$.</span>
<span id="cb9-192"><a href="#cb9-192" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb9-193"><a href="#cb9-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-194"><a href="#cb9-194" aria-hidden="true" tabindex="-1"></a>As mentioned above, we assume in the first step of Algorithm 1 that we can sample according to $g^*$. Since $g^*$ is known up to a multiplicative constant, this is a reasonable assumption as classical techniques such as importance sampling with self-normalized weights or Markov Chain Monte--Carlo (MCMC) can be applied in this case (see for instance [@ChanKroese_ImprovedCrossentropyMethod_2012], [@GraceEtAl_AutomatedStateDependentImportance_2014]). In this paper, we choose to apply a basic rejection method that yields perfect independent samples from $g^*$, possibly at the price of a high computational cost. As the primary goal of this paper is to understand whether the $\mathbf{d}^*_i$'s are indeed good projection directions, this computational cost to generate from $g^*$ is not relevant for us and therefore not taken into account. Possible improvements to relax this assumption are discussed in the conclusion of the paper.</span>
<span id="cb9-195"><a href="#cb9-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-196"><a href="#cb9-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-197"><a href="#cb9-197" aria-hidden="true" tabindex="-1"></a><span class="fu">## Choice of the number of dimensions $k$ {#sec-choicek} </span></span>
<span id="cb9-198"><a href="#cb9-198" aria-hidden="true" tabindex="-1"></a>The choice of the effective dimension $k$, i.e., the number of projection directions considered, is important. If it is close to $n$, then the matrix $\widehat{\Sigma}^*_k$ will be close to $\widehat{\Sigma}^*$ which is the situation we want to avoid in the first place. On the other hand, setting $k=1$ in all cases may be too simple and lead to suboptimal results. In practice however, this is often a good choice. In order to adapt $k$ dynamically, we consider a simple method based on the value of the KL divergence. Given the eigenvalues $\lambda_1, \ldots, \lambda_n$ ranked in decreasing $\ell$-order, we look for the maximal gap in the sequence $(\ell(\lambda_1), \ldots, \ell(\lambda_n))$. This allows to choose $k$ such that $\sum_{i=1}^k \ell(\lambda_i)$ is close to $\sum_{i=1}^n \ell(\lambda_i)$ which is equal, up to an additive constant, to the minimal KL divergence (see @eq-Dell below). The precise method is described in Algorithm 2. </span>
<span id="cb9-199"><a href="#cb9-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-200"><a href="#cb9-200" aria-hidden="true" tabindex="-1"></a><span class="in">```{.pseudocode}</span></span>
<span id="cb9-201"><a href="#cb9-201" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb9-202"><a href="#cb9-202" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Choice of the number of dimensions}</span></span>
<span id="cb9-203"><a href="#cb9-203" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb9-204"><a href="#cb9-204" aria-hidden="true" tabindex="-1"></a><span class="in">\State \textbf{Data}: Sequence of positive numbers $\lambda_1, \ldots, \lambda_n$ in decreasing $\ell$-order</span></span>
<span id="cb9-205"><a href="#cb9-205" aria-hidden="true" tabindex="-1"></a><span class="in">\State \textbf{Result}: Number of selected dimensions $k$</span></span>
<span id="cb9-206"><a href="#cb9-206" aria-hidden="true" tabindex="-1"></a><span class="in">\State Compute the increments $\delta_i = \ell(\lambda_{i+1}) - \ell(\lambda_i)$ for $i=1\ldots n-1$</span></span>
<span id="cb9-207"><a href="#cb9-207" aria-hidden="true" tabindex="-1"></a><span class="in">\State Return $k=\arg\max \delta_i$, the index of the maximum of the differences.</span></span>
<span id="cb9-208"><a href="#cb9-208" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb9-209"><a href="#cb9-209" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb9-210"><a href="#cb9-210" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb9-211"><a href="#cb9-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-212"><a href="#cb9-212" aria-hidden="true" tabindex="-1"></a><span class="fu">## Theoretical result concerning the projection on $\mathbf{m}^*$ {#sec-mm} </span></span>
<span id="cb9-213"><a href="#cb9-213" aria-hidden="true" tabindex="-1"></a>In <span class="co">[</span><span class="ot">@MasriEtAl_ImprovementCrossentropyMethod_2020</span><span class="co">]</span>, the authors propose to project on the mean $\mathbf{m}^*$ of the optimal auxiliary density $g^*$. Numerically, this algorithm is shown to perform well, but only a very heuristic explanation based on the light tail of the Gaussian distribution is provided to motivate this choice. It turns out that the techniques used in the proof of @thm-thm1 can shed light on why projecting on $\mathbf{m}^*$ may indeed be a good idea. Let us first state our theoretical result, and then explain why it justifies the idea of projecting on $\mathbf{m}^*$.</span>
<span id="cb9-214"><a href="#cb9-214" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-215"><a href="#cb9-215" aria-hidden="true" tabindex="-1"></a>::: {#thm-thm2}</span>
<span id="cb9-216"><a href="#cb9-216" aria-hidden="true" tabindex="-1"></a>Consider $\Sigma \in \mathcal{L}_{n,1}$ of the form $\Sigma = I_n + (\alpha - 1) \mathbf{d} \mathbf{d}^\top$ with $\alpha &gt; 0$ and $\lVert \mathbf{d} \rVert = 1$. Then the minimizer in $(\alpha, \mathbf{d})$ of the KL divergence between $f$ and $g_{\mathbf{m}^*, \Sigma}$ is $(1+\lVert m^*\rVert^2, \mathbf{m}^* / \lVert \mathbf{m}^* \rVert)$:</span>
<span id="cb9-217"><a href="#cb9-217" aria-hidden="true" tabindex="-1"></a>        $$\left( 1+\lVert \mathbf{m}^*\rVert^2, \mathbf{m}^* / \lVert \mathbf{m}^* \rVert \right) = \arg \min_{\alpha, \mathbf{d}} \left\{ D(f, g_{\mathbf{m}^*, I_n + (\alpha - 1) \mathbf{d} \mathbf{d}^\top}): \alpha &gt; 0, \ \lVert \mathbf{d} \rVert = 1 \right<span class="sc">\}</span>. $$</span>
<span id="cb9-218"><a href="#cb9-218" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb9-219"><a href="#cb9-219" aria-hidden="true" tabindex="-1"></a>In other words, $\mathbf{m}^*$ appears as an optimal projection direction when one seeks to minimize the KL divergence between $f$ and the Gaussian density with mean $\mathbf{m}^*$ and covariance of the form $I_n + (\alpha - 1) \mathbf{d} \mathbf{d}^\top$. Let us now explain why this minimization problem is indeed relevant, and why choosing an auxiliary density which minimizes this KL divergence may indeed lead to an accurate estimation. The justification deeply relies on the recent results by Chatterjee and Diaconis <span class="co">[</span><span class="ot">@Chatterjee18:0</span><span class="co">]</span>.</span>
<span id="cb9-220"><a href="#cb9-220" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-221"><a href="#cb9-221" aria-hidden="true" tabindex="-1"></a>As mentioned above, in a reliability context where one seeks to estimate a small probability $p = \mathbb{P}(\mathbf{X} \in A),$ Theorem $1.3$ in <span class="co">[</span><span class="ot">@Chatterjee18:0</span><span class="co">]</span> shows that $D(g^*, g)$ governs the sample size required for an accurate estimation of $p$: more precisely, the estimation is accurate if the sample size is larger than $e^{D(g^*, g)}$, and inaccurate otherwise. This motivates the rationale for minimizing the KL divergence with $g^*$.</span>
<span id="cb9-222"><a href="#cb9-222" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-223"><a href="#cb9-223" aria-hidden="true" tabindex="-1"></a>However, in high dimension, importance sampling is known to fail because of the weight degeneracy problem whereby $\max_i L_i / \sum_i L_i \approx 1$, with the $L_i$'s the unnormalized importance weights, or likelihood ratios: $L_i = f(\mathbf{X}_i) / g(\mathbf{X}_i)$ with the $\mathbf{X}_i$'s i.i.d. drawn according to $g$. Theorem $2.3$ in <span class="co">[</span><span class="ot">@Chatterjee18:0</span><span class="co">]</span> shows that the weight degeneracy problem is avoided if the empirical mean of the likelihood ratios is close to $1$, and for this, Theorem $1.1$ in <span class="co">[</span><span class="ot">@Chatterjee18:0</span><span class="co">]</span> shows that the sample size should be larger than $e^{D(f, g)}$. In other words, these results suggest that the KL divergence with $g^*$ governs the sample size for an accurate estimation of $p$, while the KL divergence with $f$ governs the weight degeneracy problem.</span>
<span id="cb9-224"><a href="#cb9-224" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-225"><a href="#cb9-225" aria-hidden="true" tabindex="-1"></a>In light of these results, it becomes natural to consider the KL divergence with $f$ and not only $g^*$. Of course, minimizing $D(f, g_{\mathbf{m}, \Sigma})$ without constraints on $\mathbf{m}$ and $\Sigma$ is trivial since $g_{\mathbf{m}, \Sigma} = f$ for $\mathbf{m} = 0$ and $\Sigma = I_n$. However, these choices are the ones we want to avoid in the first place, and so it makes sense to impose some constraints on $\mathbf{m}$ and $\Sigma$. If one keeps in mind the other objective of getting close to $g^*$, then the choice $\mathbf{m} = \mathbf{m}^*$ becomes very natural, and we are led, when $\Sigma \in \mathcal{L}_{n,1}$ is sought as a rank-$1$ perturbation of the identity, to considering the optimization problem of @thm-thm2.</span>
<span id="cb9-226"><a href="#cb9-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-227"><a href="#cb9-227" aria-hidden="true" tabindex="-1"></a><span class="fu"># Proof of Theorems @thm-thm1 and @thm-thm2 {#sec-proof} </span></span>
<span id="cb9-228"><a href="#cb9-228" aria-hidden="true" tabindex="-1"></a>We begin with a preliminary lemma.</span>
<span id="cb9-229"><a href="#cb9-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-230"><a href="#cb9-230" aria-hidden="true" tabindex="-1"></a>::: {#lem-D}</span>
<span id="cb9-231"><a href="#cb9-231" aria-hidden="true" tabindex="-1"></a>Let $f$ be the density of the standard Gaussian vector in dimension $n$, $\phi: \mathbb{R}^n \to \mathbb{R}_+$ and $g_* = f \phi / E$ with $E = \int f \phi$. Then for any $\mathbf{m}$ and any $\Sigma$ of the form $\Sigma = I_n + \sum_i (\alpha_i - 1) \mathbf{d}_i \mathbf{d}_i^\top$ with $\alpha_i &gt; 0$ and the $\mathbf{d}_i$'s orthonormal, we have</span>
<span id="cb9-232"><a href="#cb9-232" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-233"><a href="#cb9-233" aria-hidden="true" tabindex="-1"></a> D(g^*, g_{\mathbf{m}, \Sigma}) =  \frac{1}{2} \sum_i \left( \log \alpha_i - \left(1 - \frac{1}{\alpha_i} \right) \mathbf{d}_i^\top \Sigma^* \mathbf{d}_i \right) + \frac{1}{2} (\mathbf{m} - \mathbf{m}^*)^\top \Sigma^{-1} (\mathbf{m} - \mathbf{m}^*)<span class="sc">\\</span></span>
<span id="cb9-234"><a href="#cb9-234" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>\frac{1}{2} \lVert \mathbf{m}^* \rVert^2 - \log E + \mathbb{E}_{g^*}(\log \phi(\mathbf{X})).</span>
<span id="cb9-235"><a href="#cb9-235" aria-hidden="true" tabindex="-1"></a>$$ {#eq-D}</span>
<span id="cb9-236"><a href="#cb9-236" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb9-237"><a href="#cb9-237" aria-hidden="true" tabindex="-1"></a>::: {.proof}</span>
<span id="cb9-238"><a href="#cb9-238" aria-hidden="true" tabindex="-1"></a><span class="fu">## of @lem-D</span></span>
<span id="cb9-239"><a href="#cb9-239" aria-hidden="true" tabindex="-1"></a>For any $\mathbf{m} \in \mathbb{R}^n$ and $\Sigma \in \mathcal{S}^+_n$, we have by definition</span>
<span id="cb9-240"><a href="#cb9-240" aria-hidden="true" tabindex="-1"></a>$$ D(g^*, g_{\mathbf{m}, \Sigma}) = \mathbb{E}_{g^*} \left( \log \left( \frac{g^*(\mathbf{X})}{g_{\mathbf{m}, \Sigma}(\mathbf{X})} \right) \right) = \mathbb{E}_{g^*} \left( \log \left( \frac{\frac{\phi(\mathbf{X}) e^{-\frac{1}{2} \lVert \mathbf{X} \rVert^2}}{E(2\pi)^{d/2}}}{ \frac{e^{-\frac{1}{2} (\mathbf{X} - \mathbf{m})^\top \Sigma^{-1} (\mathbf{X} - \mathbf{m})}}{(2\pi)^{d/2} \lvert \Sigma \rvert^{1/2}} } \right) \right) $$</span>
<span id="cb9-241"><a href="#cb9-241" aria-hidden="true" tabindex="-1"></a>and so</span>
<span id="cb9-242"><a href="#cb9-242" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-243"><a href="#cb9-243" aria-hidden="true" tabindex="-1"></a>D(g^*, g_{\mathbf{m}, \Sigma}) = - \frac{1}{2} \mathbb{E}_{g^*}(\lVert \mathbf{X} \rVert^2) + \frac{1}{2} \mathbb{E}_{g^*} \left( (\mathbf{X} - \mathbf{m})^\top \Sigma^{-1} (\mathbf{X} - \mathbf{m}) \right) + \frac{1}{2} \log \lvert \Sigma \rvert<span class="sc">\\</span></span>
<span id="cb9-244"><a href="#cb9-244" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>\log E + \mathbb{E}_{g^*}(\log \phi(\mathbf{X})).</span>
<span id="cb9-245"><a href="#cb9-245" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-246"><a href="#cb9-246" aria-hidden="true" tabindex="-1"></a>Because $\mathbb{E}_{g^*}(\mathbf{X}) = \mathbf{m}^*$, we have $\mathbb{E}_{g^*}(\lVert \mathbf{X} \rVert^2) = \mathbb{E}_{g^*}(\lVert \mathbf{X} - \mathbf{m}^* \rVert^2) + \lVert \mathbf{m}^* \rVert^2$ and</span>
<span id="cb9-247"><a href="#cb9-247" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-248"><a href="#cb9-248" aria-hidden="true" tabindex="-1"></a>\mathbb{E}_{g^*} \left( (\mathbf{X} - \mathbf{m})^\top \Sigma^{-1} (\mathbf{X} - \mathbf{m}) \right) = \mathbb{E}_{g^*} \left( (\mathbf{X} - \mathbf{m}^*)^\top \Sigma^{-1} (\mathbf{X} - \mathbf{m}^*) \right)<span class="sc">\\</span></span>
<span id="cb9-249"><a href="#cb9-249" aria-hidden="true" tabindex="-1"></a><span class="ss">+ </span>(\mathbf{m} - \mathbf{m}^*)^\top \Sigma^{-1} (\mathbf{m} - \mathbf{m}^*).</span>
<span id="cb9-250"><a href="#cb9-250" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-251"><a href="#cb9-251" aria-hidden="true" tabindex="-1"></a>In the following derivations, we use the linearity of the trace and of the expectation, which make these two operators commute, as well as the identity $a^\top b = \textrm{tr}(a b^\top)$ for any two vectors $a$ and $b$. With this caveat, we obtain</span>
<span id="cb9-252"><a href="#cb9-252" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-253"><a href="#cb9-253" aria-hidden="true" tabindex="-1"></a>\mathbb{E}_{g^*}\left[ \lVert \mathbf{X} - \mathbf{m}^* \rVert^2 \right] = \mathbb{E}_{g^*} \left[ \textrm{tr}((\mathbf{X} - \mathbf{m}^*) (\mathbf{X} - \mathbf{m}^*)^\top) \right] = \textrm{tr} (\Sigma^*) </span>
<span id="cb9-254"><a href="#cb9-254" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-255"><a href="#cb9-255" aria-hidden="true" tabindex="-1"></a>and we obtain with similar arguments $\mathbb{E}_{g^*}( (\mathbf{X} - \mathbf{m}^*)^\top \Sigma^{-1} (\mathbf{X} - \mathbf{m}^*) ) = \textrm{tr} ( \Sigma^{-1} \Sigma^*)$. Consider now $\Sigma = I_n + \sum_i (\alpha_i - 1) \mathbf{d}_i \mathbf{d}_i^\top$ with $\alpha_i &gt; 0$ and the $\mathbf{d}_i$'s orthonormal. Then the eigenvalues of $\Sigma$ potentially different from $1$ are the $\alpha_i$'s ($\alpha_i$ is the eigenvalue associated with $\mathbf{d}_i$), so that</span>
<span id="cb9-256"><a href="#cb9-256" aria-hidden="true" tabindex="-1"></a>$$\log \lvert \Sigma \rvert = \sum_i \log \alpha_i. </span>
<span id="cb9-257"><a href="#cb9-257" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-258"><a href="#cb9-258" aria-hidden="true" tabindex="-1"></a>Moreover, we have $\Sigma^{-1} = I_n - \sum_i \beta_i \mathbf{d}_i \mathbf{d}_i^\top$ with $\beta_i = 1 - 1/\alpha_i$ and so</span>
<span id="cb9-259"><a href="#cb9-259" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-260"><a href="#cb9-260" aria-hidden="true" tabindex="-1"></a>\textrm{tr}(\Sigma^{-1} \Sigma^*) = \textrm{tr}(\Sigma^*) - \sum_i \beta_i \mathbf{d}_i^\top \Sigma^* \mathbf{d}_i. </span>
<span id="cb9-261"><a href="#cb9-261" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-262"><a href="#cb9-262" aria-hidden="true" tabindex="-1"></a>Gathering the previous relation, we finally obtain the desired result.</span>
<span id="cb9-263"><a href="#cb9-263" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb9-264"><a href="#cb9-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-265"><a href="#cb9-265" aria-hidden="true" tabindex="-1"></a>::: {.proof}</span>
<span id="cb9-266"><a href="#cb9-266" aria-hidden="true" tabindex="-1"></a><span class="fu">## of @thm-thm1</span></span>
<span id="cb9-267"><a href="#cb9-267" aria-hidden="true" tabindex="-1"></a>From @eq-D we see that the only dependency of $D(g^*, g_{\mathbf{m}, \Sigma})$ in $\mathbf{m}$ is in the quadratic term $(\mathbf{m} - \mathbf{m}^*)^\top \Sigma^{-1} (\mathbf{m} - \mathbf{m}^*)$. As $\Sigma$ is definite positive, this term is $\geq 0$, and so it is minimized for $\mathbf{m} = \mathbf{m}^*$. Next, we see that the derivative in $\alpha_i$ is given by (here and in the sequel, we see $D(g^*, g_{\mathbf{m}, \Sigma})$ as a function of $\mathbf{v} = (\alpha_i)_i$ and $\mathbf{d} = (\mathbf{d}_i)_i$)</span>
<span id="cb9-268"><a href="#cb9-268" aria-hidden="true" tabindex="-1"></a>    $$ \dfrac{\partial D}{\partial \alpha_i}(\mathbf{v}, \mathbf{d}) = \dfrac{1}{\alpha_i} - \frac{1}{\alpha_i^2} \mathbf{d}_i^\top \Sigma^* \mathbf{d}_i = \frac{1}{\alpha_i^2} \left( \alpha_i - \mathbf{d}_i^\top \Sigma^* \mathbf{d}_i \right). $$</span>
<span id="cb9-269"><a href="#cb9-269" aria-hidden="true" tabindex="-1"></a>Thus, for fixed $\mathbf{d}$, $D$ is decreasing in $\alpha_i$ for $\alpha_i &lt; \mathbf{d}_i^\top \Sigma^* \mathbf{d}_i$ and then increasing for $\alpha_i &gt; \mathbf{d}_i^\top \Sigma^* \mathbf{d}_i$, which shows that, for fixed $\mathbf{d}$, it is minimized for $\alpha_i = \mathbf{d}_i^\top \Sigma^* \mathbf{d}_i$. For this value (and $\mathbf{m} = \mathbf{m}^*$) we have</span>
<span id="cb9-270"><a href="#cb9-270" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb9-271"><a href="#cb9-271" aria-hidden="true" tabindex="-1"></a>D(g^*, g_{\mathbf{m}^*, \Sigma}) = \sum_{i=1}^k \left[ \log(\mathbf{d}_i^\top \Sigma^* \mathbf{d}_i) + 1 - \mathbf{d}_i^\top \Sigma^* \mathbf{d}_i \right] + C = -\sum_{i=1}^k \ell(\mathbf{d}_i^\top \Sigma^* \mathbf{d}_i) + C</span>
<span id="cb9-272"><a href="#cb9-272" aria-hidden="true" tabindex="-1"></a>$$ {#eq-Dell}</span>
<span id="cb9-273"><a href="#cb9-273" aria-hidden="true" tabindex="-1"></a>with $C = - \frac{1}{2} \lVert \mathbf{m}^* \rVert^2 - \log E + \mathbb{E}_{g^*}(\log \phi(\mathbf{X}))$ independent from the $\mathbf{d}_i$'s. Since $\ell$ is decreasing and then increasing, it is clear from this expression that in order to minimize $D$, one must choose the $\mathbf{d}_i$'s in order to either maximize or minimize $\mathbf{d}_i^\top \Sigma^* \mathbf{d}_i$, whichever maximizes $\ell$. Since the variational characterization of eigenvalues shows that eigenvectors precisely solve this problem, we get the desired result.</span>
<span id="cb9-274"><a href="#cb9-274" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb9-275"><a href="#cb9-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-276"><a href="#cb9-276" aria-hidden="true" tabindex="-1"></a>::: {.proof}</span>
<span id="cb9-277"><a href="#cb9-277" aria-hidden="true" tabindex="-1"></a><span class="fu">## of @thm-thm2</span></span>
<span id="cb9-278"><a href="#cb9-278" aria-hidden="true" tabindex="-1"></a>In @eq-D, the $\mathbf{m}^*$ and the $\Sigma^*$ that appear in the right-hand side are the mean and variance of the density $g^*$ considered in the first argument of the Kullback--Leibler divergence. In particular, if we apply @eq-D with $\phi \equiv 1$, we have $g^* = f$, and the $\mathbf{m}^*$ and $\Sigma^*$ of the right-hand side become $0$ and $I_n$, respectively, so that</span>
<span id="cb9-279"><a href="#cb9-279" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb9-280"><a href="#cb9-280" aria-hidden="true" tabindex="-1"></a> D(f, g_{\mathbf{m}, \Sigma}) =  \frac{1}{2} \sum_i \left( \log \alpha_i - \left(1 - \frac{1}{\alpha_i} \right) \right) + \frac{1}{2} \mathbf{m}^\top \Sigma^{-1} \mathbf{m}. </span>
<span id="cb9-281"><a href="#cb9-281" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-282"><a href="#cb9-282" aria-hidden="true" tabindex="-1"></a>Now, if we consider $\mathbf{m} = \mathbf{m}^*$ and $\Sigma = I + (\alpha - 1) \mathbf{d} \mathbf{d}^\top$, we obtain (using $\Sigma^{-1} = I - (1-1/\alpha) \mathbf{d} \mathbf{d}^\top$ as mentioned in the proof of @lem-D)</span>
<span id="cb9-283"><a href="#cb9-283" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-284"><a href="#cb9-284" aria-hidden="true" tabindex="-1"></a>D(f, g_{\mathbf{m}^*, \Sigma}) =  \frac{1}{2} \left( \log \alpha - \left(1 - \frac{1}{\alpha} \right) \left( 1 + (\mathbf{d}^\top \mathbf{m}^*)^2 \right) \right) + \frac{1}{2} \lVert \mathbf{m}^* \rVert^2.</span>
<span id="cb9-285"><a href="#cb9-285" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-286"><a href="#cb9-286" aria-hidden="true" tabindex="-1"></a>We have seen in the proof of @thm-thm1 that the function $x \mapsto \log x + (1/x-1)\gamma$ is minimized for $x = \gamma$ where it takes the value $-\ell(\gamma)$: $D(f, g_{\mathbf{m}^*, \Sigma})$ is therefore minimized for $\alpha = 1 + (\mathbf{d}^\top \mathbf{m}^*)^2$ and for this value, we have</span>
<span id="cb9-287"><a href="#cb9-287" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-288"><a href="#cb9-288" aria-hidden="true" tabindex="-1"></a>D(f, g_{\mathbf{m}^*, \Sigma}) =  - \frac{1}{2} \ell(1 + (\mathbf{d}^\top \mathbf{m}^*)^2) + \frac{1}{2} \lVert \mathbf{m}^* \rVert^2. </span>
<span id="cb9-289"><a href="#cb9-289" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-290"><a href="#cb9-290" aria-hidden="true" tabindex="-1"></a>As $\ell$ is increasing in $[1, \infty)$, this last quantity is minimized by maximizing $(\mathbf{d}^\top \mathbf{m}^*)^2$, which is obtained for $\mathbf{d} = \mathbf{m}^* / \lVert \mathbf{m}^* \rVert$. The result is proved.</span>
<span id="cb9-291"><a href="#cb9-291" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb9-292"><a href="#cb9-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-293"><a href="#cb9-293" aria-hidden="true" tabindex="-1"></a><span class="fu"># Framework for the numerical results {#sec-num-results-framework} </span></span>
<span id="cb9-294"><a href="#cb9-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-295"><a href="#cb9-295" aria-hidden="true" tabindex="-1"></a><span class="fu">## General framework</span></span>
<span id="cb9-296"><a href="#cb9-296" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-297"><a href="#cb9-297" aria-hidden="true" tabindex="-1"></a>The objective of the numerical simulations is to evaluate the impact of the choice of the covariance matrix on the estimation accuracy of a high dimensional integral $E$. We compare in this section the estimation results for different choices of the auxiliary covariance matrix when the IS auxiliary density is Gaussian. To extend this comparison, we also compute the results when the IS auxiliary density is chosen with the von Mises–Fisher– Nakagami (vMFN) model recently proposed in <span class="co">[</span><span class="ot">@PapaioannouEtAl_ImprovedCrossEntropybased_2019</span><span class="co">]</span> for high dimensional probability estimation.</span>
<span id="cb9-298"><a href="#cb9-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-299"><a href="#cb9-299" aria-hidden="true" tabindex="-1"></a>In the following section we test these different models of auxiliary densities on five test cases, where $f$ is a standard Gaussian density. This choice is not a theoretical limitation as we can in principle always come back to this case by transforming the vector $\mathbf{X}$ with isoprobabilistic transformations (see for instance <span class="co">[</span><span class="ot">@HohenbichlerRackwitz_NonNormalDependentVectors_1981</span><span class="co">]</span>, <span class="co">[</span><span class="ot">@LiuDerKiureghian_MultivariateDistributionModels_1986</span><span class="co">]</span>).</span>
<span id="cb9-300"><a href="#cb9-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-301"><a href="#cb9-301" aria-hidden="true" tabindex="-1"></a>The precise numerical framework that we will consider to assess the efficiency of the different auxiliary models is as follows. We assume first that $M$ i.i.d.\ random samples $\mathbf{X}_1,\ldots,\mathbf{X}_M$ distributed from $g^*$ are available from rejection sampling. From these samples, the parameters of the Gaussian and of the vMFN auxiliary density are computed to get an auxiliary density $g'$. Finally, $N$ samples are generated from $g'$ to provide an estimation of $E$ with IS. This procedure is summarized by the following stages: </span>
<span id="cb9-302"><a href="#cb9-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-303"><a href="#cb9-303" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Generate a sample $\mathbf{X}_1,\ldots,\mathbf{X}_M$ independently according to $g^*$;</span>
<span id="cb9-304"><a href="#cb9-304" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>From $\mathbf{X}_1,\ldots,\mathbf{X}_M$, compute the parameters of the auxiliary parametric density $g'$;</span>
<span id="cb9-305"><a href="#cb9-305" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Generate a new sample $\mathbf{X}_1,\ldots,\mathbf{X}_N$ independently from $g'$;</span>
<span id="cb9-306"><a href="#cb9-306" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Estimate $E$ with $\widehat{E}_N=\frac{1}{N}\underset{i=1}{\overset{N}{\sum}} \phi(\mathbf{X}_i)\frac{f(\mathbf{X}_i)}{g'(\mathbf{X}_i)}$.</span>
<span id="cb9-307"><a href="#cb9-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-308"><a href="#cb9-308" aria-hidden="true" tabindex="-1"></a>The number of samples $M$ and $N$ are respectively set to $M=500$ and $N=2000$. This procedure is then repeated $50$ times to provide a mean estimation $\widehat{E}$ of $E$. In the result tables, for each auxiliary density $g'$ we report the corresponding value for the relative error $\widehat{E}/ E-1$ and the coefficient of variation of the $50$ iterations (the empirical standard deviation divided by $E$). As was established in the proof of @thm-thm1, the KL divergence is, up to an additive constant, equal to $D'(\Sigma) = \log \lvert \Sigma \rvert + \textrm{tr}(\Sigma^* \Sigma^{-1})$ which we will refer to as partial KL divergence. In the result tables, we also report thus the mean value of $D'(\Sigma)$ to analyse the relevancy of the auxiliary density $g_{\widehat{\mathbf{m}}^*, \Sigma}$ for these six choices of covariance matrix $\Sigma$. The next sections specify the different parameters of $g'$ for the Gaussian model and for the vMFN model we have considered in the simulations. </span>
<span id="cb9-309"><a href="#cb9-309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-310"><a href="#cb9-310" aria-hidden="true" tabindex="-1"></a><span class="fu">## Choice of the auxiliary density $g'$ for the Gaussian model  {#sec-def_cov} </span></span>
<span id="cb9-311"><a href="#cb9-311" aria-hidden="true" tabindex="-1"></a>The goal is to get benchmark results to assess whether one can improve estimations of Gaussian IS auxiliary density by projecting the covariance matrix $\Sigma^*$ in the proposed directions $\mathbf{d}^*_i$. The algorithm that we study here (Algorithms 1+2) aims more precisely at understanding whether:</span>
<span id="cb9-312"><a href="#cb9-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-313"><a href="#cb9-313" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>projecting can improve the situation with respect to the empirical covariance matrix;</span>
<span id="cb9-314"><a href="#cb9-314" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>the $\mathbf{d}^*_i$'s are good candidates, in particular compared to the choice $\mathbf{m}^*$ suggested in <span class="co">[</span><span class="ot">@MasriEtAl_ImprovementCrossentropyMethod_2020</span><span class="co">]</span>;</span>
<span id="cb9-315"><a href="#cb9-315" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>what is the impact in making errors in estimating the eigenpairs $(\lambda^*_i, \mathbf{d}^*_i)$.</span>
<span id="cb9-316"><a href="#cb9-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-317"><a href="#cb9-317" aria-hidden="true" tabindex="-1"></a>Let us define the estimate  $\widehat{\mathbf{m}}^*$ of $\mathbf{m}^*$  from the $M$ i.i.d. random samples $\mathbf{X}_1,\ldots,\mathbf{X}_M$ distributed from $g^*$ with</span>
<span id="cb9-318"><a href="#cb9-318" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-319"><a href="#cb9-319" aria-hidden="true" tabindex="-1"></a>    \widehat{\mathbf{m}}^* = \frac{1}{M}\sum_{i=1}^M \mathbf{X}_i.</span>
<span id="cb9-320"><a href="#cb9-320" aria-hidden="true" tabindex="-1"></a>$$ {#eq-hatm}</span>
<span id="cb9-321"><a href="#cb9-321" aria-hidden="true" tabindex="-1"></a>In our numerical test cases, we will compare six different choices of Gaussian auxiliary distributions $g'$ with mean $\widehat{\mathbf{m}}^*$ and the following covariance matrices (see @tbl-sigma):</span>
<span id="cb9-322"><a href="#cb9-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-323"><a href="#cb9-323" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>$\Sigma^*$: the optimal covariance matrix given by @eq-mstar;</span>
<span id="cb9-324"><a href="#cb9-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-325"><a href="#cb9-325" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>$\widehat{\Sigma}^*$: the empirical estimation of $\Sigma^*$ given by</span>
<span id="cb9-326"><a href="#cb9-326" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-327"><a href="#cb9-327" aria-hidden="true" tabindex="-1"></a>    \widehat{\Sigma}^* = \frac{1}{M}\sum_{i=1}^M (\mathbf{X}_i-\widehat{\mathbf{m}}^*)(\mathbf{X}_i-\widehat{\mathbf{m}}^*)^\top.</span>
<span id="cb9-328"><a href="#cb9-328" aria-hidden="true" tabindex="-1"></a>$$ {#eq-hatSigma}</span>
<span id="cb9-329"><a href="#cb9-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-330"><a href="#cb9-330" aria-hidden="true" tabindex="-1"></a>The four other covariance matrices considered in the numerical simulations are of the form </span>
<span id="cb9-331"><a href="#cb9-331" aria-hidden="true" tabindex="-1"></a>     $\sum_{i=1}^k (v_i-1) \mathbf{d}_i \mathbf{d}^\top_i + I_n$ where $v_i$ is the variance of $\widehat{\Sigma}^*$ in the direction $\mathbf{d}_i$, $v_i = \mathbf{d}_i^\top \widehat{\Sigma}^* \mathbf{d}_i$. The considered choice of $k$ and $\mathbf{d}_i$ gives the following covariance matrices:   </span>
<span id="cb9-332"><a href="#cb9-332" aria-hidden="true" tabindex="-1"></a>     </span>
<span id="cb9-333"><a href="#cb9-333" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>${\widehat{\Sigma}^{\text{}}_\text{opt}}$ is obtained by choosing $\mathbf{d}_i = \mathbf{d}^*_i$ of @thm-thm1, which is supposed to be perfectly known from $\Sigma^*$ and $k$ is computed with Algorithm 2;</span>
<span id="cb9-334"><a href="#cb9-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-335"><a href="#cb9-335" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>${\widehat{\Sigma}^{\text{+d}}_\text{opt}}$ is obtained by choosing $\mathbf{d}_i = {\widehat{\mathbf{d}}}^*_i$ the $i$-th eigenvector of $\widehat{\Sigma}^*$ (in $\ell$-order), which is an estimation of $\mathbf{d}^*_i$, and $k$ is computed with Algorithm 2;</span>
<span id="cb9-336"><a href="#cb9-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-337"><a href="#cb9-337" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>${\widehat{\Sigma}^{\text{}}_\text{mean}}$ is obtained by choosing $k = 1$ and $\mathbf{d}_1 = \mathbf{m}^* / \lVert \mathbf{m}^* \rVert$;   </span>
<span id="cb9-338"><a href="#cb9-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-339"><a href="#cb9-339" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>${\widehat{\Sigma}^{\text{+d}}_\text{mean}}$ is obtained by choosing $k = 1$ and $\mathbf{d}_1 = {\widehat{\mathbf{m}}}^* / \lVert {\widehat{\mathbf{m}}}^* \rVert$, where $\widehat{\mathbf{m}}^*$ given by @eq-hatm.  </span>
<span id="cb9-340"><a href="#cb9-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-341"><a href="#cb9-341" aria-hidden="true" tabindex="-1"></a>The matrices ${\widehat{\Sigma}^{\text{}}_\text{opt}}$ and ${\widehat{\Sigma}^{\text{}}_\text{mean}}$ use the estimation $\widehat{\Sigma}^*$ but the actual directions $\mathbf{d}^*_i$ or $\mathbf{m}^*$, while the matrices ${\widehat{\Sigma}^{\text{+d}}_\text{opt}}$ and ${\widehat{\Sigma}^{\text{+d}}_\text{mean}}$ involve an additional estimation of the directions. By definition, $\Sigma^*$ will give optimal results, while results for $\widehat{\Sigma}^*$ will deteriorate as the dimension increases, which is the well-known behavior which we try to improve. Moreover, for ${\widehat{\Sigma}^{\text{}}_\text{mean}}$ and ${\widehat{\Sigma}^{\text{}}_\text{opt}}$, the projection directions, if not known analytically, are obtained by a brute force Monte Carlo scheme with a very high simulation budget. Finally, we emphasize that Algorithm 1 corresponds to estimating and projecting on the $\mathbf{d}^*_i$'s, and so the matrix $\widehat{\Sigma}^*_k$ of Algorithm 1 is equal to the matrix ${\widehat{\Sigma}^{\text{+d}}_\text{opt}}$, i.e., $\widehat{\Sigma}^*_k = {\widehat{\Sigma}^{\text{+d}}_\text{opt}}$.</span>
<span id="cb9-342"><a href="#cb9-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-343"><a href="#cb9-343" aria-hidden="true" tabindex="-1"></a>|   |$\Sigma^*$|$\widehat{\Sigma}^*$|${\widehat{\Sigma}^{\text{}}_\text{opt}}$|${\widehat{\Sigma}^{\text{}}_\text{mean}}$|${\widehat{\Sigma}^{\text{+d}}_\text{opt}}$|${\widehat{\Sigma}^{\text{+d}}_\text{mean}}$|</span>
<span id="cb9-344"><a href="#cb9-344" aria-hidden="true" tabindex="-1"></a>|-------|---|---|---|---|---|---|---|</span>
<span id="cb9-345"><a href="#cb9-345" aria-hidden="true" tabindex="-1"></a>|Initial covariance matrix|$\Sigma^*$|$\widehat \Sigma^*$|$\widehat \Sigma^*$|$\widehat \Sigma^*$|$\widehat \Sigma^*$|$\widehat \Sigma^*$|</span>
<span id="cb9-346"><a href="#cb9-346" aria-hidden="true" tabindex="-1"></a>|Projection directions (exact or estimated)|-|-|Exact|Exact|Estimated|Estimated|</span>
<span id="cb9-347"><a href="#cb9-347" aria-hidden="true" tabindex="-1"></a>|Choice for the projection direction|None|None|Opt|Mean|Opt|Mean|</span>
<span id="cb9-348"><a href="#cb9-348" aria-hidden="true" tabindex="-1"></a>:  Presentation of the six covariance matrices considered in the numerical examples. Except $\Sigma^*$, the five other matrices involve one or two estimations: $\widehat \Sigma^*$ is the empirical estimation of $\Sigma^*$ given by @eq-hatSigma. The four others are obtained by projecting $\widehat \Sigma^*$ on: (i) the optimal directions $\mathbf{d}^*_i$ for ${\widehat{\Sigma}^{\text{}}_\text{opt}}$; (ii) estimations $\widehat{\mathbf{d}}^*_i$ of the optimal directions $\mathbf{d}^*_i$ for ${\widehat{\Sigma}^{\text{+d}}_\text{opt}}$; (iii) $\mathbf{m}^*$ for ${\widehat{\Sigma}^{\text{}}_\text{mean}}$; (iv) the estimation $\widehat{\mathbf{m}}^*$ in @eq-mstar of $\mathbf{m}^*$ for ${\widehat{\Sigma}^{\text{+d}}_\text{mean}}$. The subscript therefore indicates the choice for the projection direction, while the superscript +d indicates whether these directions are estimated or not. {#tbl-sigma}</span>
<span id="cb9-349"><a href="#cb9-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-350"><a href="#cb9-350" aria-hidden="true" tabindex="-1"></a><span class="fu">## Choice of the auxiliary density $g'$ for the von Mises–Fisher–Nakagami model</span></span>
<span id="cb9-351"><a href="#cb9-351" aria-hidden="true" tabindex="-1"></a>Von Mises–Fisher–Nakagami (vMFN) distributions were proposed in <span class="co">[</span><span class="ot">@PapaioannouEtAl_ImprovedCrossEntropybased_2019</span><span class="co">]</span> as an alternative to the Gaussian parametric family to perform IS for high dimensional probability estimation. A random vector $\mathbf{X}$ drawn according to the vMFN distribution can be written as $\mathbf{X}=R {\bf A}$ where ${\bf A}=\frac{\mathbf{X}}{\lVert\mathbf{X}\rVert}$ is a unit random vector following the von Mises-Fisher distribution, and $R=\lVert\mathbf{X}\rVert$ is a positive random variable with a Nakagami distribution; further, $R$ and $\bf A$ are independent. The vMFN pdf can be written as</span>
<span id="cb9-352"><a href="#cb9-352" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-353"><a href="#cb9-353" aria-hidden="true" tabindex="-1"></a>g_\text{vMFN}({\bf x})= g_\text{N}(\lVert{\bf x}\rVert, p, \omega) \times g_\text{vMF} \left( \frac{{\bf x}}{\lVert{\bf x}\rVert}, {\boldsymbol{\mu}}, \kappa \right).</span>
<span id="cb9-354"><a href="#cb9-354" aria-hidden="true" tabindex="-1"></a>$${#eq-vMFN}</span>
<span id="cb9-355"><a href="#cb9-355" aria-hidden="true" tabindex="-1"></a>The density $g_\text{N}(\lVert {\bf x}\rVert, p, \omega)$ is the Nakagami distribution with shape parameter $p \geq 0.5$ and a spread parameter $\omega&gt;0$ defined by</span>
<span id="cb9-356"><a href="#cb9-356" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb9-357"><a href="#cb9-357" aria-hidden="true" tabindex="-1"></a>g_\text{N}(\lVert {\bf x}\rVert, p, \omega) = \frac{2 p^p}{\Gamma(p) \omega^p} \lVert {\bf x}\rVert^{2p-1} \exp\left( - \frac{p}{\omega}\lVert {\bf x}\rVert^2\right) </span>
<span id="cb9-358"><a href="#cb9-358" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-359"><a href="#cb9-359" aria-hidden="true" tabindex="-1"></a>and the density $g_\text{vMF}(\frac{{\bf x}}{\lVert{\bf x}\rVert}, {\boldsymbol{\mu}}, \kappa)$ is the von Mises-Fisher distribution, given by</span>
<span id="cb9-360"><a href="#cb9-360" aria-hidden="true" tabindex="-1"></a>$$g_\text{vMF} \left( \frac{{\bf x}}{\lVert{\bf x}\rVert}, {\boldsymbol{\mu}}, \kappa \right) = C_n(\kappa) \exp\left(\kappa {\boldsymbol{\mu}}^T \frac{{\bf x}}{\lVert{\bf x}\rvert\rvert} \right),</span>
<span id="cb9-361"><a href="#cb9-361" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-362"><a href="#cb9-362" aria-hidden="true" tabindex="-1"></a>where $C_n(\kappa)$ is a normalizing constant, $\boldsymbol{\mu}$ is a mean direction $\boldsymbol{\mu}$ (with $\lvert\lvert\boldsymbol{\mu}\rvert\rvert=1$) and $\kappa &gt; 0$ is a concentration parameter $\kappa&gt;0$.</span>
<span id="cb9-363"><a href="#cb9-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-364"><a href="#cb9-364" aria-hidden="true" tabindex="-1"></a>Choosing a vMFN distribution therefore amounts to choosing the parameters $p, \omega, {\boldsymbol{\mu}},$ and $\kappa$. There are therefore $n+3$ parameters to estimate, which is a significant reduction compared to the $\frac{n(n+3)}{2}$ required parameters of the Gaussian model with full covariance matrix.</span>
<span id="cb9-365"><a href="#cb9-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-366"><a href="#cb9-366" aria-hidden="true" tabindex="-1"></a>Following <span class="co">[</span><span class="ot">@PapaioannouEtAl_ImprovedCrossEntropybased_2019</span><span class="co">]</span>, given a sample $\mathbf{X}_1,\ldots,\mathbf{X}_M$ distributed from $g^*$, the parameters $\omega$, $p$, $\boldsymbol{\mu}$ and $\kappa$ are set in the following way in order to define $g'$:</span>
<span id="cb9-367"><a href="#cb9-367" aria-hidden="true" tabindex="-1"></a>$$ \widehat{\omega}=\frac{1}{M}\sum_{i=1}^M \lVert\mathbf{X}_i\rVert^2 \ \text{ and } \ \widehat{p}=\frac{\widehat{\omega}^2}{\widehat{\tau}-\widehat{\omega}^2} \text{ with } \widehat{\tau}=\frac{1}{M}\sum_{i=1}^M \lVert\mathbf{X}_i\rVert^4 </span>
<span id="cb9-368"><a href="#cb9-368" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-369"><a href="#cb9-369" aria-hidden="true" tabindex="-1"></a>and</span>
<span id="cb9-370"><a href="#cb9-370" aria-hidden="true" tabindex="-1"></a>$$ \widehat{\boldsymbol{\mu}}=\frac{\sum_{i=1}^M \frac{\mathbf{X}_i}{\lvert\lvert\mathbf{X}_i\rvert\rvert}}{\lvert\lvert\sum_{i=1}^M \frac{\mathbf{X}_i}{\lvert\lvert\mathbf{X}_i\rvert\rvert} \rvert\rvert} \ \text{ and } \  \widehat{\kappa}=\dfrac{n\widehat{\chi}-\widehat{\chi}^3}{1-\widehat{\chi}^2} \text{ with } \widehat{\chi} = \min \left( \left \lVert \frac{1}{M}\sum_{i=1}^M \frac{\mathbf{X}_i}{\lVert \mathbf{X}_i \rVert} \right \rVert, 0.95 \right). </span>
<span id="cb9-371"><a href="#cb9-371" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-372"><a href="#cb9-372" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-373"><a href="#cb9-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-374"><a href="#cb9-374" aria-hidden="true" tabindex="-1"></a><span class="fu">#  Numerical results on five test cases   {#sec-test-cases} </span></span>
<span id="cb9-375"><a href="#cb9-375" aria-hidden="true" tabindex="-1"></a> The proposed numerical framework is applied on three examples that are often considered to assess the performance of importance sampling algorithms and also two test cases  from the area of financial mathematics. Extended simulation results are given in the supplementary material associated with this article.</span>
<span id="cb9-376"><a href="#cb9-376" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-377"><a href="#cb9-377" aria-hidden="true" tabindex="-1"></a><span class="fu">##  Test case 1: one-dimensional optimal projection   {#sec-sub:sum} </span></span>
<span id="cb9-378"><a href="#cb9-378" aria-hidden="true" tabindex="-1"></a>We consider a test case where all computations can be made exactly. This is a classical example of rare event probability estimation, often used to test the robustness of a method in high dimension. It is given by $\phi(\mathbf{x})=\mathbb{I}_{<span class="sc">\{</span>\varphi(\mathbf{x})\geq 0<span class="sc">\}</span>}$ with $\varphi$ the following affine function:</span>
<span id="cb9-379"><a href="#cb9-379" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-380"><a href="#cb9-380" aria-hidden="true" tabindex="-1"></a>    \varphi: \mathbf{x}=(x_1,\ldots,x_n)\in\mathbb{R}^n \mapsto\underset{j=1}{\overset{n}{\sum}} x_j-3\sqrt{n}.</span>
<span id="cb9-381"><a href="#cb9-381" aria-hidden="true" tabindex="-1"></a>$${#eq-sum}</span>
<span id="cb9-382"><a href="#cb9-382" aria-hidden="true" tabindex="-1"></a>The quantity of interest $E$ is defined as $E=\int_{\mathbb{R}^n} \phi(\mathbf{x}) f(\mathbf{x}) \textrm{d}\mathbf{x} = \mathbb{P}_f(\varphi(\mathbf{X})\geq 0)\simeq 1.35\cdot 10^{-3}$ for all $n$ where the density $f$ is the standard $n$-dimensional Gaussian distribution. Here, the zero-variance density is $g^*(\mathbf{x})=\dfrac{f(\mathbf{x})\mathbb{I}_{<span class="sc">\{</span>\varphi(\mathbf{x})\geq 0<span class="sc">\}</span>}}{E}$, and the optimal parameters $\mathbf{m}^*$ and $\Sigma^*$ in @eq-mstar can be computed exactly, namely $\mathbf{m}^* = \alpha \textbf{1}$ with $\alpha = e^{-9/2}/(E(2\pi)^{1/2})$ and $\textbf{1} = \frac{1}{\sqrt n} (1,\ldots,1) \in \mathbb{R}^n$ the normalized constant vector, and $\Sigma^* =(v-1) \mathbf{1} \mathbf{1}^\top + I_n$ with $v=3\alpha-\alpha^2+1$.</span>
<span id="cb9-383"><a href="#cb9-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-384"><a href="#cb9-384" aria-hidden="true" tabindex="-1"></a><span class="fu">###  Evolution of the partial KL divergence and spectrum</span></span>
<span id="cb9-385"><a href="#cb9-385" aria-hidden="true" tabindex="-1"></a>@fig-eigsum-1 represents the evolution as the dimension varies between $5$ and $100$ of the partial KL divergence $D'$ for three different choices of covariance matrix: the optimal matrix $\Sigma^*$, its empirical estimation $\widehat{\Sigma}^*$ and the estimation $\widehat{\Sigma}^*_k$ of the optimal lower-dimensional covariance matrix. We can notice that the partial KL divergence for $\widehat{\Sigma}^*$ grows much faster than the other two, and that the partial KL divergence for $\widehat{\Sigma}^*_k$ remains very close to the optimal value $D'(\Sigma^*)$. As the KL divergence is a proxy for the efficiency of the auxiliary density (it is for instance closely related to the number of samples required for a given precision [@Chatterjee18:0]), this suggests that using $\widehat{\Sigma}^*_k$ will provide results close to optimal.</span>
<span id="cb9-386"><a href="#cb9-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-387"><a href="#cb9-387" aria-hidden="true" tabindex="-1"></a>We now check this claim. As $\Sigma^* = (v-1) \textbf{1} \textbf{1}^\top + I_n$, its eigenpairs are $(v, \textbf{1})$ and $(1,\mathbf{d}_i)$ where the $\mathbf{d}_i$'s form an orthonormal basis of the space orthogonal to the space spanned by $\textbf{1}$. In particular, $(v, \textbf{1})$ is the largest (in $\ell$-order) eigenpair of $\Sigma^*$ and $\Sigma^*_k = \Sigma^*$ for any $k \geq 1$.</span>
<span id="cb9-388"><a href="#cb9-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-389"><a href="#cb9-389" aria-hidden="true" tabindex="-1"></a>In practice, we do not use this theoretical knowledge and $\Sigma^*$, $\Sigma^*_k$ and the eigenpairs are estimated. The six covariance matrices introduced in @sec-def_cov and in which we are interested are as follows:</span>
<span id="cb9-390"><a href="#cb9-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-391"><a href="#cb9-391" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\Sigma^* = (v-1) \textbf{1} \textbf{1}^\top + I_n$;</span>
<span id="cb9-392"><a href="#cb9-392" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\widehat{\Sigma}^*$ given by @eq-hatSigma;</span>
<span id="cb9-393"><a href="#cb9-393" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>${\widehat{\Sigma}^{\text{}}_\text{opt}}$ and ${\widehat{\Sigma}^{\text{}}_\text{mean}}$ are equal and given by $(\widehat \lambda-1) \textbf{1} \textbf{1}^\top + I_n$ with $\widehat{\lambda} = \textbf{1}^\top \widehat{\Sigma}^* \textbf{1}$. This amounts to assuming that the projection direction $\textbf{1}$ is perfectly known, whereas the variance in this direction is estimated;</span>
<span id="cb9-394"><a href="#cb9-394" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>${\widehat{\Sigma}^{\text{+d}}_\text{opt}} = (\widehat{\lambda} - 1) \widehat{\mathbf{d}} {\widehat{\mathbf{d}}}^\top + I_n$ with $(\widehat{\lambda}, \widehat{\mathbf{d}})$ the smallest eigenpair of $\widehat{\Sigma}^*$. The difference with the previous case is that we do not assume anymore that the optimal projection direction $\textbf{1}$ is known, and so it needs to be estimated;</span>
<span id="cb9-395"><a href="#cb9-395" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>${\widehat{\Sigma}^{\text{+d}}_\text{mean}} = (\widehat{\lambda} - 1) \frac{\widehat{\mathbf{m}}^* {(\widehat{\mathbf{m}}^*)}^\top}{\lVert \widehat{\mathbf{m}}^* \rVert^2} + I_n$ with $\widehat{\mathbf{m}}^*$ given by @eq-hatm and $\widehat{\lambda} = \frac{{(\widehat{\mathbf{m}}^*)}^\top \widehat{\Sigma}^* \widehat{\mathbf{m}}^*}{\lVert \widehat{\mathbf{m}}^* \rVert^2}$. Here we assume that $\mathbf{m}^*$ is a good projection direction, but is unknown and therefore needs to be estimated.</span>
<span id="cb9-396"><a href="#cb9-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-397"><a href="#cb9-397" aria-hidden="true" tabindex="-1"></a>Note that in the particularly simple case considered here, both $\widehat{\mathbf{m}}^* / \lVert \widehat{\mathbf{m}}^* \rVert$ and $\widehat{\mathbf{d}}$ are estimators of $\textbf{1}$ but they are obtained by different methods. In the next example we will consider a case where $\mathbf{m}^*$ is not an optimal projection direction as given by @thm-thm1.</span>
<span id="cb9-398"><a href="#cb9-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-399"><a href="#cb9-399" aria-hidden="true" tabindex="-1"></a>@fig-eigsum-2 represents the images by $\ell$ of the eigenvalues of $\Sigma^*$ and $\widehat{\Sigma}^*$. This picture carries a very important insight. We notice that the estimation of most eigenvalues is poor: indeed, all the blue crosses except the leftmost one are meant to be estimator of $1$, whereas we see that they are more or less uniformly spread between $0.4$ and $1.8$. This means that the variance terms in the corresponding directions are poorly estimated, which could be the explanation on why the use of $\widehat{\Sigma}^*$ gives an inaccurate estimation. But what we remark also is that the function $\ell$ is quite flat around one: as a consequence, although the eigenvalues offer significant variability, this variability is smoothed by the action of $\ell$. Indeed, the images of the eigenvalues by $\ell$ take values between $0$ and $0.4$ and have smaller variability. Moreover, $\ell(x)$ increases sharply as $x$ approaches $0$ and thus efficiently distinguishes between the two leftmost estimated eigenvalues and is able to separate them.</span>
<span id="cb9-400"><a href="#cb9-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-403"><a href="#cb9-403" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb9-404"><a href="#cb9-404" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-eigsum</span></span>
<span id="cb9-405"><a href="#cb9-405" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: 'Partial KL divergence and spectrum for the function $\phi = \mathbb{I}_{\varphi \geq 0}$ with $\varphi$ the linear function given by @eq-sum.'</span></span>
<span id="cb9-406"><a href="#cb9-406" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-subcap:</span></span>
<span id="cb9-407"><a href="#cb9-407" aria-hidden="true" tabindex="-1"></a><span class="co">#|   - 'Evolution of the partial KL divergence as the dimension increases, with the optimal covariance matrix $\Sigma^*$ (blue circles), the sample covariance $\widehat{\Sigma}^*$ (red squares), and the projected covariance $\widehat{\Sigma}^*_k$ (black triangles).'</span></span>
<span id="cb9-408"><a href="#cb9-408" aria-hidden="true" tabindex="-1"></a><span class="co">#|   - 'Computation of $\ell(\lambda_i)$ for the eigenvalues of $\Sigma^*$ (red squares) and $\widehat{\Sigma}^*$ (blue crosses) in dimension $n = 100$.'</span></span>
<span id="cb9-409"><a href="#cb9-409" aria-hidden="true" tabindex="-1"></a><span class="co">#| layout-ncol: 2</span></span>
<span id="cb9-410"><a href="#cb9-410" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb9-411"><a href="#cb9-411" aria-hidden="true" tabindex="-1"></a><span class="co"># Figure 2. Evolution of the partial KL divergence and spectrum of the eigenvalues for the test case 1</span></span>
<span id="cb9-412"><a href="#cb9-412" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb9-413"><a href="#cb9-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-414"><a href="#cb9-414" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Somme(x):</span>
<span id="cb9-415"><a href="#cb9-415" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span>np.shape(x)[<span class="dv">1</span>]</span>
<span id="cb9-416"><a href="#cb9-416" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(np.<span class="bu">sum</span>(x,axis<span class="op">=</span><span class="dv">1</span>)<span class="op">-</span><span class="dv">3</span><span class="op">*</span>np.sqrt(n))</span>
<span id="cb9-417"><a href="#cb9-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-418"><a href="#cb9-418" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span><span class="dv">100</span>         <span class="co"># dimension</span></span>
<span id="cb9-419"><a href="#cb9-419" aria-hidden="true" tabindex="-1"></a>phi<span class="op">=</span>Somme</span>
<span id="cb9-420"><a href="#cb9-420" aria-hidden="true" tabindex="-1"></a>E<span class="op">=</span>sp.stats.norm.cdf(<span class="op">-</span><span class="dv">3</span>)   <span class="co"># exact value of the integral</span></span>
<span id="cb9-421"><a href="#cb9-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-422"><a href="#cb9-422" aria-hidden="true" tabindex="-1"></a>DKL<span class="op">=</span>np.zeros(<span class="dv">20</span>)</span>
<span id="cb9-423"><a href="#cb9-423" aria-hidden="true" tabindex="-1"></a>DKLp<span class="op">=</span>np.zeros(<span class="dv">20</span>)</span>
<span id="cb9-424"><a href="#cb9-424" aria-hidden="true" tabindex="-1"></a>DKLm<span class="op">=</span>np.zeros(<span class="dv">20</span>)</span>
<span id="cb9-425"><a href="#cb9-425" aria-hidden="true" tabindex="-1"></a>DKLstar<span class="op">=</span>np.zeros(<span class="dv">20</span>)</span>
<span id="cb9-426"><a href="#cb9-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-427"><a href="#cb9-427" aria-hidden="true" tabindex="-1"></a>M<span class="op">=</span><span class="dv">300</span></span>
<span id="cb9-428"><a href="#cb9-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-429"><a href="#cb9-429" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>,n<span class="op">+</span><span class="dv">1</span>,<span class="dv">5</span>):</span>
<span id="cb9-430"><a href="#cb9-430" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mstar</span></span>
<span id="cb9-431"><a href="#cb9-431" aria-hidden="true" tabindex="-1"></a>    alpha<span class="op">=</span>np.exp(<span class="op">-</span><span class="dv">3</span><span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)<span class="op">/</span>(E<span class="op">*</span>np.sqrt(<span class="dv">2</span><span class="op">*</span>np.pi))</span>
<span id="cb9-432"><a href="#cb9-432" aria-hidden="true" tabindex="-1"></a>    Mstar<span class="op">=</span>alpha<span class="op">*</span>np.ones(d)<span class="op">/</span>np.sqrt(d)</span>
<span id="cb9-433"><a href="#cb9-433" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sigmastar</span></span>
<span id="cb9-434"><a href="#cb9-434" aria-hidden="true" tabindex="-1"></a>    vstar<span class="op">=</span><span class="dv">3</span><span class="op">*</span>alpha<span class="op">-</span>alpha<span class="op">**</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span></span>
<span id="cb9-435"><a href="#cb9-435" aria-hidden="true" tabindex="-1"></a>    Sigstar<span class="op">=</span> (vstar<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>np.ones((d,d))<span class="op">/</span>d<span class="op">+</span>np.eye(d)</span>
<span id="cb9-436"><a href="#cb9-436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-437"><a href="#cb9-437" aria-hidden="true" tabindex="-1"></a>    <span class="co">## g*-sample</span></span>
<span id="cb9-438"><a href="#cb9-438" aria-hidden="true" tabindex="-1"></a>    VA0<span class="op">=</span>sp.stats.multivariate_normal(mean<span class="op">=</span>np.zeros(d),cov<span class="op">=</span>np.eye(d))</span>
<span id="cb9-439"><a href="#cb9-439" aria-hidden="true" tabindex="-1"></a>    X0<span class="op">=</span>VA0.rvs(size<span class="op">=</span>M<span class="op">*</span><span class="dv">1000</span>)</span>
<span id="cb9-440"><a href="#cb9-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-441"><a href="#cb9-441" aria-hidden="true" tabindex="-1"></a>    ind<span class="op">=</span>(phi(X0)<span class="op">&gt;</span><span class="dv">0</span>)</span>
<span id="cb9-442"><a href="#cb9-442" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X0[ind,:]</span>
<span id="cb9-443"><a href="#cb9-443" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X[:M,:]            <span class="co"># g*-sample of size M</span></span>
<span id="cb9-444"><a href="#cb9-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-445"><a href="#cb9-445" aria-hidden="true" tabindex="-1"></a>    <span class="co">## estimated mean and covariance</span></span>
<span id="cb9-446"><a href="#cb9-446" aria-hidden="true" tabindex="-1"></a>    mm<span class="op">=</span>np.mean(X,axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb9-447"><a href="#cb9-447" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-448"><a href="#cb9-448" aria-hidden="true" tabindex="-1"></a>    Xc<span class="op">=</span>(X<span class="op">-</span>mm).T</span>
<span id="cb9-449"><a href="#cb9-449" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span>Xc <span class="op">@</span> Xc.T<span class="op">/</span>np.shape(Xc)[<span class="dv">1</span>]</span>
<span id="cb9-450"><a href="#cb9-450" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-451"><a href="#cb9-451" aria-hidden="true" tabindex="-1"></a>    <span class="co">## projection with the eigenvalues of sigma</span></span>
<span id="cb9-452"><a href="#cb9-452" aria-hidden="true" tabindex="-1"></a>    Eig<span class="op">=</span>np.linalg.eigh(sigma)</span>
<span id="cb9-453"><a href="#cb9-453" aria-hidden="true" tabindex="-1"></a>    logeig<span class="op">=</span>np.sort(np.log(Eig[<span class="dv">0</span>])<span class="op">-</span>Eig[<span class="dv">0</span>])</span>
<span id="cb9-454"><a href="#cb9-454" aria-hidden="true" tabindex="-1"></a>    delta<span class="op">=</span>np.zeros(<span class="bu">len</span>(logeig)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb9-455"><a href="#cb9-455" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(logeig)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb9-456"><a href="#cb9-456" aria-hidden="true" tabindex="-1"></a>        delta[j]<span class="op">=</span><span class="bu">abs</span>(logeig[j]<span class="op">-</span>logeig[j<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb9-457"><a href="#cb9-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-458"><a href="#cb9-458" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span>np.argmax(delta)<span class="op">+</span><span class="dv">1</span>         <span class="co"># biggest gap between the l(lambda_i)</span></span>
<span id="cb9-459"><a href="#cb9-459" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-460"><a href="#cb9-460" aria-hidden="true" tabindex="-1"></a>    indi<span class="op">=</span>[]</span>
<span id="cb9-461"><a href="#cb9-461" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb9-462"><a href="#cb9-462" aria-hidden="true" tabindex="-1"></a>        indi.append(np.where(np.log(Eig[<span class="dv">0</span>])<span class="op">-</span>Eig[<span class="dv">0</span>]<span class="op">==</span>logeig[l])[<span class="dv">0</span>][<span class="dv">0</span>])</span>
<span id="cb9-463"><a href="#cb9-463" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-464"><a href="#cb9-464" aria-hidden="true" tabindex="-1"></a>    P1<span class="op">=</span>np.array(Eig[<span class="dv">1</span>][:,indi[<span class="dv">0</span>]],ndmin<span class="op">=</span><span class="dv">2</span>).T                  </span>
<span id="cb9-465"><a href="#cb9-465" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,k):</span>
<span id="cb9-466"><a href="#cb9-466" aria-hidden="true" tabindex="-1"></a>        P1<span class="op">=</span>np.concatenate((P1,np.array(Eig[<span class="dv">1</span>][:,indi[l]],ndmin<span class="op">=</span><span class="dv">2</span>).T),axis<span class="op">=</span><span class="dv">1</span>)   <span class="co"># matrix of inflential directions of projection</span></span>
<span id="cb9-467"><a href="#cb9-467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-468"><a href="#cb9-468" aria-hidden="true" tabindex="-1"></a>    diagsi<span class="op">=</span>np.diag(Eig[<span class="dv">0</span>][indi])</span>
<span id="cb9-469"><a href="#cb9-469" aria-hidden="true" tabindex="-1"></a>    sig_opt_d<span class="op">=</span>P1.dot((diagsi<span class="op">-</span>np.eye(k))).dot(P1.T)<span class="op">+</span>np.eye(d)  </span>
<span id="cb9-470"><a href="#cb9-470" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-471"><a href="#cb9-471" aria-hidden="true" tabindex="-1"></a>    DKL[<span class="bu">int</span>((d<span class="op">-</span><span class="dv">5</span>)<span class="op">/</span><span class="dv">5</span>)]<span class="op">=</span>np.log(np.linalg.det(sigma))<span class="op">+</span>np.<span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(sigma))))</span>
<span id="cb9-472"><a href="#cb9-472" aria-hidden="true" tabindex="-1"></a>    DKLp[<span class="bu">int</span>((d<span class="op">-</span><span class="dv">5</span>)<span class="op">/</span><span class="dv">5</span>)]<span class="op">=</span>np.log(np.linalg.det(sig_opt_d))<span class="op">+</span>np.<span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(sig_opt_d))))</span>
<span id="cb9-473"><a href="#cb9-473" aria-hidden="true" tabindex="-1"></a>    DKLstar[<span class="bu">int</span>((d<span class="op">-</span><span class="dv">5</span>)<span class="op">/</span><span class="dv">5</span>)]<span class="op">=</span>np.log(np.linalg.det(Sigstar))<span class="op">+</span>d</span>
<span id="cb9-474"><a href="#cb9-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-475"><a href="#cb9-475" aria-hidden="true" tabindex="-1"></a><span class="co">#### plot of partial KL divergence</span></span>
<span id="cb9-476"><a href="#cb9-476" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">5</span>,<span class="dv">105</span>,<span class="dv">5</span>),DKL,<span class="st">'rs'</span>,label<span class="op">=</span><span class="vs">r"$D'(\hat{\Sigma}^*)$"</span>)</span>
<span id="cb9-477"><a href="#cb9-477" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">5</span>,<span class="dv">105</span>,<span class="dv">5</span>),DKLp,<span class="st">'k^'</span>,label<span class="op">=</span><span class="vs">r"$D'(\hat{\Sigma}^*_k)$"</span>)</span>
<span id="cb9-478"><a href="#cb9-478" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">5</span>,<span class="dv">105</span>,<span class="dv">5</span>),DKLstar,<span class="st">'bo'</span>,label<span class="op">=</span><span class="vs">r"$D'(\Sigma^*)$"</span>)</span>
<span id="cb9-479"><a href="#cb9-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-480"><a href="#cb9-480" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb9-481"><a href="#cb9-481" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Dimension'</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb9-482"><a href="#cb9-482" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="vs">r"Partial KL divergence $D'$"</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb9-483"><a href="#cb9-483" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb9-484"><a href="#cb9-484" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tickLabel <span class="kw">in</span> plt.gca().get_xticklabels() <span class="op">+</span> plt.gca().get_yticklabels():</span>
<span id="cb9-485"><a href="#cb9-485" aria-hidden="true" tabindex="-1"></a>    tickLabel.set_fontsize(<span class="dv">16</span>)</span>
<span id="cb9-486"><a href="#cb9-486" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb9-487"><a href="#cb9-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-488"><a href="#cb9-488" aria-hidden="true" tabindex="-1"></a><span class="co">#### plot of the eigenvalues</span></span>
<span id="cb9-489"><a href="#cb9-489" aria-hidden="true" tabindex="-1"></a>Eig1<span class="op">=</span>np.linalg.eigh(sigma)</span>
<span id="cb9-490"><a href="#cb9-490" aria-hidden="true" tabindex="-1"></a>logeig1<span class="op">=</span>np.log(Eig1[<span class="dv">0</span>])<span class="op">-</span>Eig1[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span></span>
<span id="cb9-491"><a href="#cb9-491" aria-hidden="true" tabindex="-1"></a>Table_eigv<span class="op">=</span>np.zeros((n,<span class="dv">2</span>))</span>
<span id="cb9-492"><a href="#cb9-492" aria-hidden="true" tabindex="-1"></a>Table_eigv[:,<span class="dv">0</span>]<span class="op">=</span>Eig1[<span class="dv">0</span>]</span>
<span id="cb9-493"><a href="#cb9-493" aria-hidden="true" tabindex="-1"></a>Table_eigv[:,<span class="dv">1</span>]<span class="op">=-</span>logeig1</span>
<span id="cb9-494"><a href="#cb9-494" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-495"><a href="#cb9-495" aria-hidden="true" tabindex="-1"></a>Eigst<span class="op">=</span>np.linalg.eigh(Sigstar)</span>
<span id="cb9-496"><a href="#cb9-496" aria-hidden="true" tabindex="-1"></a>logeigst<span class="op">=</span>np.log(Eigst[<span class="dv">0</span>])<span class="op">-</span>Eigst[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span></span>
<span id="cb9-497"><a href="#cb9-497" aria-hidden="true" tabindex="-1"></a>Table_eigv_st<span class="op">=</span>np.zeros((n,<span class="dv">2</span>))</span>
<span id="cb9-498"><a href="#cb9-498" aria-hidden="true" tabindex="-1"></a>Table_eigv_st[:,<span class="dv">0</span>]<span class="op">=</span>Eigst[<span class="dv">0</span>]</span>
<span id="cb9-499"><a href="#cb9-499" aria-hidden="true" tabindex="-1"></a>Table_eigv_st[:,<span class="dv">1</span>]<span class="op">=-</span>logeigst</span>
<span id="cb9-500"><a href="#cb9-500" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-501"><a href="#cb9-501" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb9-502"><a href="#cb9-502" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"Eigenvalues $\lambda_i$"</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb9-503"><a href="#cb9-503" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="vs">r"$\ell(\lambda_i)$"</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb9-504"><a href="#cb9-504" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tickLabel <span class="kw">in</span> plt.gca().get_xticklabels() <span class="op">+</span> plt.gca().get_yticklabels():</span>
<span id="cb9-505"><a href="#cb9-505" aria-hidden="true" tabindex="-1"></a>    tickLabel.set_fontsize(<span class="dv">16</span>)</span>
<span id="cb9-506"><a href="#cb9-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-507"><a href="#cb9-507" aria-hidden="true" tabindex="-1"></a>plt.plot(Table_eigv[:,<span class="dv">0</span>],Table_eigv[:,<span class="dv">1</span>],<span class="st">'bx'</span>,label<span class="op">=</span><span class="vs">r"Eigenvalues of $\hat{\Sigma}^*$"</span>)</span>
<span id="cb9-508"><a href="#cb9-508" aria-hidden="true" tabindex="-1"></a>plt.plot(Table_eigv_st[:,<span class="dv">0</span>],Table_eigv_st[:,<span class="dv">1</span>],<span class="st">'rs'</span>,label<span class="op">=</span><span class="vs">r"Eigenvalues of $\Sigma^*$"</span>)</span>
<span id="cb9-509"><a href="#cb9-509" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb9-510"><a href="#cb9-510" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb9-511"><a href="#cb9-511" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb9-512"><a href="#cb9-512" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-513"><a href="#cb9-513" aria-hidden="true" tabindex="-1"></a><span class="fu">###  Numerical results</span></span>
<span id="cb9-514"><a href="#cb9-514" aria-hidden="true" tabindex="-1"></a>We report in @tbl-sum the numerical results for the six different matrices and the vMFN model for the dimension $n=100$. The column $\Sigma^*$ gives the optimal results, while the column $\widehat{\Sigma}^*$ corresponds to the results that we are trying to improve. Comparing these two columns, we notice as expected that the estimation of $E$ with $\widehat{\Sigma}^*$ is significantly degraded. Compared to the first column $\Sigma^*$, the third and fourth column with ${\widehat{\Sigma}^{\text{}}_\text{opt}} =  {\widehat{\Sigma}^{\text{}}_\text{mean}}$ correspond to the best projection direction $\textbf{1}$ (as for $\Sigma^*$) but estimating the variance in this direction (instead of the true variance) with $\textbf{1}^\top \widehat{\Sigma}^* \textbf{1}$. This choice performs very well, with numerical results similar to the optimal ones. This can be understood since in this case, both ${\widehat{\Sigma}^{\text{}}_\text{opt}}$ and $\Sigma^*$ are of the form $\alpha \textbf{1} \textbf{1}^\top + I_n$ and so estimating ${\widehat{\Sigma}^{\text{}}_\text{opt}}$ requires only a one-dimensional estimation (namely, the estimation of $\alpha$). Next, the last two columns ${\widehat{\Sigma}^{\text{+d}}_\text{opt}}$ and ${\widehat{\Sigma}^{\text{+d}}_\text{mean}}$ highlight the impact of having to estimate the projection directions in addition to the variance since these two matrices are of the form $\widehat \alpha \widehat{\textbf{1}} {\widehat{\textbf{1}}}^\top + I_n$ with both $\widehat{\alpha}$ (the variance term) and $\widehat{\textbf{1}}$ (the direction) being estimated. We observe that these matrices yield results which are close to optimal and greatly improve the estimation obtained using $\widehat{\Sigma}^*$. In dimension $100$, the coefficient of variation is around $4$\% for ${\widehat{\Sigma}^{\text{+d}}_\text{mean}}$, and around $5$\% for $\widehat{\Sigma}^{\text{+d}}_{\text{opt}}$, compared to $2.5$\% for $\widehat{\Sigma}^*$. </span>
<span id="cb9-515"><a href="#cb9-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-516"><a href="#cb9-516" aria-hidden="true" tabindex="-1"></a>Moreover, we observe that ${\widehat{\Sigma}^{\text{+d}}_\text{mean}}$ gives slightly better results than ${\widehat{\Sigma}^{\text{+d}}_\text{opt}}$. We suggest that this is because $\widehat{\mathbf{m}}^* / \lVert \widehat{\mathbf{m}}^* \rVert$ is a better estimator of $\textbf{1}$ than the eigenvector of $\widehat{\Sigma}^*$. Indeed, evaluating $\widehat{\mathbf{m}}^*$ requires the estimation of $n$ parameters, whereas $\widehat{\Sigma}^*$ needs around $n^2/2$ parameters to estimate, so the eigenvector is finally more noisy than the mean vector.  In the last column, we present the vMFN results that are similar to the estimation obtained with ${\widehat{\Sigma}^{\text{+d}}_\text{mean}}$.</span>
<span id="cb9-517"><a href="#cb9-517" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-518"><a href="#cb9-518" aria-hidden="true" tabindex="-1"></a>Thus, the proposed idea improves significantly the probability estimation in high dimension. But we see that the method taken in <span class="co">[</span><span class="ot">@MasriEtAl_ImprovementCrossentropyMethod_2020</span><span class="co">]</span> with the projection $\mathbf{m}^*$ is at least as much efficient in this example where we need only a one-dimensional projection. The next case shows that the projection on more than one direction can outperform the one-dimensional projection on $\mathbf{m}^*$. </span>
<span id="cb9-519"><a href="#cb9-519" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-522"><a href="#cb9-522" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb9-523"><a href="#cb9-523" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-sum</span></span>
<span id="cb9-524"><a href="#cb9-524" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: 'Numerical comparison of the estimation of $E \approx 1.35\cdot 10^{-3}$ considering the Gaussian model with the six covariance matrices defined in @sec-def_cov and the vFMN model, when $\phi = \mathbb{I}_{\{\varphi\geq 0\}}$ with $\varphi$ the linear function given by @eq-sum. As explained in the text, ${\widehat{\Sigma}^{\text{}}_\text{mean}}$ and ${\widehat{\Sigma}^{\text{}}_\text{opt}}$ are actually equal in this case.'</span></span>
<span id="cb9-525"><a href="#cb9-525" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb9-526"><a href="#cb9-526" aria-hidden="true" tabindex="-1"></a><span class="co"># Table 2. Numerical comparison on test case 1</span></span>
<span id="cb9-527"><a href="#cb9-527" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb9-528"><a href="#cb9-528" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display, Math, Latex</span>
<span id="cb9-529"><a href="#cb9-529" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Markdown</span>
<span id="cb9-530"><a href="#cb9-530" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tabulate <span class="im">import</span> tabulate</span>
<span id="cb9-531"><a href="#cb9-531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-532"><a href="#cb9-532" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span><span class="dv">100</span>         <span class="co"># dimension</span></span>
<span id="cb9-533"><a href="#cb9-533" aria-hidden="true" tabindex="-1"></a>phi<span class="op">=</span>Somme</span>
<span id="cb9-534"><a href="#cb9-534" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-535"><a href="#cb9-535" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mypi(X):                   </span>
<span id="cb9-536"><a href="#cb9-536" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span>np.shape(X)[<span class="dv">1</span>]</span>
<span id="cb9-537"><a href="#cb9-537" aria-hidden="true" tabindex="-1"></a>    f0<span class="op">=</span>sp.stats.multivariate_normal.pdf(X,mean<span class="op">=</span>np.zeros(n),cov<span class="op">=</span>np.eye(n))</span>
<span id="cb9-538"><a href="#cb9-538" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>((phi(X)<span class="op">&gt;</span><span class="dv">0</span>)<span class="op">*</span>f0)</span>
<span id="cb9-539"><a href="#cb9-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-540"><a href="#cb9-540" aria-hidden="true" tabindex="-1"></a>N<span class="op">=</span><span class="dv">2000</span>   </span>
<span id="cb9-541"><a href="#cb9-541" aria-hidden="true" tabindex="-1"></a>M<span class="op">=</span><span class="dv">500</span>   </span>
<span id="cb9-542"><a href="#cb9-542" aria-hidden="true" tabindex="-1"></a>B<span class="op">=</span><span class="dv">50</span>    <span class="co"># number of runs</span></span>
<span id="cb9-543"><a href="#cb9-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-544"><a href="#cb9-544" aria-hidden="true" tabindex="-1"></a>Eopt<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-545"><a href="#cb9-545" aria-hidden="true" tabindex="-1"></a>EIS<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-546"><a href="#cb9-546" aria-hidden="true" tabindex="-1"></a>Eprj<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-547"><a href="#cb9-547" aria-hidden="true" tabindex="-1"></a>Eprm<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-548"><a href="#cb9-548" aria-hidden="true" tabindex="-1"></a>Eprjst<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-549"><a href="#cb9-549" aria-hidden="true" tabindex="-1"></a>Eprmst<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-550"><a href="#cb9-550" aria-hidden="true" tabindex="-1"></a>Evmfn<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-551"><a href="#cb9-551" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-552"><a href="#cb9-552" aria-hidden="true" tabindex="-1"></a>SI<span class="op">=</span>[]</span>
<span id="cb9-553"><a href="#cb9-553" aria-hidden="true" tabindex="-1"></a>SIP<span class="op">=</span>[]</span>
<span id="cb9-554"><a href="#cb9-554" aria-hidden="true" tabindex="-1"></a>SIPst<span class="op">=</span>[]</span>
<span id="cb9-555"><a href="#cb9-555" aria-hidden="true" tabindex="-1"></a>SIM<span class="op">=</span>[]</span>
<span id="cb9-556"><a href="#cb9-556" aria-hidden="true" tabindex="-1"></a>SIMst<span class="op">=</span>[]</span>
<span id="cb9-557"><a href="#cb9-557" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-558"><a href="#cb9-558" aria-hidden="true" tabindex="-1"></a><span class="co"># Mstar</span></span>
<span id="cb9-559"><a href="#cb9-559" aria-hidden="true" tabindex="-1"></a>alpha<span class="op">=</span>np.exp(<span class="op">-</span><span class="dv">3</span><span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)<span class="op">/</span>(E<span class="op">*</span>np.sqrt(<span class="dv">2</span><span class="op">*</span>np.pi))</span>
<span id="cb9-560"><a href="#cb9-560" aria-hidden="true" tabindex="-1"></a>Mstar<span class="op">=</span>alpha<span class="op">*</span>np.ones(d)<span class="op">/</span>np.sqrt(d)</span>
<span id="cb9-561"><a href="#cb9-561" aria-hidden="true" tabindex="-1"></a><span class="co"># Sigmastar</span></span>
<span id="cb9-562"><a href="#cb9-562" aria-hidden="true" tabindex="-1"></a>vstar<span class="op">=</span><span class="dv">3</span><span class="op">*</span>alpha<span class="op">-</span>alpha<span class="op">**</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span></span>
<span id="cb9-563"><a href="#cb9-563" aria-hidden="true" tabindex="-1"></a>Sigstar<span class="op">=</span> (vstar<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>np.ones((d,d))<span class="op">/</span>d<span class="op">+</span>np.eye(d)</span>
<span id="cb9-564"><a href="#cb9-564" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-565"><a href="#cb9-565" aria-hidden="true" tabindex="-1"></a>Eigst<span class="op">=</span>np.linalg.eigh(Sigstar)                        </span>
<span id="cb9-566"><a href="#cb9-566" aria-hidden="true" tabindex="-1"></a>logeigst<span class="op">=</span>np.sort(np.log(Eigst[<span class="dv">0</span>])<span class="op">-</span>Eigst[<span class="dv">0</span>])         </span>
<span id="cb9-567"><a href="#cb9-567" aria-hidden="true" tabindex="-1"></a>deltast<span class="op">=</span>np.zeros(<span class="bu">len</span>(logeigst)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb9-568"><a href="#cb9-568" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-569"><a href="#cb9-569" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(logeigst)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb9-570"><a href="#cb9-570" aria-hidden="true" tabindex="-1"></a>    deltast[i]<span class="op">=</span><span class="bu">abs</span>(logeigst[i]<span class="op">-</span>logeigst[i<span class="op">+</span><span class="dv">1</span>])         </span>
<span id="cb9-571"><a href="#cb9-571" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-572"><a href="#cb9-572" aria-hidden="true" tabindex="-1"></a><span class="co">## choice of the number of dimension</span></span>
<span id="cb9-573"><a href="#cb9-573" aria-hidden="true" tabindex="-1"></a>k_st<span class="op">=</span>np.argmax(deltast)<span class="op">+</span><span class="dv">1</span>     </span>
<span id="cb9-574"><a href="#cb9-574" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-575"><a href="#cb9-575" aria-hidden="true" tabindex="-1"></a>indist<span class="op">=</span>[]</span>
<span id="cb9-576"><a href="#cb9-576" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(k_st):</span>
<span id="cb9-577"><a href="#cb9-577" aria-hidden="true" tabindex="-1"></a>    indist.append(np.where(np.log(Eigst[<span class="dv">0</span>])<span class="op">-</span>Eigst[<span class="dv">0</span>]<span class="op">==</span>logeigst[i])[<span class="dv">0</span>][<span class="dv">0</span>])           </span>
<span id="cb9-578"><a href="#cb9-578" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-579"><a href="#cb9-579" aria-hidden="true" tabindex="-1"></a>P1st<span class="op">=</span>np.array(Eigst[<span class="dv">1</span>][:,indist[<span class="dv">0</span>]],ndmin<span class="op">=</span><span class="dv">2</span>).T</span>
<span id="cb9-580"><a href="#cb9-580" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,k_st):</span>
<span id="cb9-581"><a href="#cb9-581" aria-hidden="true" tabindex="-1"></a>    P1st<span class="op">=</span>np.concatenate((P1st,np.array(Eigst[<span class="dv">1</span>][:,indist[i]],ndmin<span class="op">=</span><span class="dv">2</span>).T),axis<span class="op">=</span><span class="dv">1</span>)    <span class="co"># matrix of influential directions   </span></span>
<span id="cb9-582"><a href="#cb9-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-583"><a href="#cb9-583" aria-hidden="true" tabindex="-1"></a><span class="co">#np.random.seed(0)</span></span>
<span id="cb9-584"><a href="#cb9-584" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(B):</span>
<span id="cb9-585"><a href="#cb9-585" aria-hidden="true" tabindex="-1"></a><span class="co">############################# Estimation of the matrices</span></span>
<span id="cb9-586"><a href="#cb9-586" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-587"><a href="#cb9-587" aria-hidden="true" tabindex="-1"></a>   <span class="co">## g*-sample of size M</span></span>
<span id="cb9-588"><a href="#cb9-588" aria-hidden="true" tabindex="-1"></a>    VA<span class="op">=</span>sp.stats.multivariate_normal(np.zeros(n),np.eye(n))      </span>
<span id="cb9-589"><a href="#cb9-589" aria-hidden="true" tabindex="-1"></a>    X0<span class="op">=</span>VA.rvs(size<span class="op">=</span>M<span class="op">*</span><span class="dv">1000</span>)                   </span>
<span id="cb9-590"><a href="#cb9-590" aria-hidden="true" tabindex="-1"></a>    ind<span class="op">=</span>(phi(X0)<span class="op">&gt;</span><span class="dv">0</span>)          </span>
<span id="cb9-591"><a href="#cb9-591" aria-hidden="true" tabindex="-1"></a>    X1<span class="op">=</span>X0[ind,:]                             </span>
<span id="cb9-592"><a href="#cb9-592" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X1[:M,:]           </span>
<span id="cb9-593"><a href="#cb9-593" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-594"><a href="#cb9-594" aria-hidden="true" tabindex="-1"></a>    R<span class="op">=</span>np.sqrt(np.<span class="bu">sum</span>(X<span class="op">**</span><span class="dv">2</span>,axis<span class="op">=</span><span class="dv">1</span>))   </span>
<span id="cb9-595"><a href="#cb9-595" aria-hidden="true" tabindex="-1"></a>    Xu<span class="op">=</span>(X.T<span class="op">/</span>R).T                </span>
<span id="cb9-596"><a href="#cb9-596" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-597"><a href="#cb9-597" aria-hidden="true" tabindex="-1"></a>   <span class="co">## estimated gaussian mean and covariance </span></span>
<span id="cb9-598"><a href="#cb9-598" aria-hidden="true" tabindex="-1"></a>    mm<span class="op">=</span>np.mean(X,axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb9-599"><a href="#cb9-599" aria-hidden="true" tabindex="-1"></a>    Xc<span class="op">=</span>(X<span class="op">-</span>mm).T</span>
<span id="cb9-600"><a href="#cb9-600" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span>Xc <span class="op">@</span> Xc.T<span class="op">/</span>np.shape(Xc)[<span class="dv">1</span>]  </span>
<span id="cb9-601"><a href="#cb9-601" aria-hidden="true" tabindex="-1"></a>    SI.append(sigma)</span>
<span id="cb9-602"><a href="#cb9-602" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-603"><a href="#cb9-603" aria-hidden="true" tabindex="-1"></a>   <span class="co">## von Mises Fisher parameters</span></span>
<span id="cb9-604"><a href="#cb9-604" aria-hidden="true" tabindex="-1"></a>    normu<span class="op">=</span>np.sqrt(np.mean(Xu,axis<span class="op">=</span><span class="dv">0</span>).dot(np.mean(Xu,axis<span class="op">=</span><span class="dv">0</span>).T))</span>
<span id="cb9-605"><a href="#cb9-605" aria-hidden="true" tabindex="-1"></a>    mu<span class="op">=</span>np.mean(Xu,axis<span class="op">=</span><span class="dv">0</span>)<span class="op">/</span>normu</span>
<span id="cb9-606"><a href="#cb9-606" aria-hidden="true" tabindex="-1"></a>    mu<span class="op">=</span>np.array(mu,ndmin<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb9-607"><a href="#cb9-607" aria-hidden="true" tabindex="-1"></a>    chi<span class="op">=</span><span class="bu">min</span>(normu,<span class="fl">0.95</span>)</span>
<span id="cb9-608"><a href="#cb9-608" aria-hidden="true" tabindex="-1"></a>    kappa<span class="op">=</span>(chi<span class="op">*</span>n<span class="op">-</span>chi<span class="op">**</span><span class="dv">3</span>)<span class="op">/</span>(<span class="dv">1</span><span class="op">-</span>chi<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb9-609"><a href="#cb9-609" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-610"><a href="#cb9-610" aria-hidden="true" tabindex="-1"></a>   <span class="co">## Nakagami parameters</span></span>
<span id="cb9-611"><a href="#cb9-611" aria-hidden="true" tabindex="-1"></a>    omega<span class="op">=</span>np.mean(R<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb9-612"><a href="#cb9-612" aria-hidden="true" tabindex="-1"></a>    tau4<span class="op">=</span>np.mean(R<span class="op">**</span><span class="dv">4</span>)</span>
<span id="cb9-613"><a href="#cb9-613" aria-hidden="true" tabindex="-1"></a>    pp<span class="op">=</span>omega<span class="op">**</span><span class="dv">2</span><span class="op">/</span>(tau4<span class="op">-</span>omega<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb9-614"><a href="#cb9-614" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-615"><a href="#cb9-615" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb9-616"><a href="#cb9-616" aria-hidden="true" tabindex="-1"></a>    Eig<span class="op">=</span>np.linalg.eigh(sigma)                     </span>
<span id="cb9-617"><a href="#cb9-617" aria-hidden="true" tabindex="-1"></a>    logeig<span class="op">=</span>np.sort(np.log(Eig[<span class="dv">0</span>])<span class="op">-</span>Eig[<span class="dv">0</span>])     </span>
<span id="cb9-618"><a href="#cb9-618" aria-hidden="true" tabindex="-1"></a>    delta<span class="op">=</span>np.zeros(<span class="bu">len</span>(logeig)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb9-619"><a href="#cb9-619" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(logeig)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb9-620"><a href="#cb9-620" aria-hidden="true" tabindex="-1"></a>        delta[j]<span class="op">=</span><span class="bu">abs</span>(logeig[j]<span class="op">-</span>logeig[j<span class="op">+</span><span class="dv">1</span>])    </span>
<span id="cb9-621"><a href="#cb9-621" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-622"><a href="#cb9-622" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span>np.argmax(delta)<span class="op">+</span><span class="dv">1</span>         </span>
<span id="cb9-623"><a href="#cb9-623" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-624"><a href="#cb9-624" aria-hidden="true" tabindex="-1"></a>    indi<span class="op">=</span>[]</span>
<span id="cb9-625"><a href="#cb9-625" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb9-626"><a href="#cb9-626" aria-hidden="true" tabindex="-1"></a>        indi.append(np.where(np.log(Eig[<span class="dv">0</span>])<span class="op">-</span>Eig[<span class="dv">0</span>]<span class="op">==</span>logeig[l])[<span class="dv">0</span>][<span class="dv">0</span>])</span>
<span id="cb9-627"><a href="#cb9-627" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-628"><a href="#cb9-628" aria-hidden="true" tabindex="-1"></a>    P1<span class="op">=</span>np.array(Eig[<span class="dv">1</span>][:,indi[<span class="dv">0</span>]],ndmin<span class="op">=</span><span class="dv">2</span>).T</span>
<span id="cb9-629"><a href="#cb9-629" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,k):</span>
<span id="cb9-630"><a href="#cb9-630" aria-hidden="true" tabindex="-1"></a>        P1<span class="op">=</span>np.concatenate((P1,np.array(Eig[<span class="dv">1</span>][:,indi[l]],ndmin<span class="op">=</span><span class="dv">2</span>).T),axis<span class="op">=</span><span class="dv">1</span>)     </span>
<span id="cb9-631"><a href="#cb9-631" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-632"><a href="#cb9-632" aria-hidden="true" tabindex="-1"></a>    diagsi<span class="op">=</span>np.diag(Eig[<span class="dv">0</span>][indi])                           </span>
<span id="cb9-633"><a href="#cb9-633" aria-hidden="true" tabindex="-1"></a>    sig_opt_d<span class="op">=</span>P1.dot((diagsi<span class="op">-</span>np.eye(k))).dot(P1.T)<span class="op">+</span>np.eye(n)</span>
<span id="cb9-634"><a href="#cb9-634" aria-hidden="true" tabindex="-1"></a>    SIP.append(sig_opt_d)</span>
<span id="cb9-635"><a href="#cb9-635" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-636"><a href="#cb9-636" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb9-637"><a href="#cb9-637" aria-hidden="true" tabindex="-1"></a>    diagsist<span class="op">=</span>P1st.T.dot(sigma).dot(P1st)                   </span>
<span id="cb9-638"><a href="#cb9-638" aria-hidden="true" tabindex="-1"></a>    sig_opt<span class="op">=</span>P1st.dot(diagsist<span class="op">-</span>np.eye(k_st)).dot(P1st.T)<span class="op">+</span>np.eye(n)</span>
<span id="cb9-639"><a href="#cb9-639" aria-hidden="true" tabindex="-1"></a>    SIPst.append(sig_opt)</span>
<span id="cb9-640"><a href="#cb9-640" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-641"><a href="#cb9-641" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb9-642"><a href="#cb9-642" aria-hidden="true" tabindex="-1"></a>    Norm_mm<span class="op">=</span>np.linalg.norm(mm)               </span>
<span id="cb9-643"><a href="#cb9-643" aria-hidden="true" tabindex="-1"></a>    normalised_mm<span class="op">=</span>np.array(mm,ndmin<span class="op">=</span><span class="dv">2</span>).T<span class="op">/</span>Norm_mm        </span>
<span id="cb9-644"><a href="#cb9-644" aria-hidden="true" tabindex="-1"></a>    vhat<span class="op">=</span>normalised_mm.T.dot(sigma).dot(normalised_mm)          </span>
<span id="cb9-645"><a href="#cb9-645" aria-hidden="true" tabindex="-1"></a>    sig_mean_d<span class="op">=</span>(vhat<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>normalised_mm.dot(normalised_mm.T)<span class="op">+</span>np.eye(n) </span>
<span id="cb9-646"><a href="#cb9-646" aria-hidden="true" tabindex="-1"></a>    SIM.append(sig_mean_d)</span>
<span id="cb9-647"><a href="#cb9-647" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-648"><a href="#cb9-648" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb9-649"><a href="#cb9-649" aria-hidden="true" tabindex="-1"></a>    Norm_Mstar<span class="op">=</span>np.linalg.norm(Mstar)               </span>
<span id="cb9-650"><a href="#cb9-650" aria-hidden="true" tabindex="-1"></a>    normalised_Mstar<span class="op">=</span>np.array(Mstar,ndmin<span class="op">=</span><span class="dv">2</span>).T<span class="op">/</span>Norm_Mstar   </span>
<span id="cb9-651"><a href="#cb9-651" aria-hidden="true" tabindex="-1"></a>    vhatst<span class="op">=</span>normalised_Mstar.T.dot(sigma).dot(normalised_Mstar)      </span>
<span id="cb9-652"><a href="#cb9-652" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-653"><a href="#cb9-653" aria-hidden="true" tabindex="-1"></a>    sig_mean<span class="op">=</span>(vhatst<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>normalised_Mstar.dot(normalised_Mstar.T)<span class="op">+</span>np.eye(n) </span>
<span id="cb9-654"><a href="#cb9-654" aria-hidden="true" tabindex="-1"></a>    SIMst.append(sig_mean)</span>
<span id="cb9-655"><a href="#cb9-655" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-656"><a href="#cb9-656" aria-hidden="true" tabindex="-1"></a><span class="co">############################################# Estimation of the integral</span></span>
<span id="cb9-657"><a href="#cb9-657" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb9-658"><a href="#cb9-658" aria-hidden="true" tabindex="-1"></a>    Xop<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>Sigstar,size<span class="op">=</span>N)              </span>
<span id="cb9-659"><a href="#cb9-659" aria-hidden="true" tabindex="-1"></a>    wop<span class="op">=</span>mypi(Xop)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xop,mean<span class="op">=</span>mm, cov<span class="op">=</span>Sigstar)       </span>
<span id="cb9-660"><a href="#cb9-660" aria-hidden="true" tabindex="-1"></a>    Eopt[i]<span class="op">=</span>np.mean(wop)                                                     </span>
<span id="cb9-661"><a href="#cb9-661" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-662"><a href="#cb9-662" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb9-663"><a href="#cb9-663" aria-hidden="true" tabindex="-1"></a>    Xis<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sigma,size<span class="op">=</span>N)</span>
<span id="cb9-664"><a href="#cb9-664" aria-hidden="true" tabindex="-1"></a>    wis<span class="op">=</span>mypi(Xis)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xis,mean<span class="op">=</span>mm, cov<span class="op">=</span>sigma)</span>
<span id="cb9-665"><a href="#cb9-665" aria-hidden="true" tabindex="-1"></a>    EIS[i]<span class="op">=</span>np.mean(wis)</span>
<span id="cb9-666"><a href="#cb9-666" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-667"><a href="#cb9-667" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb9-668"><a href="#cb9-668" aria-hidden="true" tabindex="-1"></a>    Xpr<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_opt_d,size<span class="op">=</span>N)</span>
<span id="cb9-669"><a href="#cb9-669" aria-hidden="true" tabindex="-1"></a>    wpr<span class="op">=</span>mypi(Xpr)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xpr,mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_opt_d)</span>
<span id="cb9-670"><a href="#cb9-670" aria-hidden="true" tabindex="-1"></a>    Eprj[i]<span class="op">=</span>np.mean(wpr)</span>
<span id="cb9-671"><a href="#cb9-671" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-672"><a href="#cb9-672" aria-hidden="true" tabindex="-1"></a>   <span class="co">###   </span></span>
<span id="cb9-673"><a href="#cb9-673" aria-hidden="true" tabindex="-1"></a>    Xpm<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_mean_d,size<span class="op">=</span>N)</span>
<span id="cb9-674"><a href="#cb9-674" aria-hidden="true" tabindex="-1"></a>    wpm<span class="op">=</span>mypi(Xpm)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xpm,mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_mean_d)</span>
<span id="cb9-675"><a href="#cb9-675" aria-hidden="true" tabindex="-1"></a>    Eprm[i]<span class="op">=</span>np.mean(wpm)</span>
<span id="cb9-676"><a href="#cb9-676" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-677"><a href="#cb9-677" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb9-678"><a href="#cb9-678" aria-hidden="true" tabindex="-1"></a>    Xprst<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_opt,size<span class="op">=</span>N)</span>
<span id="cb9-679"><a href="#cb9-679" aria-hidden="true" tabindex="-1"></a>    wprst<span class="op">=</span>mypi(Xprst)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xprst,mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_opt)</span>
<span id="cb9-680"><a href="#cb9-680" aria-hidden="true" tabindex="-1"></a>    Eprjst[i]<span class="op">=</span>np.mean(wprst)</span>
<span id="cb9-681"><a href="#cb9-681" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-682"><a href="#cb9-682" aria-hidden="true" tabindex="-1"></a>   <span class="co">###    </span></span>
<span id="cb9-683"><a href="#cb9-683" aria-hidden="true" tabindex="-1"></a>    Xpmst<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_mean,size<span class="op">=</span>N)</span>
<span id="cb9-684"><a href="#cb9-684" aria-hidden="true" tabindex="-1"></a>    wpmst<span class="op">=</span>mypi(Xpmst)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xpmst,mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_mean)</span>
<span id="cb9-685"><a href="#cb9-685" aria-hidden="true" tabindex="-1"></a>    Eprmst[i]<span class="op">=</span>np.mean(wpmst)</span>
<span id="cb9-686"><a href="#cb9-686" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-687"><a href="#cb9-687" aria-hidden="true" tabindex="-1"></a>   <span class="co">###</span></span>
<span id="cb9-688"><a href="#cb9-688" aria-hidden="true" tabindex="-1"></a>    Xvmfn <span class="op">=</span> vMFNM_sample(mu, kappa, omega, pp, <span class="dv">1</span>, N)</span>
<span id="cb9-689"><a href="#cb9-689" aria-hidden="true" tabindex="-1"></a>    Rvn<span class="op">=</span>np.sqrt(np.<span class="bu">sum</span>(Xvmfn<span class="op">**</span><span class="dv">2</span>,axis<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb9-690"><a href="#cb9-690" aria-hidden="true" tabindex="-1"></a>    Xvnu<span class="op">=</span>Xvmfn.T<span class="op">/</span>Rvn</span>
<span id="cb9-691"><a href="#cb9-691" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb9-692"><a href="#cb9-692" aria-hidden="true" tabindex="-1"></a>    h_log<span class="op">=</span>vMF_logpdf(Xvnu,mu.T,kappa)<span class="op">+</span>nakagami_logpdf(Rvn,pp,omega)</span>
<span id="cb9-693"><a href="#cb9-693" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> np.log(n) <span class="op">+</span> np.log(np.pi <span class="op">**</span> (n <span class="op">/</span> <span class="dv">2</span>)) <span class="op">-</span> sp.special.gammaln(n <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb9-694"><a href="#cb9-694" aria-hidden="true" tabindex="-1"></a>    f_u <span class="op">=</span> <span class="op">-</span>A       </span>
<span id="cb9-695"><a href="#cb9-695" aria-hidden="true" tabindex="-1"></a>    f_chi <span class="op">=</span> (np.log(<span class="dv">2</span>) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> n <span class="op">/</span> <span class="dv">2</span>) <span class="op">+</span> np.log(Rvn) <span class="op">*</span> (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> Rvn <span class="op">**</span> <span class="dv">2</span> <span class="op">-</span> sp.special.gammaln(n <span class="op">/</span> <span class="dv">2</span>)) </span>
<span id="cb9-696"><a href="#cb9-696" aria-hidden="true" tabindex="-1"></a>    f_log <span class="op">=</span> f_u <span class="op">+</span> f_chi</span>
<span id="cb9-697"><a href="#cb9-697" aria-hidden="true" tabindex="-1"></a>    W_log <span class="op">=</span> f_log <span class="op">-</span> h_log</span>
<span id="cb9-698"><a href="#cb9-698" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-699"><a href="#cb9-699" aria-hidden="true" tabindex="-1"></a>    wvmfn<span class="op">=</span>(phi(Xvmfn)<span class="op">&gt;</span><span class="dv">0</span>)<span class="op">*</span>np.exp(W_log)          </span>
<span id="cb9-700"><a href="#cb9-700" aria-hidden="true" tabindex="-1"></a>    Evmfn[i]<span class="op">=</span>np.mean(wvmfn)</span>
<span id="cb9-701"><a href="#cb9-701" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-702"><a href="#cb9-702" aria-hidden="true" tabindex="-1"></a><span class="co">### KL divergences    </span></span>
<span id="cb9-703"><a href="#cb9-703" aria-hidden="true" tabindex="-1"></a>dkli<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-704"><a href="#cb9-704" aria-hidden="true" tabindex="-1"></a>dklp<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-705"><a href="#cb9-705" aria-hidden="true" tabindex="-1"></a>dklm<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-706"><a href="#cb9-706" aria-hidden="true" tabindex="-1"></a>dklpst<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-707"><a href="#cb9-707" aria-hidden="true" tabindex="-1"></a>dklmst<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-708"><a href="#cb9-708" aria-hidden="true" tabindex="-1"></a>dklpca<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-709"><a href="#cb9-709" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-710"><a href="#cb9-710" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(B):</span>
<span id="cb9-711"><a href="#cb9-711" aria-hidden="true" tabindex="-1"></a>    dkli[i]<span class="op">=</span>np.log(np.linalg.det(SI[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SI[i]))))      </span>
<span id="cb9-712"><a href="#cb9-712" aria-hidden="true" tabindex="-1"></a>    dklp[i]<span class="op">=</span>np.log(np.linalg.det(SIP[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SIP[i]))))        </span>
<span id="cb9-713"><a href="#cb9-713" aria-hidden="true" tabindex="-1"></a>    dklm[i]<span class="op">=</span>np.log(np.linalg.det(SIM[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SIM[i]))))</span>
<span id="cb9-714"><a href="#cb9-714" aria-hidden="true" tabindex="-1"></a>    dklpst[i]<span class="op">=</span>np.log(np.linalg.det(SIPst[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SIPst[i]))))</span>
<span id="cb9-715"><a href="#cb9-715" aria-hidden="true" tabindex="-1"></a>    dklmst[i]<span class="op">=</span>np.log(np.linalg.det(SIMst[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SIMst[i]))))</span>
<span id="cb9-716"><a href="#cb9-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-717"><a href="#cb9-717" aria-hidden="true" tabindex="-1"></a>Tabresult<span class="op">=</span>np.zeros((<span class="dv">3</span>,<span class="dv">7</span>)) <span class="co"># table of results</span></span>
<span id="cb9-718"><a href="#cb9-718" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-719"><a href="#cb9-719" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">0</span>]<span class="op">=</span>np.log(np.linalg.det(Sigstar))<span class="op">+</span>n</span>
<span id="cb9-720"><a href="#cb9-720" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">1</span>]<span class="op">=</span>np.mean(dkli)</span>
<span id="cb9-721"><a href="#cb9-721" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">2</span>]<span class="op">=</span>np.mean(dklpst)</span>
<span id="cb9-722"><a href="#cb9-722" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">3</span>]<span class="op">=</span>np.mean(dklmst)</span>
<span id="cb9-723"><a href="#cb9-723" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">4</span>]<span class="op">=</span>np.mean(dklp)</span>
<span id="cb9-724"><a href="#cb9-724" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">5</span>]<span class="op">=</span>np.mean(dklm)</span>
<span id="cb9-725"><a href="#cb9-725" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">6</span>]<span class="op">=</span><span class="va">None</span></span>
<span id="cb9-726"><a href="#cb9-726" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-727"><a href="#cb9-727" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">0</span>]<span class="op">=</span>np.mean(Eopt<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-728"><a href="#cb9-728" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">1</span>]<span class="op">=</span>np.mean(EIS<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-729"><a href="#cb9-729" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">2</span>]<span class="op">=</span>np.mean(Eprjst<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-730"><a href="#cb9-730" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">3</span>]<span class="op">=</span>np.mean(Eprmst<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-731"><a href="#cb9-731" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">4</span>]<span class="op">=</span>np.mean(Eprj<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-732"><a href="#cb9-732" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">5</span>]<span class="op">=</span>np.mean(Eprm<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-733"><a href="#cb9-733" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">6</span>]<span class="op">=</span>np.mean(Evmfn<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-734"><a href="#cb9-734" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-735"><a href="#cb9-735" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">0</span>]<span class="op">=</span>np.sqrt(np.mean((Eopt<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-736"><a href="#cb9-736" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">1</span>]<span class="op">=</span>np.sqrt(np.mean((EIS<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-737"><a href="#cb9-737" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">2</span>]<span class="op">=</span>np.sqrt(np.mean((Eprjst<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-738"><a href="#cb9-738" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">3</span>]<span class="op">=</span>np.sqrt(np.mean((Eprmst<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-739"><a href="#cb9-739" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">4</span>]<span class="op">=</span>np.sqrt(np.mean((Eprj<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-740"><a href="#cb9-740" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">5</span>]<span class="op">=</span>np.sqrt(np.mean((Eprm<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-741"><a href="#cb9-741" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">6</span>]<span class="op">=</span>np.sqrt(np.mean((Evmfn<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-742"><a href="#cb9-742" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-743"><a href="#cb9-743" aria-hidden="true" tabindex="-1"></a>Tabresult<span class="op">=</span>np.<span class="bu">round</span>(Tabresult,<span class="dv">1</span>)</span>
<span id="cb9-744"><a href="#cb9-744" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-745"><a href="#cb9-745" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-746"><a href="#cb9-746" aria-hidden="true" tabindex="-1"></a>table<span class="op">=</span>[[<span class="st">"D'"</span>,Tabresult[<span class="dv">0</span>,<span class="dv">0</span>],Tabresult[<span class="dv">0</span>,<span class="dv">1</span>],Tabresult[<span class="dv">0</span>,<span class="dv">2</span>],Tabresult[<span class="dv">0</span>,<span class="dv">3</span>],Tabresult[<span class="dv">0</span>,<span class="dv">4</span>],Tabresult[<span class="dv">0</span>,<span class="dv">5</span>],Tabresult[<span class="dv">0</span>,<span class="dv">6</span>]],</span>
<span id="cb9-747"><a href="#cb9-747" aria-hidden="true" tabindex="-1"></a>      [<span class="st">"Relative error (\%)"</span>,Tabresult[<span class="dv">1</span>,<span class="dv">0</span>],Tabresult[<span class="dv">1</span>,<span class="dv">1</span>],Tabresult[<span class="dv">1</span>,<span class="dv">2</span>],Tabresult[<span class="dv">1</span>,<span class="dv">3</span>],Tabresult[<span class="dv">1</span>,<span class="dv">4</span>],Tabresult[<span class="dv">1</span>,<span class="dv">5</span>],Tabresult[<span class="dv">1</span>,<span class="dv">6</span>]],</span>
<span id="cb9-748"><a href="#cb9-748" aria-hidden="true" tabindex="-1"></a>    [<span class="st">"Coefficient of variation (\%)"</span>,Tabresult[<span class="dv">2</span>,<span class="dv">0</span>],Tabresult[<span class="dv">2</span>,<span class="dv">1</span>],Tabresult[<span class="dv">2</span>,<span class="dv">2</span>],Tabresult[<span class="dv">2</span>,<span class="dv">3</span>],Tabresult[<span class="dv">2</span>,<span class="dv">4</span>],Tabresult[<span class="dv">2</span>,<span class="dv">5</span>],Tabresult[<span class="dv">2</span>,<span class="dv">6</span>]]]</span>
<span id="cb9-749"><a href="#cb9-749" aria-hidden="true" tabindex="-1"></a>Markdown(tabulate(</span>
<span id="cb9-750"><a href="#cb9-750" aria-hidden="true" tabindex="-1"></a>  table, </span>
<span id="cb9-751"><a href="#cb9-751" aria-hidden="true" tabindex="-1"></a>  headers<span class="op">=</span>[<span class="st">""</span>,<span class="st">"$\Sigma^*$"</span>, <span class="st">"$\hat{\Sigma}^*$"</span>, <span class="st">"$\hat{\Sigma}_</span><span class="sc">{opt}</span><span class="st">$"</span>, <span class="st">"$\hat{\Sigma}_</span><span class="sc">{mean}</span><span class="st">$"</span>, <span class="st">"${\hat{\Sigma}^{+d}_</span><span class="sc">{opt}</span><span class="st">}$"</span>, <span class="st">"$\hat{\Sigma}^{+d}_</span><span class="sc">{mean}</span><span class="st">$"</span>, <span class="st">"vMFN"</span>],</span>
<span id="cb9-752"><a href="#cb9-752" aria-hidden="true" tabindex="-1"></a>    tablefmt<span class="op">=</span><span class="st">"pipe"</span>))</span>
<span id="cb9-753"><a href="#cb9-753" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb9-754"><a href="#cb9-754" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-755"><a href="#cb9-755" aria-hidden="true" tabindex="-1"></a><span class="fu">##  Test case 2: projection in 2 directions   {#sec-sub:parabol}    </span></span>
<span id="cb9-756"><a href="#cb9-756" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-757"><a href="#cb9-757" aria-hidden="true" tabindex="-1"></a>The second test case is again a probability estimation, i.e., it is of the form $\phi = \mathbb{I}_{<span class="sc">\{</span>\varphi \geq 0<span class="sc">\}</span>}$ with now the function $\varphi$ having some quadratic terms:</span>
<span id="cb9-758"><a href="#cb9-758" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-759"><a href="#cb9-759" aria-hidden="true" tabindex="-1"></a>    \varphi: \mathbf{x}=(x_1,\ldots,x_n) \in \mathbb{R}^n \mapsto x_1 - 25 x_2^2 - 30 x_3^2 - 1.</span>
<span id="cb9-760"><a href="#cb9-760" aria-hidden="true" tabindex="-1"></a>$$ {#eq-parabol}</span>
<span id="cb9-761"><a href="#cb9-761" aria-hidden="true" tabindex="-1"></a>        The quantity of interest $E$ is defined as $E=\int_{\mathbb{R}^n} \phi(\mathbf{x}) f(\mathbf{x}) \textrm{d}\mathbf{x} = \mathbb{P}_f(\varphi(\mathbf{X})\geq 0)$ for all $n$ where the density $f$ is the standard $n$-dimensional Gaussian distribution. This function is motivated in part because $\mathbf{m}^*$ and $\mathbf{d}^*_1$ are different and also because Algorithm 2 chooses two projection directions. Thus, this is an example where ${\widehat{\Sigma}^{\text{}}_\text{mean}}$ and ${\widehat{\Sigma}^{\text{}}_\text{opt}}$ are significantly different.</span>
<span id="cb9-762"><a href="#cb9-762" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-763"><a href="#cb9-763" aria-hidden="true" tabindex="-1"></a><span class="fu">###  Evolution of the partial KL divergence and spectrum</span></span>
<span id="cb9-764"><a href="#cb9-764" aria-hidden="true" tabindex="-1"></a>We check on @fig-inefficiency-parab-1 that the partial KL divergence obeys the same behavior as for the previous example, namely the one associated with $\widehat{\Sigma}^*$ increases much faster than the ones associated with $\Sigma^*$ and $\widehat \Sigma^*_k$, which again suggests that projecting can improve the situation. Since the function $\varphi$ only depends on the first three variables and is even in $x_2$ and $x_3$, one gets that $\mathbf{m}^* = \alpha </span>
<span id="cb9-765"><a href="#cb9-765" aria-hidden="true" tabindex="-1"></a>    \textbf{e}_1$ with $\alpha = \mathbb{E}(X_1 \mid X_1 \geq 25 X^2_2 + 30 X^2_3 + 1) \approx 1.9$ (here and in the sequel, $\textbf{e}_i$ denotes the $i$th canonical vector of $\mathbb{R}^n$, i.e., all its coordinates are $0$ except the $i$-th one which is equal to one), and that $\Sigma^*$ is diagonal with</span>
<span id="cb9-766"><a href="#cb9-766" aria-hidden="true" tabindex="-1"></a>$$ \Sigma^* =</span>
<span id="cb9-767"><a href="#cb9-767" aria-hidden="true" tabindex="-1"></a>    \begin{pmatrix}</span>
<span id="cb9-768"><a href="#cb9-768" aria-hidden="true" tabindex="-1"></a>    \lambda_1 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 <span class="sc">\\</span></span>
<span id="cb9-769"><a href="#cb9-769" aria-hidden="true" tabindex="-1"></a>    0 &amp; \lambda_2 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 <span class="sc">\\</span></span>
<span id="cb9-770"><a href="#cb9-770" aria-hidden="true" tabindex="-1"></a>    0 &amp; 0 &amp; \lambda_3 &amp; 0 &amp; \cdots &amp; 0 <span class="sc">\\</span></span>
<span id="cb9-771"><a href="#cb9-771" aria-hidden="true" tabindex="-1"></a>    0 &amp; 0 &amp; 0 &amp; 1 &amp; \cdots &amp; 0 <span class="sc">\\</span></span>
<span id="cb9-772"><a href="#cb9-772" aria-hidden="true" tabindex="-1"></a>    \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots <span class="sc">\\</span></span>
<span id="cb9-773"><a href="#cb9-773" aria-hidden="true" tabindex="-1"></a>    0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1 <span class="sc">\\</span></span>
<span id="cb9-774"><a href="#cb9-774" aria-hidden="true" tabindex="-1"></a>    \end{pmatrix}. </span>
<span id="cb9-775"><a href="#cb9-775" aria-hidden="true" tabindex="-1"></a> $$</span>
<span id="cb9-776"><a href="#cb9-776" aria-hidden="true" tabindex="-1"></a>Note that the off-diagonal elements of the submatrix $(\Sigma^*_{ij})_{1 \leq i, j \leq 3}$ are indeed $0$ since they result from integrating an odd function of an odd random variable with an even conditioning. For instance, if $F(x) = \mathbb{P}(30 X^2_3 + 1 \leq x)$, then by conditioning on $(X_1, X_3)$ we obtain</span>
<span id="cb9-777"><a href="#cb9-777" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-778"><a href="#cb9-778" aria-hidden="true" tabindex="-1"></a>    \Sigma^*_{12} = \mathbb{E} \left( (X_1 - \alpha) X_2 \mid X_1 - 25 X_2^2 \geq 30 X^2_3 + 1 \right)<span class="sc">\\</span></span>
<span id="cb9-779"><a href="#cb9-779" aria-hidden="true" tabindex="-1"></a>     = \frac{1}{E} \mathbb{E} \left<span class="co">[</span><span class="ot"> (X_1 - \alpha) \mathbb{E} \left( X_2 F(X_1 - 25 X^2_2) \mid X_1 \right) \right</span><span class="co">]</span></span>
<span id="cb9-780"><a href="#cb9-780" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb9-781"><a href="#cb9-781" aria-hidden="true" tabindex="-1"></a>    which is $0$ as $x_2 F(x_1 - x^2_2)$ is an odd function of $x_2$ for fixed $x_1$, and $X_2$ has an even density. </span>
<span id="cb9-782"><a href="#cb9-782" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-783"><a href="#cb9-783" aria-hidden="true" tabindex="-1"></a>We can numerically compute $\lambda_1 \approx 0.278$, $\lambda_2 \approx 0.009$ and $\lambda_3 \approx 0.0075$. These values correspond to the red squares in @fig-inefficiency-parab-2 which shows that the smallest eigenvalues are properly estimated. Moreover, Algorithm 2 selects the two largest eigenvalues, which have the highest $\ell$-values. These two eigenvalues thus correspond to the eigenvectors $\mathbf{e}_2$ and $\mathbf{e}_3$, and so we see that on this example, the optimal directions predicted by @thm-thm1 are significantly different (actually, orthogonal) from $\mathbf{m}^*$ which is proportional to $\textbf{e}_1$.</span>
<span id="cb9-784"><a href="#cb9-784" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-787"><a href="#cb9-787" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb9-788"><a href="#cb9-788" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-inefficiency-parab</span></span>
<span id="cb9-789"><a href="#cb9-789" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: 'Partial KL divergence and spectrum for the function $\phi = \mathbb{I}_{\varphi \geq 0}$ with $\varphi$ given by @eq-parabol. in dimension $n=100$. Left: same behavior as for the first test case. Right: we now have two eigenvalues that stand out, and the behavior of $\ell$ is such that Algorithm 2 selects $k = 2$ which corresponds to the leftmost two.'</span></span>
<span id="cb9-790"><a href="#cb9-790" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-subcap:</span></span>
<span id="cb9-791"><a href="#cb9-791" aria-hidden="true" tabindex="-1"></a><span class="co">#|   - 'Evolution of the partial KL divergence as the dimension increases, with the optimal covariance matrix $\Sigma^*$ (blue circles), the sample covariance $\widehat{\Sigma}^*$ (red squares), and the projected covariance $\widehat{\Sigma}^*_k$ (black triangles).'</span></span>
<span id="cb9-792"><a href="#cb9-792" aria-hidden="true" tabindex="-1"></a><span class="co">#|   - 'Computation of $\ell(\lambda_i)$ for the eigenvalues of $\Sigma^*$ (red squares) and $\widehat{\Sigma}^*$ (blue crosses) in dimension $n = 100$.'</span></span>
<span id="cb9-793"><a href="#cb9-793" aria-hidden="true" tabindex="-1"></a><span class="co">#| layout-ncol: 2</span></span>
<span id="cb9-794"><a href="#cb9-794" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-795"><a href="#cb9-795" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb9-796"><a href="#cb9-796" aria-hidden="true" tabindex="-1"></a><span class="co"># Figure 3. Evolution of the partial KL divergence and spectrum of the eigenvalues for the test case 2</span></span>
<span id="cb9-797"><a href="#cb9-797" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb9-798"><a href="#cb9-798" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-799"><a href="#cb9-799" aria-hidden="true" tabindex="-1"></a><span class="co">#E=1.51*10**-3</span></span>
<span id="cb9-800"><a href="#cb9-800" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parabol(X):</span>
<span id="cb9-801"><a href="#cb9-801" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span>np.shape(X)[<span class="dv">1</span>]</span>
<span id="cb9-802"><a href="#cb9-802" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(X[:,<span class="dv">0</span>]<span class="op">-</span><span class="dv">25</span><span class="op">*</span>X[:,<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span><span class="op">-</span><span class="dv">30</span><span class="op">*</span>X[:,<span class="dv">2</span>]<span class="op">**</span><span class="dv">2</span><span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb9-803"><a href="#cb9-803" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-804"><a href="#cb9-804" aria-hidden="true" tabindex="-1"></a>bigsample<span class="op">=</span><span class="dv">1</span><span class="op">*</span><span class="dv">10</span><span class="op">**</span><span class="dv">8</span></span>
<span id="cb9-805"><a href="#cb9-805" aria-hidden="true" tabindex="-1"></a>phi<span class="op">=</span>parabol</span>
<span id="cb9-806"><a href="#cb9-806" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-807"><a href="#cb9-807" aria-hidden="true" tabindex="-1"></a>VA0<span class="op">=</span>sp.stats.multivariate_normal(mean<span class="op">=</span>np.zeros(<span class="dv">3</span>),cov<span class="op">=</span>np.eye(<span class="dv">3</span>))</span>
<span id="cb9-808"><a href="#cb9-808" aria-hidden="true" tabindex="-1"></a>X0<span class="op">=</span>VA0.rvs(size<span class="op">=</span>bigsample)</span>
<span id="cb9-809"><a href="#cb9-809" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-810"><a href="#cb9-810" aria-hidden="true" tabindex="-1"></a>ind<span class="op">=</span>(phi(X0)<span class="op">&gt;</span><span class="dv">0</span>)</span>
<span id="cb9-811"><a href="#cb9-811" aria-hidden="true" tabindex="-1"></a>X<span class="op">=</span>X0[ind,:]</span>
<span id="cb9-812"><a href="#cb9-812" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-813"><a href="#cb9-813" aria-hidden="true" tabindex="-1"></a>E<span class="op">=</span><span class="fl">1.51</span><span class="op">*</span><span class="dv">10</span><span class="op">**-</span><span class="dv">3</span>   <span class="co"># reference value of the integral</span></span>
<span id="cb9-814"><a href="#cb9-814" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-815"><a href="#cb9-815" aria-hidden="true" tabindex="-1"></a>Mstar_dim3<span class="op">=</span>np.zeros(<span class="dv">3</span>)</span>
<span id="cb9-816"><a href="#cb9-816" aria-hidden="true" tabindex="-1"></a>Mstar_dim3[<span class="dv">0</span>]<span class="op">=</span>np.mean(X,axis<span class="op">=</span><span class="dv">0</span>)[<span class="dv">0</span>]   <span class="co"># accurate value of optimal mean in dimension 3</span></span>
<span id="cb9-817"><a href="#cb9-817" aria-hidden="true" tabindex="-1"></a>Xc<span class="op">=</span>(X<span class="op">-</span>Mstar_dim3).T</span>
<span id="cb9-818"><a href="#cb9-818" aria-hidden="true" tabindex="-1"></a>Sigstar_dim3<span class="op">=</span>Xc <span class="op">@</span> Xc.T<span class="op">/</span>np.shape(Xc)[<span class="dv">1</span>]    <span class="co"># accurate value of optimal covariance in dimension 3</span></span>
<span id="cb9-819"><a href="#cb9-819" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-820"><a href="#cb9-820" aria-hidden="true" tabindex="-1"></a>DKL<span class="op">=</span>np.zeros(<span class="dv">20</span>)</span>
<span id="cb9-821"><a href="#cb9-821" aria-hidden="true" tabindex="-1"></a>DKLp<span class="op">=</span>np.zeros(<span class="dv">20</span>)</span>
<span id="cb9-822"><a href="#cb9-822" aria-hidden="true" tabindex="-1"></a>DKLm<span class="op">=</span>np.zeros(<span class="dv">20</span>)</span>
<span id="cb9-823"><a href="#cb9-823" aria-hidden="true" tabindex="-1"></a>DKLstar<span class="op">=</span>np.zeros(<span class="dv">20</span>)</span>
<span id="cb9-824"><a href="#cb9-824" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-825"><a href="#cb9-825" aria-hidden="true" tabindex="-1"></a>M<span class="op">=</span><span class="dv">300</span></span>
<span id="cb9-826"><a href="#cb9-826" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-827"><a href="#cb9-827" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>,n<span class="op">+</span><span class="dv">1</span>,<span class="dv">5</span>):</span>
<span id="cb9-828"><a href="#cb9-828" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-829"><a href="#cb9-829" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mstar</span></span>
<span id="cb9-830"><a href="#cb9-830" aria-hidden="true" tabindex="-1"></a>    Mstar<span class="op">=</span>np.zeros(d)</span>
<span id="cb9-831"><a href="#cb9-831" aria-hidden="true" tabindex="-1"></a>    Mstar[:<span class="dv">3</span>]<span class="op">=</span>Mstar_dim3</span>
<span id="cb9-832"><a href="#cb9-832" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sigmastar</span></span>
<span id="cb9-833"><a href="#cb9-833" aria-hidden="true" tabindex="-1"></a>    Sigstar<span class="op">=</span>np.eye(d)</span>
<span id="cb9-834"><a href="#cb9-834" aria-hidden="true" tabindex="-1"></a>    Sigstar[:<span class="dv">3</span>,:<span class="dv">3</span>]<span class="op">=</span>Sigstar_dim3</span>
<span id="cb9-835"><a href="#cb9-835" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-836"><a href="#cb9-836" aria-hidden="true" tabindex="-1"></a>    <span class="co">## g*-sample</span></span>
<span id="cb9-837"><a href="#cb9-837" aria-hidden="true" tabindex="-1"></a>    VA0<span class="op">=</span>sp.stats.multivariate_normal(mean<span class="op">=</span>np.zeros(d),cov<span class="op">=</span>np.eye(d))</span>
<span id="cb9-838"><a href="#cb9-838" aria-hidden="true" tabindex="-1"></a>    X0<span class="op">=</span>VA0.rvs(size<span class="op">=</span>M<span class="op">*</span><span class="dv">1000</span>)</span>
<span id="cb9-839"><a href="#cb9-839" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-840"><a href="#cb9-840" aria-hidden="true" tabindex="-1"></a>    ind<span class="op">=</span>(phi(X0)<span class="op">&gt;</span><span class="dv">0</span>)</span>
<span id="cb9-841"><a href="#cb9-841" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X0[ind,:]</span>
<span id="cb9-842"><a href="#cb9-842" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X[:M,:]</span>
<span id="cb9-843"><a href="#cb9-843" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-844"><a href="#cb9-844" aria-hidden="true" tabindex="-1"></a>    <span class="co">## estimated mean and covariance</span></span>
<span id="cb9-845"><a href="#cb9-845" aria-hidden="true" tabindex="-1"></a>    mm<span class="op">=</span>np.mean(X,axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb9-846"><a href="#cb9-846" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-847"><a href="#cb9-847" aria-hidden="true" tabindex="-1"></a>    Xc<span class="op">=</span>(X<span class="op">-</span>mm).T</span>
<span id="cb9-848"><a href="#cb9-848" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span>Xc <span class="op">@</span> Xc.T<span class="op">/</span>np.shape(Xc)[<span class="dv">1</span>]</span>
<span id="cb9-849"><a href="#cb9-849" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-850"><a href="#cb9-850" aria-hidden="true" tabindex="-1"></a>    <span class="co">## projection with the eigenvalues of sigma</span></span>
<span id="cb9-851"><a href="#cb9-851" aria-hidden="true" tabindex="-1"></a>    Eig<span class="op">=</span>np.linalg.eigh(sigma)</span>
<span id="cb9-852"><a href="#cb9-852" aria-hidden="true" tabindex="-1"></a>    logeig<span class="op">=</span>np.sort(np.log(Eig[<span class="dv">0</span>])<span class="op">-</span>Eig[<span class="dv">0</span>])</span>
<span id="cb9-853"><a href="#cb9-853" aria-hidden="true" tabindex="-1"></a>    delta<span class="op">=</span>np.zeros(<span class="bu">len</span>(logeig)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb9-854"><a href="#cb9-854" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(logeig)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb9-855"><a href="#cb9-855" aria-hidden="true" tabindex="-1"></a>        delta[j]<span class="op">=</span><span class="bu">abs</span>(logeig[j]<span class="op">-</span>logeig[j<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb9-856"><a href="#cb9-856" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-857"><a href="#cb9-857" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span>np.argmax(delta)<span class="op">+</span><span class="dv">1</span>         <span class="co"># biggest gap between the l(lambda_i)</span></span>
<span id="cb9-858"><a href="#cb9-858" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-859"><a href="#cb9-859" aria-hidden="true" tabindex="-1"></a>    indi<span class="op">=</span>[]</span>
<span id="cb9-860"><a href="#cb9-860" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb9-861"><a href="#cb9-861" aria-hidden="true" tabindex="-1"></a>        indi.append(np.where(np.log(Eig[<span class="dv">0</span>])<span class="op">-</span>Eig[<span class="dv">0</span>]<span class="op">==</span>logeig[l])[<span class="dv">0</span>][<span class="dv">0</span>])</span>
<span id="cb9-862"><a href="#cb9-862" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-863"><a href="#cb9-863" aria-hidden="true" tabindex="-1"></a>    P1<span class="op">=</span>np.array(Eig[<span class="dv">1</span>][:,indi[<span class="dv">0</span>]],ndmin<span class="op">=</span><span class="dv">2</span>).T                  </span>
<span id="cb9-864"><a href="#cb9-864" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,k):</span>
<span id="cb9-865"><a href="#cb9-865" aria-hidden="true" tabindex="-1"></a>        P1<span class="op">=</span>np.concatenate((P1,np.array(Eig[<span class="dv">1</span>][:,indi[l]],ndmin<span class="op">=</span><span class="dv">2</span>).T),axis<span class="op">=</span><span class="dv">1</span>)    <span class="co"># matrix od influential directions of projections</span></span>
<span id="cb9-866"><a href="#cb9-866" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-867"><a href="#cb9-867" aria-hidden="true" tabindex="-1"></a>    diagsi<span class="op">=</span>np.diag(Eig[<span class="dv">0</span>][indi])</span>
<span id="cb9-868"><a href="#cb9-868" aria-hidden="true" tabindex="-1"></a>    sig_opt_d<span class="op">=</span>P1.dot((diagsi<span class="op">-</span>np.eye(k))).dot(P1.T)<span class="op">+</span>np.eye(d)  </span>
<span id="cb9-869"><a href="#cb9-869" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-870"><a href="#cb9-870" aria-hidden="true" tabindex="-1"></a>    DKL[<span class="bu">int</span>((d<span class="op">-</span><span class="dv">5</span>)<span class="op">/</span><span class="dv">5</span>)]<span class="op">=</span>np.log(np.linalg.det(sigma))<span class="op">+</span>np.<span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(sigma))))</span>
<span id="cb9-871"><a href="#cb9-871" aria-hidden="true" tabindex="-1"></a>    DKLp[<span class="bu">int</span>((d<span class="op">-</span><span class="dv">5</span>)<span class="op">/</span><span class="dv">5</span>)]<span class="op">=</span>np.log(np.linalg.det(sig_opt_d))<span class="op">+</span>np.<span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(sig_opt_d))))</span>
<span id="cb9-872"><a href="#cb9-872" aria-hidden="true" tabindex="-1"></a>    DKLstar[<span class="bu">int</span>((d<span class="op">-</span><span class="dv">5</span>)<span class="op">/</span><span class="dv">5</span>)]<span class="op">=</span>np.log(np.linalg.det(Sigstar))<span class="op">+</span>d</span>
<span id="cb9-873"><a href="#cb9-873" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-874"><a href="#cb9-874" aria-hidden="true" tabindex="-1"></a><span class="co">#### plot of partial KL divergence</span></span>
<span id="cb9-875"><a href="#cb9-875" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">5</span>,<span class="dv">105</span>,<span class="dv">5</span>),DKL,<span class="st">'rs'</span>,label<span class="op">=</span><span class="vs">r"$D'(\hat{\Sigma}^*)$"</span>)</span>
<span id="cb9-876"><a href="#cb9-876" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">5</span>,<span class="dv">105</span>,<span class="dv">5</span>),DKLp,<span class="st">'k^'</span>,label<span class="op">=</span><span class="vs">r"$D'(\hat{\Sigma}^*_k)$"</span>)</span>
<span id="cb9-877"><a href="#cb9-877" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">5</span>,<span class="dv">105</span>,<span class="dv">5</span>),DKLstar,<span class="st">'bo'</span>,label<span class="op">=</span><span class="vs">r"$D'(\Sigma^*)$"</span>)</span>
<span id="cb9-878"><a href="#cb9-878" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-879"><a href="#cb9-879" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb9-880"><a href="#cb9-880" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Dimension'</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb9-881"><a href="#cb9-881" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="vs">r"Partial KL divergence $D'$"</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb9-882"><a href="#cb9-882" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb9-883"><a href="#cb9-883" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tickLabel <span class="kw">in</span> plt.gca().get_xticklabels() <span class="op">+</span> plt.gca().get_yticklabels():</span>
<span id="cb9-884"><a href="#cb9-884" aria-hidden="true" tabindex="-1"></a>    tickLabel.set_fontsize(<span class="dv">16</span>)</span>
<span id="cb9-885"><a href="#cb9-885" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb9-886"><a href="#cb9-886" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-887"><a href="#cb9-887" aria-hidden="true" tabindex="-1"></a><span class="co">#### plot of the eigenvalues</span></span>
<span id="cb9-888"><a href="#cb9-888" aria-hidden="true" tabindex="-1"></a>Eig1<span class="op">=</span>np.linalg.eigh(sigma)</span>
<span id="cb9-889"><a href="#cb9-889" aria-hidden="true" tabindex="-1"></a>logeig1<span class="op">=</span>np.log(Eig1[<span class="dv">0</span>])<span class="op">-</span>Eig1[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span></span>
<span id="cb9-890"><a href="#cb9-890" aria-hidden="true" tabindex="-1"></a>Table_eigv<span class="op">=</span>np.zeros((n,<span class="dv">2</span>))</span>
<span id="cb9-891"><a href="#cb9-891" aria-hidden="true" tabindex="-1"></a>Table_eigv[:,<span class="dv">0</span>]<span class="op">=</span>Eig1[<span class="dv">0</span>]</span>
<span id="cb9-892"><a href="#cb9-892" aria-hidden="true" tabindex="-1"></a>Table_eigv[:,<span class="dv">1</span>]<span class="op">=-</span>logeig1</span>
<span id="cb9-893"><a href="#cb9-893" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-894"><a href="#cb9-894" aria-hidden="true" tabindex="-1"></a>Eigst<span class="op">=</span>np.linalg.eigh(Sigstar)</span>
<span id="cb9-895"><a href="#cb9-895" aria-hidden="true" tabindex="-1"></a>logeigst<span class="op">=</span>np.log(Eigst[<span class="dv">0</span>])<span class="op">-</span>Eigst[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span></span>
<span id="cb9-896"><a href="#cb9-896" aria-hidden="true" tabindex="-1"></a>Table_eigv_st<span class="op">=</span>np.zeros((n,<span class="dv">2</span>))</span>
<span id="cb9-897"><a href="#cb9-897" aria-hidden="true" tabindex="-1"></a>Table_eigv_st[:,<span class="dv">0</span>]<span class="op">=</span>Eigst[<span class="dv">0</span>]</span>
<span id="cb9-898"><a href="#cb9-898" aria-hidden="true" tabindex="-1"></a>Table_eigv_st[:,<span class="dv">1</span>]<span class="op">=-</span>logeigst</span>
<span id="cb9-899"><a href="#cb9-899" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-900"><a href="#cb9-900" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb9-901"><a href="#cb9-901" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"Eigenvalues $\lambda_i$"</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb9-902"><a href="#cb9-902" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="vs">r"$\ell(\lambda_i)$"</span>,fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb9-903"><a href="#cb9-903" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tickLabel <span class="kw">in</span> plt.gca().get_xticklabels() <span class="op">+</span> plt.gca().get_yticklabels():</span>
<span id="cb9-904"><a href="#cb9-904" aria-hidden="true" tabindex="-1"></a>    tickLabel.set_fontsize(<span class="dv">16</span>)</span>
<span id="cb9-905"><a href="#cb9-905" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-906"><a href="#cb9-906" aria-hidden="true" tabindex="-1"></a>plt.plot(Table_eigv[:,<span class="dv">0</span>],Table_eigv[:,<span class="dv">1</span>],<span class="st">'bx'</span>,label<span class="op">=</span><span class="vs">r"Eigenvalues of $\hat{\Sigma}^*$"</span>)</span>
<span id="cb9-907"><a href="#cb9-907" aria-hidden="true" tabindex="-1"></a>plt.plot(Table_eigv_st[:,<span class="dv">0</span>],Table_eigv_st[:,<span class="dv">1</span>],<span class="st">'rs'</span>,label<span class="op">=</span><span class="vs">r"Eigenvalues of $\Sigma^*$"</span>)</span>
<span id="cb9-908"><a href="#cb9-908" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb9-909"><a href="#cb9-909" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb9-910"><a href="#cb9-910" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb9-911"><a href="#cb9-911" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-912"><a href="#cb9-912" aria-hidden="true" tabindex="-1"></a><span class="fu">###  Numerical results</span></span>
<span id="cb9-913"><a href="#cb9-913" aria-hidden="true" tabindex="-1"></a>The numerical results of our simulations are presented in @tbl-parabol. We remark as before that, when using $\widehat{\Sigma}^*$, the accuracy quickly deteriorates as the dimension increases as shows the coefficient of variation of $84 \%$ in dimension $n = 100$. In contrast, ${\widehat{\Sigma}^{\text{}}_\text{opt}}$ leads to very accurate results, which remain close to optimal up to the same dimension $n = 100$. This behavior is to compare with the evolution of the relative KL divergence: contrary to $\widehat{\Sigma}^*$, ${\widehat{\Sigma}^{\text{}}_\text{opt}}$ gives a partial KL divergence close to optimal in dimension $n = 100$. This confirms that the KL divergence is indeed a good proxy to assess the relevance of an auxiliary density.</span>
<span id="cb9-914"><a href="#cb9-914" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-915"><a href="#cb9-915" aria-hidden="true" tabindex="-1"></a>It is also interesting to note that the direction $\mathbf{m}^*$ improves the situation compared to not projecting (column ${\widehat{\Sigma}^{\text{}}_\text{mean}}$ compared to $\widehat{\Sigma}^*$), but using ${\widehat{\Sigma}^{\text{}}_\text{opt}}$ gives significantly better results, with for instance a coefficient of variation around $3 \%$ for ${\widehat{\Sigma}^{\text{}}_\text{opt}}$ and around $25 \%$ for ${\widehat{\Sigma}^{\text{}}_\text{mean}}$ in dimension $n = 100$. Thus, this confirms our theoretical result that the $\mathbf{d}^*_i$'s are good directions on which to project. </span>
<span id="cb9-916"><a href="#cb9-916" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-917"><a href="#cb9-917" aria-hidden="true" tabindex="-1"></a>Finally, we notice that performing estimations of the projection directions instead of taking the true ones (columns ${\widehat{\Sigma}^{\text{+d}}_\text{opt}}$ vs ${\widehat{\Sigma}^{\text{}}_\text{opt}}$) slightly degrades the situation, making the coefficient of variation increase from $3$ to $7 \%$ even if the accuracy remains satisfactory.</span>
<span id="cb9-918"><a href="#cb9-918" aria-hidden="true" tabindex="-1"></a>    The vMFN model is also not really adapted to this example as it gives results similar to ${\widehat{\Sigma}^{\text{}}_\text{mean}}$. Gaussian density family are more able to fit $g^*$ than vMFN parametric model in this test case.</span>
<span id="cb9-919"><a href="#cb9-919" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-922"><a href="#cb9-922" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb9-923"><a href="#cb9-923" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-parabol</span></span>
<span id="cb9-924"><a href="#cb9-924" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: 'Numerical comparison of the estimation of $E \approx 1.51\cdot 10^{-3}$ considering the Gaussian density with the six covariance matrices defined in @sec-def_cov and the vFMN model, when $\phi = \mathbb{I}_{\{\varphi\geq 0\}}$ with $\varphi$ the quadratic function given by @eq-parabol.'</span></span>
<span id="cb9-925"><a href="#cb9-925" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb9-926"><a href="#cb9-926" aria-hidden="true" tabindex="-1"></a><span class="co"># Table 3. Numerical comparison on test case 2</span></span>
<span id="cb9-927"><a href="#cb9-927" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################################################################</span></span>
<span id="cb9-928"><a href="#cb9-928" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-929"><a href="#cb9-929" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span><span class="dv">100</span>         <span class="co"># dimension</span></span>
<span id="cb9-930"><a href="#cb9-930" aria-hidden="true" tabindex="-1"></a>phi<span class="op">=</span>parabol</span>
<span id="cb9-931"><a href="#cb9-931" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-932"><a href="#cb9-932" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mypi(X):                   </span>
<span id="cb9-933"><a href="#cb9-933" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span>np.shape(X)[<span class="dv">1</span>]</span>
<span id="cb9-934"><a href="#cb9-934" aria-hidden="true" tabindex="-1"></a>    f0<span class="op">=</span>sp.stats.multivariate_normal.pdf(X,mean<span class="op">=</span>np.zeros(n),cov<span class="op">=</span>np.eye(n))</span>
<span id="cb9-935"><a href="#cb9-935" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>((phi(X)<span class="op">&gt;</span><span class="dv">0</span>)<span class="op">*</span>f0)</span>
<span id="cb9-936"><a href="#cb9-936" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-937"><a href="#cb9-937" aria-hidden="true" tabindex="-1"></a>N<span class="op">=</span><span class="dv">2000</span>   </span>
<span id="cb9-938"><a href="#cb9-938" aria-hidden="true" tabindex="-1"></a>M<span class="op">=</span><span class="dv">500</span>   </span>
<span id="cb9-939"><a href="#cb9-939" aria-hidden="true" tabindex="-1"></a>B<span class="op">=</span><span class="dv">50</span>    <span class="co"># number of runs</span></span>
<span id="cb9-940"><a href="#cb9-940" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-941"><a href="#cb9-941" aria-hidden="true" tabindex="-1"></a>Eopt<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-942"><a href="#cb9-942" aria-hidden="true" tabindex="-1"></a>EIS<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-943"><a href="#cb9-943" aria-hidden="true" tabindex="-1"></a>Eprj<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-944"><a href="#cb9-944" aria-hidden="true" tabindex="-1"></a>Eprm<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-945"><a href="#cb9-945" aria-hidden="true" tabindex="-1"></a>Eprjst<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-946"><a href="#cb9-946" aria-hidden="true" tabindex="-1"></a>Eprmst<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-947"><a href="#cb9-947" aria-hidden="true" tabindex="-1"></a>Evmfn<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-948"><a href="#cb9-948" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-949"><a href="#cb9-949" aria-hidden="true" tabindex="-1"></a>SI<span class="op">=</span>[]</span>
<span id="cb9-950"><a href="#cb9-950" aria-hidden="true" tabindex="-1"></a>SIP<span class="op">=</span>[]</span>
<span id="cb9-951"><a href="#cb9-951" aria-hidden="true" tabindex="-1"></a>SIPst<span class="op">=</span>[]</span>
<span id="cb9-952"><a href="#cb9-952" aria-hidden="true" tabindex="-1"></a>SIM<span class="op">=</span>[]</span>
<span id="cb9-953"><a href="#cb9-953" aria-hidden="true" tabindex="-1"></a>SIMst<span class="op">=</span>[]</span>
<span id="cb9-954"><a href="#cb9-954" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-955"><a href="#cb9-955" aria-hidden="true" tabindex="-1"></a>bigsample<span class="op">=</span><span class="dv">1</span><span class="op">*</span><span class="dv">10</span><span class="op">**</span><span class="dv">8</span></span>
<span id="cb9-956"><a href="#cb9-956" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-957"><a href="#cb9-957" aria-hidden="true" tabindex="-1"></a>VA0<span class="op">=</span>sp.stats.multivariate_normal(mean<span class="op">=</span>np.zeros(<span class="dv">3</span>),cov<span class="op">=</span>np.eye(<span class="dv">3</span>))</span>
<span id="cb9-958"><a href="#cb9-958" aria-hidden="true" tabindex="-1"></a>X0<span class="op">=</span>VA0.rvs(size<span class="op">=</span>bigsample)</span>
<span id="cb9-959"><a href="#cb9-959" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-960"><a href="#cb9-960" aria-hidden="true" tabindex="-1"></a>ind<span class="op">=</span>(phi(X0)<span class="op">&gt;</span><span class="dv">0</span>)</span>
<span id="cb9-961"><a href="#cb9-961" aria-hidden="true" tabindex="-1"></a>X<span class="op">=</span>X0[ind,:]</span>
<span id="cb9-962"><a href="#cb9-962" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-963"><a href="#cb9-963" aria-hidden="true" tabindex="-1"></a>E<span class="op">=</span><span class="fl">1.51</span><span class="op">*</span><span class="dv">10</span><span class="op">**-</span><span class="dv">3</span>   <span class="co"># reference value of the integral</span></span>
<span id="cb9-964"><a href="#cb9-964" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-965"><a href="#cb9-965" aria-hidden="true" tabindex="-1"></a>Mstar_dim3<span class="op">=</span>np.zeros(<span class="dv">3</span>)</span>
<span id="cb9-966"><a href="#cb9-966" aria-hidden="true" tabindex="-1"></a>Mstar_dim3[<span class="dv">0</span>]<span class="op">=</span>np.mean(X,axis<span class="op">=</span><span class="dv">0</span>)[<span class="dv">0</span>]   <span class="co"># accurate value of optimal mean in dimension 3</span></span>
<span id="cb9-967"><a href="#cb9-967" aria-hidden="true" tabindex="-1"></a>Xc<span class="op">=</span>(X<span class="op">-</span>Mstar_dim3).T</span>
<span id="cb9-968"><a href="#cb9-968" aria-hidden="true" tabindex="-1"></a>Sigstar_dim3<span class="op">=</span>Xc <span class="op">@</span> Xc.T<span class="op">/</span>np.shape(Xc)[<span class="dv">1</span>]    <span class="co"># accurate value of optimal covariance in dimension 3</span></span>
<span id="cb9-969"><a href="#cb9-969" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-970"><a href="#cb9-970" aria-hidden="true" tabindex="-1"></a><span class="co"># Mstar</span></span>
<span id="cb9-971"><a href="#cb9-971" aria-hidden="true" tabindex="-1"></a>Mstar<span class="op">=</span>np.zeros(n)</span>
<span id="cb9-972"><a href="#cb9-972" aria-hidden="true" tabindex="-1"></a>Mstar[:<span class="dv">3</span>]<span class="op">=</span>Mstar_dim3</span>
<span id="cb9-973"><a href="#cb9-973" aria-hidden="true" tabindex="-1"></a><span class="co"># Sigmastar</span></span>
<span id="cb9-974"><a href="#cb9-974" aria-hidden="true" tabindex="-1"></a>Sigstar<span class="op">=</span>np.eye(n)</span>
<span id="cb9-975"><a href="#cb9-975" aria-hidden="true" tabindex="-1"></a>Sigstar[:<span class="dv">3</span>,:<span class="dv">3</span>]<span class="op">=</span>Sigstar_dim3</span>
<span id="cb9-976"><a href="#cb9-976" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-977"><a href="#cb9-977" aria-hidden="true" tabindex="-1"></a>Eigst<span class="op">=</span>np.linalg.eigh(Sigstar)                        </span>
<span id="cb9-978"><a href="#cb9-978" aria-hidden="true" tabindex="-1"></a>logeigst<span class="op">=</span>np.sort(np.log(Eigst[<span class="dv">0</span>])<span class="op">-</span>Eigst[<span class="dv">0</span>])         </span>
<span id="cb9-979"><a href="#cb9-979" aria-hidden="true" tabindex="-1"></a>deltast<span class="op">=</span>np.zeros(<span class="bu">len</span>(logeigst)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb9-980"><a href="#cb9-980" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-981"><a href="#cb9-981" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(logeigst)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb9-982"><a href="#cb9-982" aria-hidden="true" tabindex="-1"></a>    deltast[i]<span class="op">=</span><span class="bu">abs</span>(logeigst[i]<span class="op">-</span>logeigst[i<span class="op">+</span><span class="dv">1</span>])         </span>
<span id="cb9-983"><a href="#cb9-983" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-984"><a href="#cb9-984" aria-hidden="true" tabindex="-1"></a><span class="co">## choice of the number of dimension</span></span>
<span id="cb9-985"><a href="#cb9-985" aria-hidden="true" tabindex="-1"></a>k_st<span class="op">=</span>np.argmax(deltast)<span class="op">+</span><span class="dv">1</span>     </span>
<span id="cb9-986"><a href="#cb9-986" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-987"><a href="#cb9-987" aria-hidden="true" tabindex="-1"></a>indist<span class="op">=</span>[]</span>
<span id="cb9-988"><a href="#cb9-988" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(k_st):</span>
<span id="cb9-989"><a href="#cb9-989" aria-hidden="true" tabindex="-1"></a>    indist.append(np.where(np.log(Eigst[<span class="dv">0</span>])<span class="op">-</span>Eigst[<span class="dv">0</span>]<span class="op">==</span>logeigst[i])[<span class="dv">0</span>][<span class="dv">0</span>])           </span>
<span id="cb9-990"><a href="#cb9-990" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-991"><a href="#cb9-991" aria-hidden="true" tabindex="-1"></a>P1st<span class="op">=</span>np.array(Eigst[<span class="dv">1</span>][:,indist[<span class="dv">0</span>]],ndmin<span class="op">=</span><span class="dv">2</span>).T                          </span>
<span id="cb9-992"><a href="#cb9-992" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,k_st):</span>
<span id="cb9-993"><a href="#cb9-993" aria-hidden="true" tabindex="-1"></a>    P1st<span class="op">=</span>np.concatenate((P1st,np.array(Eigst[<span class="dv">1</span>][:,indist[i]],ndmin<span class="op">=</span><span class="dv">2</span>).T),axis<span class="op">=</span><span class="dv">1</span>)       <span class="co"># matrix of influential directions</span></span>
<span id="cb9-994"><a href="#cb9-994" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-995"><a href="#cb9-995" aria-hidden="true" tabindex="-1"></a><span class="co">#np.random.seed(0)</span></span>
<span id="cb9-996"><a href="#cb9-996" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(B):</span>
<span id="cb9-997"><a href="#cb9-997" aria-hidden="true" tabindex="-1"></a><span class="co">############################# Estimation of the matrices</span></span>
<span id="cb9-998"><a href="#cb9-998" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-999"><a href="#cb9-999" aria-hidden="true" tabindex="-1"></a>   <span class="co">## g*-sample of size M</span></span>
<span id="cb9-1000"><a href="#cb9-1000" aria-hidden="true" tabindex="-1"></a>    VA<span class="op">=</span>sp.stats.multivariate_normal(np.zeros(n),np.eye(n))      </span>
<span id="cb9-1001"><a href="#cb9-1001" aria-hidden="true" tabindex="-1"></a>    X0<span class="op">=</span>VA.rvs(size<span class="op">=</span>M<span class="op">*</span><span class="dv">1000</span>)                   </span>
<span id="cb9-1002"><a href="#cb9-1002" aria-hidden="true" tabindex="-1"></a>    ind<span class="op">=</span>(phi(X0)<span class="op">&gt;</span><span class="dv">0</span>)          </span>
<span id="cb9-1003"><a href="#cb9-1003" aria-hidden="true" tabindex="-1"></a>    X1<span class="op">=</span>X0[ind,:]                             </span>
<span id="cb9-1004"><a href="#cb9-1004" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X1[:M,:]           </span>
<span id="cb9-1005"><a href="#cb9-1005" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-1006"><a href="#cb9-1006" aria-hidden="true" tabindex="-1"></a>    R<span class="op">=</span>np.sqrt(np.<span class="bu">sum</span>(X<span class="op">**</span><span class="dv">2</span>,axis<span class="op">=</span><span class="dv">1</span>))   </span>
<span id="cb9-1007"><a href="#cb9-1007" aria-hidden="true" tabindex="-1"></a>    Xu<span class="op">=</span>(X.T<span class="op">/</span>R).T                </span>
<span id="cb9-1008"><a href="#cb9-1008" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-1009"><a href="#cb9-1009" aria-hidden="true" tabindex="-1"></a>   <span class="co">## estimated gaussian mean and covariance </span></span>
<span id="cb9-1010"><a href="#cb9-1010" aria-hidden="true" tabindex="-1"></a>    mm<span class="op">=</span>np.mean(X,axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb9-1011"><a href="#cb9-1011" aria-hidden="true" tabindex="-1"></a>    Xc<span class="op">=</span>(X<span class="op">-</span>mm).T</span>
<span id="cb9-1012"><a href="#cb9-1012" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span>Xc <span class="op">@</span> Xc.T<span class="op">/</span>np.shape(Xc)[<span class="dv">1</span>]  </span>
<span id="cb9-1013"><a href="#cb9-1013" aria-hidden="true" tabindex="-1"></a>    SI.append(sigma)</span>
<span id="cb9-1014"><a href="#cb9-1014" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-1015"><a href="#cb9-1015" aria-hidden="true" tabindex="-1"></a>   <span class="co">## von Mises Fisher parameters</span></span>
<span id="cb9-1016"><a href="#cb9-1016" aria-hidden="true" tabindex="-1"></a>    normu<span class="op">=</span>np.sqrt(np.mean(Xu,axis<span class="op">=</span><span class="dv">0</span>).dot(np.mean(Xu,axis<span class="op">=</span><span class="dv">0</span>).T))</span>
<span id="cb9-1017"><a href="#cb9-1017" aria-hidden="true" tabindex="-1"></a>    mu<span class="op">=</span>np.mean(Xu,axis<span class="op">=</span><span class="dv">0</span>)<span class="op">/</span>normu</span>
<span id="cb9-1018"><a href="#cb9-1018" aria-hidden="true" tabindex="-1"></a>    mu<span class="op">=</span>np.array(mu,ndmin<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb9-1019"><a href="#cb9-1019" aria-hidden="true" tabindex="-1"></a>    chi<span class="op">=</span><span class="bu">min</span>(normu,<span class="fl">0.95</span>)</span>
<span id="cb9-1020"><a href="#cb9-1020" aria-hidden="true" tabindex="-1"></a>    kappa<span class="op">=</span>(chi<span class="op">*</span>n<span class="op">-</span>chi<span class="op">**</span><span class="dv">3</span>)<span class="op">/</span>(<span class="dv">1</span><span class="op">-</span>chi<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb9-1021"><a href="#cb9-1021" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-1022"><a href="#cb9-1022" aria-hidden="true" tabindex="-1"></a>   <span class="co">## Nakagami parameters</span></span>
<span id="cb9-1023"><a href="#cb9-1023" aria-hidden="true" tabindex="-1"></a>    omega<span class="op">=</span>np.mean(R<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb9-1024"><a href="#cb9-1024" aria-hidden="true" tabindex="-1"></a>    tau4<span class="op">=</span>np.mean(R<span class="op">**</span><span class="dv">4</span>)</span>
<span id="cb9-1025"><a href="#cb9-1025" aria-hidden="true" tabindex="-1"></a>    pp<span class="op">=</span>omega<span class="op">**</span><span class="dv">2</span><span class="op">/</span>(tau4<span class="op">-</span>omega<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb9-1026"><a href="#cb9-1026" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-1027"><a href="#cb9-1027" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb9-1028"><a href="#cb9-1028" aria-hidden="true" tabindex="-1"></a>    Eig<span class="op">=</span>np.linalg.eigh(sigma)                     </span>
<span id="cb9-1029"><a href="#cb9-1029" aria-hidden="true" tabindex="-1"></a>    logeig<span class="op">=</span>np.sort(np.log(Eig[<span class="dv">0</span>])<span class="op">-</span>Eig[<span class="dv">0</span>])     </span>
<span id="cb9-1030"><a href="#cb9-1030" aria-hidden="true" tabindex="-1"></a>    delta<span class="op">=</span>np.zeros(<span class="bu">len</span>(logeig)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb9-1031"><a href="#cb9-1031" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(logeig)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb9-1032"><a href="#cb9-1032" aria-hidden="true" tabindex="-1"></a>        delta[j]<span class="op">=</span><span class="bu">abs</span>(logeig[j]<span class="op">-</span>logeig[j<span class="op">+</span><span class="dv">1</span>])    </span>
<span id="cb9-1033"><a href="#cb9-1033" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-1034"><a href="#cb9-1034" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span>np.argmax(delta)<span class="op">+</span><span class="dv">1</span>         </span>
<span id="cb9-1035"><a href="#cb9-1035" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-1036"><a href="#cb9-1036" aria-hidden="true" tabindex="-1"></a>    indi<span class="op">=</span>[]</span>
<span id="cb9-1037"><a href="#cb9-1037" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb9-1038"><a href="#cb9-1038" aria-hidden="true" tabindex="-1"></a>        indi.append(np.where(np.log(Eig[<span class="dv">0</span>])<span class="op">-</span>Eig[<span class="dv">0</span>]<span class="op">==</span>logeig[l])[<span class="dv">0</span>][<span class="dv">0</span>])</span>
<span id="cb9-1039"><a href="#cb9-1039" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-1040"><a href="#cb9-1040" aria-hidden="true" tabindex="-1"></a>    P1<span class="op">=</span>np.array(Eig[<span class="dv">1</span>][:,indi[<span class="dv">0</span>]],ndmin<span class="op">=</span><span class="dv">2</span>).T</span>
<span id="cb9-1041"><a href="#cb9-1041" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,k):</span>
<span id="cb9-1042"><a href="#cb9-1042" aria-hidden="true" tabindex="-1"></a>        P1<span class="op">=</span>np.concatenate((P1,np.array(Eig[<span class="dv">1</span>][:,indi[l]],ndmin<span class="op">=</span><span class="dv">2</span>).T),axis<span class="op">=</span><span class="dv">1</span>)     </span>
<span id="cb9-1043"><a href="#cb9-1043" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-1044"><a href="#cb9-1044" aria-hidden="true" tabindex="-1"></a>    diagsi<span class="op">=</span>np.diag(Eig[<span class="dv">0</span>][indi])                           </span>
<span id="cb9-1045"><a href="#cb9-1045" aria-hidden="true" tabindex="-1"></a>    sig_opt_d<span class="op">=</span>P1.dot((diagsi<span class="op">-</span>np.eye(k))).dot(P1.T)<span class="op">+</span>np.eye(n)</span>
<span id="cb9-1046"><a href="#cb9-1046" aria-hidden="true" tabindex="-1"></a>    SIP.append(sig_opt_d)</span>
<span id="cb9-1047"><a href="#cb9-1047" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-1048"><a href="#cb9-1048" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb9-1049"><a href="#cb9-1049" aria-hidden="true" tabindex="-1"></a>    diagsist<span class="op">=</span>P1st.T.dot(sigma).dot(P1st)                   </span>
<span id="cb9-1050"><a href="#cb9-1050" aria-hidden="true" tabindex="-1"></a>    sig_opt<span class="op">=</span>P1st.dot(diagsist<span class="op">-</span>np.eye(k_st)).dot(P1st.T)<span class="op">+</span>np.eye(n)</span>
<span id="cb9-1051"><a href="#cb9-1051" aria-hidden="true" tabindex="-1"></a>    SIPst.append(sig_opt)</span>
<span id="cb9-1052"><a href="#cb9-1052" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-1053"><a href="#cb9-1053" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb9-1054"><a href="#cb9-1054" aria-hidden="true" tabindex="-1"></a>    Norm_mm<span class="op">=</span>np.linalg.norm(mm)               </span>
<span id="cb9-1055"><a href="#cb9-1055" aria-hidden="true" tabindex="-1"></a>    normalised_mm<span class="op">=</span>np.array(mm,ndmin<span class="op">=</span><span class="dv">2</span>).T<span class="op">/</span>Norm_mm        </span>
<span id="cb9-1056"><a href="#cb9-1056" aria-hidden="true" tabindex="-1"></a>    vhat<span class="op">=</span>normalised_mm.T.dot(sigma).dot(normalised_mm)          </span>
<span id="cb9-1057"><a href="#cb9-1057" aria-hidden="true" tabindex="-1"></a>    sig_mean_d<span class="op">=</span>(vhat<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>normalised_mm.dot(normalised_mm.T)<span class="op">+</span>np.eye(n) </span>
<span id="cb9-1058"><a href="#cb9-1058" aria-hidden="true" tabindex="-1"></a>    SIM.append(sig_mean_d)</span>
<span id="cb9-1059"><a href="#cb9-1059" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-1060"><a href="#cb9-1060" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb9-1061"><a href="#cb9-1061" aria-hidden="true" tabindex="-1"></a>    Norm_Mstar<span class="op">=</span>np.linalg.norm(Mstar)               </span>
<span id="cb9-1062"><a href="#cb9-1062" aria-hidden="true" tabindex="-1"></a>    normalised_Mstar<span class="op">=</span>np.array(Mstar,ndmin<span class="op">=</span><span class="dv">2</span>).T<span class="op">/</span>Norm_Mstar   </span>
<span id="cb9-1063"><a href="#cb9-1063" aria-hidden="true" tabindex="-1"></a>    vhatst<span class="op">=</span>normalised_Mstar.T.dot(sigma).dot(normalised_Mstar)      </span>
<span id="cb9-1064"><a href="#cb9-1064" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-1065"><a href="#cb9-1065" aria-hidden="true" tabindex="-1"></a>    sig_mean<span class="op">=</span>(vhatst<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>normalised_Mstar.dot(normalised_Mstar.T)<span class="op">+</span>np.eye(n) </span>
<span id="cb9-1066"><a href="#cb9-1066" aria-hidden="true" tabindex="-1"></a>    SIMst.append(sig_mean)</span>
<span id="cb9-1067"><a href="#cb9-1067" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-1068"><a href="#cb9-1068" aria-hidden="true" tabindex="-1"></a><span class="co">############################################# Estimation of the integral</span></span>
<span id="cb9-1069"><a href="#cb9-1069" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb9-1070"><a href="#cb9-1070" aria-hidden="true" tabindex="-1"></a>    Xop<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>Sigstar,size<span class="op">=</span>N)              </span>
<span id="cb9-1071"><a href="#cb9-1071" aria-hidden="true" tabindex="-1"></a>    wop<span class="op">=</span>mypi(Xop)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xop,mean<span class="op">=</span>mm, cov<span class="op">=</span>Sigstar)       </span>
<span id="cb9-1072"><a href="#cb9-1072" aria-hidden="true" tabindex="-1"></a>    Eopt[i]<span class="op">=</span>np.mean(wop)                                                     </span>
<span id="cb9-1073"><a href="#cb9-1073" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-1074"><a href="#cb9-1074" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb9-1075"><a href="#cb9-1075" aria-hidden="true" tabindex="-1"></a>    Xis<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sigma,size<span class="op">=</span>N)</span>
<span id="cb9-1076"><a href="#cb9-1076" aria-hidden="true" tabindex="-1"></a>    wis<span class="op">=</span>mypi(Xis)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xis,mean<span class="op">=</span>mm, cov<span class="op">=</span>sigma)</span>
<span id="cb9-1077"><a href="#cb9-1077" aria-hidden="true" tabindex="-1"></a>    EIS[i]<span class="op">=</span>np.mean(wis)</span>
<span id="cb9-1078"><a href="#cb9-1078" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-1079"><a href="#cb9-1079" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb9-1080"><a href="#cb9-1080" aria-hidden="true" tabindex="-1"></a>    Xpr<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_opt_d,size<span class="op">=</span>N)</span>
<span id="cb9-1081"><a href="#cb9-1081" aria-hidden="true" tabindex="-1"></a>    wpr<span class="op">=</span>mypi(Xpr)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xpr,mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_opt_d)</span>
<span id="cb9-1082"><a href="#cb9-1082" aria-hidden="true" tabindex="-1"></a>    Eprj[i]<span class="op">=</span>np.mean(wpr)</span>
<span id="cb9-1083"><a href="#cb9-1083" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-1084"><a href="#cb9-1084" aria-hidden="true" tabindex="-1"></a>   <span class="co">###   </span></span>
<span id="cb9-1085"><a href="#cb9-1085" aria-hidden="true" tabindex="-1"></a>    Xpm<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_mean_d,size<span class="op">=</span>N)</span>
<span id="cb9-1086"><a href="#cb9-1086" aria-hidden="true" tabindex="-1"></a>    wpm<span class="op">=</span>mypi(Xpm)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xpm,mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_mean_d)</span>
<span id="cb9-1087"><a href="#cb9-1087" aria-hidden="true" tabindex="-1"></a>    Eprm[i]<span class="op">=</span>np.mean(wpm)</span>
<span id="cb9-1088"><a href="#cb9-1088" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-1089"><a href="#cb9-1089" aria-hidden="true" tabindex="-1"></a>   <span class="co">### </span></span>
<span id="cb9-1090"><a href="#cb9-1090" aria-hidden="true" tabindex="-1"></a>    Xprst<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_opt,size<span class="op">=</span>N)</span>
<span id="cb9-1091"><a href="#cb9-1091" aria-hidden="true" tabindex="-1"></a>    wprst<span class="op">=</span>mypi(Xprst)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xprst,mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_opt)</span>
<span id="cb9-1092"><a href="#cb9-1092" aria-hidden="true" tabindex="-1"></a>    Eprjst[i]<span class="op">=</span>np.mean(wprst)</span>
<span id="cb9-1093"><a href="#cb9-1093" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-1094"><a href="#cb9-1094" aria-hidden="true" tabindex="-1"></a>   <span class="co">###    </span></span>
<span id="cb9-1095"><a href="#cb9-1095" aria-hidden="true" tabindex="-1"></a>    Xpmst<span class="op">=</span>sp.stats.multivariate_normal.rvs(mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_mean,size<span class="op">=</span>N)</span>
<span id="cb9-1096"><a href="#cb9-1096" aria-hidden="true" tabindex="-1"></a>    wpmst<span class="op">=</span>mypi(Xpmst)<span class="op">/</span>sp.stats.multivariate_normal.pdf(Xpmst,mean<span class="op">=</span>mm, cov<span class="op">=</span>sig_mean)</span>
<span id="cb9-1097"><a href="#cb9-1097" aria-hidden="true" tabindex="-1"></a>    Eprmst[i]<span class="op">=</span>np.mean(wpmst)</span>
<span id="cb9-1098"><a href="#cb9-1098" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-1099"><a href="#cb9-1099" aria-hidden="true" tabindex="-1"></a>   <span class="co">###</span></span>
<span id="cb9-1100"><a href="#cb9-1100" aria-hidden="true" tabindex="-1"></a>    Xvmfn <span class="op">=</span> vMFNM_sample(mu, kappa, omega, pp, <span class="dv">1</span>, N)</span>
<span id="cb9-1101"><a href="#cb9-1101" aria-hidden="true" tabindex="-1"></a>    Rvn<span class="op">=</span>np.sqrt(np.<span class="bu">sum</span>(Xvmfn<span class="op">**</span><span class="dv">2</span>,axis<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb9-1102"><a href="#cb9-1102" aria-hidden="true" tabindex="-1"></a>    Xvnu<span class="op">=</span>Xvmfn.T<span class="op">/</span>Rvn</span>
<span id="cb9-1103"><a href="#cb9-1103" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb9-1104"><a href="#cb9-1104" aria-hidden="true" tabindex="-1"></a>    h_log<span class="op">=</span>vMF_logpdf(Xvnu,mu.T,kappa)<span class="op">+</span>nakagami_logpdf(Rvn,pp,omega)</span>
<span id="cb9-1105"><a href="#cb9-1105" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> np.log(n) <span class="op">+</span> np.log(np.pi <span class="op">**</span> (n <span class="op">/</span> <span class="dv">2</span>)) <span class="op">-</span> sp.special.gammaln(n <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb9-1106"><a href="#cb9-1106" aria-hidden="true" tabindex="-1"></a>    f_u <span class="op">=</span> <span class="op">-</span>A       </span>
<span id="cb9-1107"><a href="#cb9-1107" aria-hidden="true" tabindex="-1"></a>    f_chi <span class="op">=</span> (np.log(<span class="dv">2</span>) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> n <span class="op">/</span> <span class="dv">2</span>) <span class="op">+</span> np.log(Rvn) <span class="op">*</span> (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> Rvn <span class="op">**</span> <span class="dv">2</span> <span class="op">-</span> sp.special.gammaln(n <span class="op">/</span> <span class="dv">2</span>)) </span>
<span id="cb9-1108"><a href="#cb9-1108" aria-hidden="true" tabindex="-1"></a>    f_log <span class="op">=</span> f_u <span class="op">+</span> f_chi</span>
<span id="cb9-1109"><a href="#cb9-1109" aria-hidden="true" tabindex="-1"></a>    W_log <span class="op">=</span> f_log <span class="op">-</span> h_log</span>
<span id="cb9-1110"><a href="#cb9-1110" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-1111"><a href="#cb9-1111" aria-hidden="true" tabindex="-1"></a>    wvmfn<span class="op">=</span>(phi(Xvmfn)<span class="op">&gt;</span><span class="dv">0</span>)<span class="op">*</span>np.exp(W_log)          </span>
<span id="cb9-1112"><a href="#cb9-1112" aria-hidden="true" tabindex="-1"></a>    Evmfn[i]<span class="op">=</span>np.mean(wvmfn)</span>
<span id="cb9-1113"><a href="#cb9-1113" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-1114"><a href="#cb9-1114" aria-hidden="true" tabindex="-1"></a><span class="co">### KL divergences    </span></span>
<span id="cb9-1115"><a href="#cb9-1115" aria-hidden="true" tabindex="-1"></a>dkli<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-1116"><a href="#cb9-1116" aria-hidden="true" tabindex="-1"></a>dklp<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-1117"><a href="#cb9-1117" aria-hidden="true" tabindex="-1"></a>dklm<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-1118"><a href="#cb9-1118" aria-hidden="true" tabindex="-1"></a>dklpst<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-1119"><a href="#cb9-1119" aria-hidden="true" tabindex="-1"></a>dklmst<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-1120"><a href="#cb9-1120" aria-hidden="true" tabindex="-1"></a>dklpca<span class="op">=</span>np.zeros(B)</span>
<span id="cb9-1121"><a href="#cb9-1121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-1122"><a href="#cb9-1122" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(B):</span>
<span id="cb9-1123"><a href="#cb9-1123" aria-hidden="true" tabindex="-1"></a>    dkli[i]<span class="op">=</span>np.log(np.linalg.det(SI[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SI[i]))))      </span>
<span id="cb9-1124"><a href="#cb9-1124" aria-hidden="true" tabindex="-1"></a>    dklp[i]<span class="op">=</span>np.log(np.linalg.det(SIP[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SIP[i]))))        </span>
<span id="cb9-1125"><a href="#cb9-1125" aria-hidden="true" tabindex="-1"></a>    dklm[i]<span class="op">=</span>np.log(np.linalg.det(SIM[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SIM[i]))))</span>
<span id="cb9-1126"><a href="#cb9-1126" aria-hidden="true" tabindex="-1"></a>    dklpst[i]<span class="op">=</span>np.log(np.linalg.det(SIPst[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SIPst[i]))))</span>
<span id="cb9-1127"><a href="#cb9-1127" aria-hidden="true" tabindex="-1"></a>    dklmst[i]<span class="op">=</span>np.log(np.linalg.det(SIMst[i]))<span class="op">+</span><span class="bu">sum</span>(np.diag(Sigstar.dot(np.linalg.inv(SIMst[i]))))</span>
<span id="cb9-1128"><a href="#cb9-1128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-1129"><a href="#cb9-1129" aria-hidden="true" tabindex="-1"></a>Tabresult<span class="op">=</span>np.zeros((<span class="dv">3</span>,<span class="dv">7</span>)) <span class="co"># table of results</span></span>
<span id="cb9-1130"><a href="#cb9-1130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-1131"><a href="#cb9-1131" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">0</span>]<span class="op">=</span>np.log(np.linalg.det(Sigstar))<span class="op">+</span>n</span>
<span id="cb9-1132"><a href="#cb9-1132" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">1</span>]<span class="op">=</span>np.mean(dkli)</span>
<span id="cb9-1133"><a href="#cb9-1133" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">2</span>]<span class="op">=</span>np.mean(dklpst)</span>
<span id="cb9-1134"><a href="#cb9-1134" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">3</span>]<span class="op">=</span>np.mean(dklmst)</span>
<span id="cb9-1135"><a href="#cb9-1135" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">4</span>]<span class="op">=</span>np.mean(dklp)</span>
<span id="cb9-1136"><a href="#cb9-1136" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">5</span>]<span class="op">=</span>np.mean(dklm)</span>
<span id="cb9-1137"><a href="#cb9-1137" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">0</span>,<span class="dv">6</span>]<span class="op">=</span><span class="va">None</span></span>
<span id="cb9-1138"><a href="#cb9-1138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-1139"><a href="#cb9-1139" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">0</span>]<span class="op">=</span>np.mean(Eopt<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-1140"><a href="#cb9-1140" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">1</span>]<span class="op">=</span>np.mean(EIS<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-1141"><a href="#cb9-1141" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">2</span>]<span class="op">=</span>np.mean(Eprjst<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-1142"><a href="#cb9-1142" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">3</span>]<span class="op">=</span>np.mean(Eprmst<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-1143"><a href="#cb9-1143" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">4</span>]<span class="op">=</span>np.mean(Eprj<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-1144"><a href="#cb9-1144" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">5</span>]<span class="op">=</span>np.mean(Eprm<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-1145"><a href="#cb9-1145" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">1</span>,<span class="dv">6</span>]<span class="op">=</span>np.mean(Evmfn<span class="op">-</span>E)<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-1146"><a href="#cb9-1146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-1147"><a href="#cb9-1147" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">0</span>]<span class="op">=</span>np.sqrt(np.mean((Eopt<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-1148"><a href="#cb9-1148" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">1</span>]<span class="op">=</span>np.sqrt(np.mean((EIS<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-1149"><a href="#cb9-1149" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">2</span>]<span class="op">=</span>np.sqrt(np.mean((Eprjst<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-1150"><a href="#cb9-1150" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">3</span>]<span class="op">=</span>np.sqrt(np.mean((Eprmst<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-1151"><a href="#cb9-1151" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">4</span>]<span class="op">=</span>np.sqrt(np.mean((Eprj<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-1152"><a href="#cb9-1152" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">5</span>]<span class="op">=</span>np.sqrt(np.mean((Eprm<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-1153"><a href="#cb9-1153" aria-hidden="true" tabindex="-1"></a>Tabresult[<span class="dv">2</span>,<span class="dv">6</span>]<span class="op">=</span>np.sqrt(np.mean((Evmfn<span class="op">-</span>E)<span class="op">**</span><span class="dv">2</span>))<span class="op">/</span>E<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-1154"><a href="#cb9-1154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-1155"><a href="#cb9-1155" aria-hidden="true" tabindex="-1"></a>Tabresult<span class="op">=</span>np.<span class="bu">round</span>(Tabresult,<span class="dv">1</span>)</span>
<span id="cb9-1156"><a href="#cb9-1156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-1157"><a href="#cb9-1157" aria-hidden="true" tabindex="-1"></a>table<span class="op">=</span>[[<span class="st">"D'"</span>,Tabresult[<span class="dv">0</span>,<span class="dv">0</span>],Tabresult[<span class="dv">0</span>,<span class="dv">1</span>],Tabresult[<span class="dv">0</span>,<span class="dv">2</span>],Tabresult[<span class="dv">0</span>,<span class="dv">3</span>],Tabresult[<span class="dv">0</span>,<span class="dv">4</span>],Tabresult[<span class="dv">0</span>,<span class="dv">5</span>],Tabresult[<span class="dv">0</span>,<span class="dv">6</span>]],</span>
<span id="cb9-1158"><a href="#cb9-1158" aria-hidden="true" tabindex="-1"></a>      [<span class="st">"Relative error (\%)"</span>,Tabresult[<span class="dv">1</span>,<span class="dv">0</span>],Tabresult[<span class="dv">1</span>,<span class="dv">1</span>],Tabresult[<span class="dv">1</span>,<span class="dv">2</span>],Tabresult[<span class="dv">1</span>,<span class="dv">3</span>],Tabresult[<span class="dv">1</span>,<span class="dv">4</span>],Tabresult[<span class="dv">1</span>,<span class="dv">5</span>],Tabresult[<span class="dv">1</span>,<span class="dv">6</span>]],</span>
<span id="cb9-1159"><a href="#cb9-1159" aria-hidden="true" tabindex="-1"></a>    [<span class="st">"Coefficient of variation (\%)"</span>,Tabresult[<span class="dv">2</span>,<span class="dv">0</span>],Tabresult[<span class="dv">2</span>,<span class="dv">1</span>],Tabresult[<span class="dv">2</span>,<span class="dv">2</span>],Tabresult[<span class="dv">2</span>,<span class="dv">3</span>],Tabresult[<span class="dv">2</span>,<span class="dv">4</span>],Tabresult[<span class="dv">2</span>,<span class="dv">5</span>],Tabresult[<span class="dv">2</span>,<span class="dv">6</span>]]]</span>
<span id="cb9-1160"><a href="#cb9-1160" aria-hidden="true" tabindex="-1"></a>Markdown(tabulate(</span>
<span id="cb9-1161"><a href="#cb9-1161" aria-hidden="true" tabindex="-1"></a>  table, </span>
<span id="cb9-1162"><a href="#cb9-1162" aria-hidden="true" tabindex="-1"></a>  headers<span class="op">=</span>[<span class="st">""</span>,<span class="st">"$\Sigma^*$"</span>, <span class="st">"$\hat{\Sigma}^*$"</span>, <span class="st">"$\hat{\Sigma}_</span><span class="sc">{opt}</span><span class="st">$"</span>, <span class="st">"$\hat{\Sigma}_</span><span class="sc">{mean}</span><span class="st">$"</span>, <span class="st">"${\hat{\Sigma}^{+d}_</span><span class="sc">{opt}</span><span class="st">}$"</span>, <span class="st">"$\hat{\Sigma}^{+d}_</span><span class="sc">{mean}</span><span class="st">$"</span>, <span class="st">"vMFN"</span>],</span>
<span id="cb9-1163"><a href="#cb9-1163" aria-hidden="true" tabindex="-1"></a>    tablefmt<span class="op">=</span><span class="st">"pipe"</span>))</span>
<span id="cb9-1164"><a href="#cb9-1164" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<script>
for (const element of document.getElementsByClassName("pseudocode")){
    pseudocode.renderElement(element);
}
</script>
<script>
for (const element of document.getElementsByClassName("pseudocode")){
    pseudocode.renderElement(element);
}
</script>



</body></html>